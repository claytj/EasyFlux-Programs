'Version 01.05 for CR6 + CDM-A116 + IRGASON or (CSAT3A and EC150) + slow microclimate sensors, based on EasyFlux_DL for CR3000

'Requirements: EC100 OS version 08.01 or newer
'              CR6   OS version 09.02 or newer 
'              CDM-A100 OS version .04 or newer
'              CRBasic editor for revision (Revised under any other text editor may not compile)              

'Copyright (c), 2019 Campbell Scientific, Inc. All rights reserved.
'This program is intended for use with Campbell Scientific open-path eddy-covariance systems manufactured after Fall 2010 that use an IRGASON or (CSAT3A and EC150)
'along with microclimate sensors.
'The most common or “best practice” corrections are applied to fluxes in this program.  Consult the manual for details on these corrections.  It is the responsibility
'of the user to determine appropriateness of the corrections used. Campbell Scientific always recommends saving raw time series data in case reprocessing of raw data 
'is warranted. Furthermore, it is the responsibility of the user and associated researchers to determine the quality and fitness of any and all data,
'regardless of whether said data were processed by this program or another tool.

'Version numbers less than 1.00 of this program are not fully tested or officially released. Campbell Scientific is not responsible for any errors in data collected
'using program versions prior to 1.00.
  
'* SITE AND CALIBRATION CONSTANTS
' Search for the text string "Unique" in this code to find the lines below in this program where "Unique" site constants and sensor calibration constants are entered.
  
'********************************************
'*** USER-DEFINED CONFIGURATION CONSTANTS ***
'********************************************

'Start of Constants Customization Section
ConstTable (Const_Table)
  
'*PROGRAM FUNCTION CONSTANTS
Const SCN_INTV                 = 100         'Unique: measurement rate (ms): 40 ms (25 Hz), 50 ms (20 Hz), 100 ms (10 Hz) as Default, 200 ms (5 Hz), or 1000 ms (1 Hz)
Const SLW_SCN_INTV             = 5000        'Unique: slow sequence measurement rate (ms) >3000 ms and <6000ms (Note: SDI-12 sensors too slow for sub-second intervals). (5000 as Default)
Const OUTPUT_INTV              = 30          'Unique: online flux data output interval (minutes). (30 as Default)
Const DAY_FLUX_CRD             = 30          'Unique: number of days of Flux_AmeriFluxFormat, Flux_CSFormat, Flux_Notes table data to store in each file on the card. Number of files stored depends on card size. (30 as Default)
Const DAY_TSRS_CRD             = 1           'Unique: number of days of Time_Series table data to store in each file on the card. Number of files stored depends on card size.
Const NTCH_FRQ_SLW As Long     = 60          'Unique: slowsequence analog measurement integration time, 60 for 60Hz (e.g. in US, Canada, etc.) or 50 for 50Hz (e.g. in Europe, China, etc.)
Const ONE_FL_TABLE As Boolean  = FALSE       'Unique: Whether or not all half-hourly or hourly data in Flux_CSFormat and Flux_Notes are stored in one table (FALSE as default).

'*PERIPHERAL
Const DVC_CDM_A116 As Boolean  = FALSE       'Unique: A CDM-A116 is being used with the CR6 (FALSE as default. Required for full suite of energy balance sensors). 
#If (DVC_CDM_A116) Then  
Const CDM_SN       As Long     = 1001        'Unique: CDM-A116 serial number 
Const CPI_ADDR_CDM As Long     = 1           'Unique: CPI address for CDM-A116
Const CPI_DEVICE   As String   = "CDMA116"   'Unique: CDM Module name or identifier
#EndIf

'* GAS ANALYZER AND SONIC ANEMOMETER
Const IRGASON       As Boolean = TRUE        'Unique: IRGASON. TRUE as default. If TRUE, CSAT3A_EC150 must be set to FALSE 
Const CSAT3A_EC150  As Boolean = FALSE       'Unique: CSAT3A + EC150. FALSE as default. If TRUE, IRGASON must be set to FALSE.
Const SDM_CLCK_SPD  As Long    = 30          'Unique: 30 is default SDM clock speed (uS). May need to increase if using long cables and skipped scans are observed.
Const EC100SDM_ADDR As Long    = 1           'Unique: SDM address for EC100.
Const BANDWIDTH                = 20          'Unique: in Hz. For spectral analysis, set to 1/2 sampling freq. Options: 5, 10, 12.5, 20, or 25 Hz. For flux only, set 20 Hz (Default) if sampling freq is 10 Hz

'*GPS
Const SENSOR_GPS   As Boolean  = FALSE       'Unique: GPS16X-HVS GPS receiver with integrated antenna (FALSE as default).
Const UTC_OFST                 = -7          'Unique: The local standard time, in hours, from UTC/GMT. The time in Logan, UT, US is 7 hour behind UTC/GMT

'*FINE WIRE THERMOCOUPLE
Const SENSOR_FW    As Boolean  = FALSE       'Unique: FW1, FW3, or other fine wire thermocouple (FALSE as default).

'*TEMP/RH PROBE
Const SENSOR_T_RH As Boolean   = FALSE       'Unique: EE181, HC2S3 or HMP155A: temperature and relative humidity probe (FALSE as Default).
#If (SENSOR_T_RH) Then 
Const TMPR_MULT   As Float     =  0.14       'Unique: multiplier for temperature; EE181 = 0.1, HMP155A = 0.14, or HMP45C = 0.1 C mV-1.
Const TMPR_OFST   As Float     = -80.0       'Unique: offset for temperature; EE181 = -40, HMP155A = -80, or HMP45C = -40 C.
Const RH_MULT     As Float     =   0.1       'Unique: multiplier for RH: EE181 = 0.1, HMP155A = 0.1, or HMP45C = 0.1.
Const RH_OFST     As Float     =   0.0       'Unique: offset for RH: EE181 = 0; HMP155A = 0, or HMP45C = 0.
#EndIf 

'*RAIN GAGE
Const SENSOR_TE525  As Boolean = FALSE      'Unique: TE525mm rain gauge. FALSE as default.
#If (SENSOR_TE525) Then  
Const TE525_MULT    As Float   = 0.1        'Unique: multiplier for TE525MM =0.1 mm/tip, TE525 = 0.254 mm/tip, TE525WS = 0.254 mm/tip, TE525/WS w/ 8 in funnel 0.1459 mm/tip   
#EndIf 

'*PYRANOMETER
Const SENSOR_CS301 As Boolean  = FALSE      'Unique: CS300 pyranometer. FALSE as default. If true, SENSOR_NR01, _CNR4, _SN500, and _CS320 must be set to FALSE
#If (SENSOR_CS301)
Const PYRAN_MULT   As Float    = 5          'Unique: multiplier.
#EndIf

Const SENSOR_CS320 As Boolean  = FALSE      'Unique: CS320: pyranometer. FALSE as default. If true, SENSOR_NR01, _CNR4, _SN500, and _CS301 must be set to FALSE.
#If (SENSOR_CS320) Then  
Const CS320SDI_ADR             = 0          'Unique: SDI address for CS320
#EndIf
 
'*QUANTUM SENSOR
Const SENSOR_CS310 As Boolean  = FALSE      'Unique: CS310 Quantum Sensor. FALSE as default. If true, SENSOR_NR01, _CNR4, and _SN500 must be set to FALSE
#If (SENSOR_CS310) Then 
Const QUNTM_MULT As Float      = 100        'Unique: Multiplier [(umolPhoton m-2 s-1)/mV] 
#EndIf 

#If (DVC_CDM_A116) Then 

'*IR RADIOMETER
Const SENSOR_SI111 As Boolean  = FALSE      'Unique: SI111 Infrared radiometer. FALSE as default. If true, SENSOR_NR01, _CNR4, and _SN500 must be set to FALSE
#If (SENSOR_SI111) Then 
Const m0_SI111     As Float    =  1.41970e9 'Unique: calbration m0, differ for each sensor
Const m1_SI111     As Float    =  7.84100e6 'Unique: calbration m1, differ for each sensor
Const m2_SI111     As Float    =  82213     'Unique: calbration m2, differ for each sensor
Const b0_SI111     As Float    = -1.72150e7 'Unique: calbration b0, differ for each sensor
Const b1_SI111     As Float    =  1.85020e5 'Unique: calbration b1, differ for each sensor
Const b2_SI111     As Float    =  13114     'Unique: calbration b2, differ for each sensor
#EndIf 

#EndIf '(DVC_CDM_A116)

'*NRLITE 2 NET RADIOMETER
Const SENSOR_NRLIT As Boolean  = FALSE      'Unique: NR Lite2 net radiometer. FALSE as default. If true, SENSOR_NR01, _CNR4, and _SN500 must be set to FALSE
#If (SENSOR_NRLIT) Then 
Const NRLIT_SNSTVT As Float    = 16.0       'Unique: NR Lite2 Sensitivity as reported on sensor calibration sheet [uV/(W m-2)]
#EndIf 

'*NR01/CRR4/SN500 4-WAY NET RADIOMETER
Const SENSOR_NR01 As Boolean   = FALSE      'Unique: NR01 4-way net radiometer. FALSE as default. If true, SENSOR_NRLIT, _CNR4, _SN500, _CS301, _CS320, _CS310, and _SI111 must be set to FALSE
Const SENSOR_CNR4 As Boolean   = FALSE      'Unique: CNR4 4-way net radiometer. FALSE as default. If true, SENSOR_NRLIT, _NR01, _SN500, _CS301, _CS320, _CS310, and _SI111 must be set to FALSE
Const SENSOR_CNF4 As Boolean   = FALSE      'Unique: CNR4 heating and ventilation unit. If TRUE, SENOR_CNR4 must be true. FALSE as Default.
#If (SENSOR_NR01 OR SENSOR_CNR4) Then 
Const SW_IN_SNSTVT As Float    = 15.35      'Unique: NR01/CNR4 sensitivity of upward facing pyranometer as reported on sensor calibration sheet [uV/(W m-2)]
Const SWOUT_SNSTVT As Float    = 15.41      'Unique: NR01/CNR4 sensitivity of downward facing pyranometer as reported on sensor calibration sheet [uV/(W m-2)]
Const LW_IN_SNSTVT As Float    = 8.50       'Unique: NR01/CNR4 sensitivity of upward facing pyrgeometer as reported on sensor calibration sheet [uV/(W m-2)]
Const LWOUT_SNSTVT As Float    = 7.09       'Unique: NR01/CNR4 sensitivity of downward facing pyrgeometer as reported on sensor calibration sheet [uV/(W m-2)]
#EndIf

Const SENSOR_SN500 As Boolean  = FALSE      'Unique: NR01 4-way net radiometer. FALSE as default. If true, SENSOR_NRLIT, _CNR4, _NR01, _CS301, _CS320, _CS310, and _SI111 must be set to FALSE
#If (SENSOR_SN500) Then 
Const SN500SDI_ADR             = 0          'Unique: SDI address for SN500
#EndIf

'*TCAV SOIL TEMPERATURE PROBE
Const SENSOR_TCAV   As Boolean = FALSE       'Unique: TCAV type E thermocouple averaging soil temperature probes (FALSE as default).
#If (SENSOR_TCAV)    Then
Const NMBR_TCAV     As Long    = 2          'Unique: number of TCAV (Maximum is 3. 2 as default, NMBR_TCAV = NMBR_CS6xx = NMBR_HFP)
#EndIf
 
'*SOIL WATER CONTENT PROBE
Const SENSOR_CS616  As Boolean = FALSE      'Unique: CS616 water content reflectometers for volumetric soil moisture. FALSE as default. If true, SENSOR_CS65X must be set to FALSE
Const SENSOR_CS65X  As Boolean = FALSE      'Unique: CS650 or CS655: water content reflectometers for volumetric soil moisture. FALSE as default. If true, SENSOR_CS616 must be set to FALSE
#If (SENSOR_CS616 OR SENSOR_CS65X) Then  
Const NMBR_CS6xx    As Long    = 2          'Unique: number of CS616, CS650, or CS655 sensors (Maximum is 3, 2 as default, NMBR_CS6xx = NMBR_HFP = NMBR_TCAV)
#If (SENSOR_CS65X) Then 
Const CSSDI12_ADR1             = 1          'Unique: SDI address for CS65X #1 (not applicable if using only CS616)
#If (NMBR_CS6xx > 1) Then 
Const CSSDI12_ADR2             = 2          'Unique: SDI address for CS65X #2 (not applicable if using only CS616)
#EndIf
#If (NMBR_CS6xx > 2) Then 
Const CSSDI12_ADR3             = 3          'Unique: SDI address for CS65X #3 (not applicable if using only CS616)
#EndIf

#EndIf
#EndIf

'SOIL HEAT FLUX PLATE
Const SENSOR_HFP01   As Boolean  = FALSE    'Unique: HFP01 soil heat flux plates. FALSE as default. If true, SENSOR_HFP01SC must be set to FALSE
Const SENSOR_HFP01SC As Boolean  = FALSE    'Unique: HFP01SC self-calibrating soil heat flux plates. FALSE as default. If true, SENSOR_HFP01 must be set to FALSE
#If (SENSOR_HFP01 OR SENSOR_HFP01SC) Then  
Const NMBR_HFP       As Long     = 2        'Unique: number of HFP01 or HFP01SC sensors (Maximum is 3, 2 as default, NMBR_HFP = NMBR_TCAV = NMBR_CS6xx).
Const HFP_SNSTVT_1   As Float    = 62.0     'Unique: Sensitivity of HFP01 or HFP01SC #1 as reported on sensor calibration sheet [uV/(W m-2)]
#If (NMBR_HFP > 1) Then 
Const HFP_SNSTVT_2   As Float    = 62.0     'Unique: Sensitivity of HFP01 or HFP01SC #2 as reported on sensor calibration sheet [uV/(W m-2)]
#EndIf 
#If (NMBR_HFP > 2) Then
Const HFP_SNSTVT_3   As Float   = 62.0      'Unique: Sensitivity of HFP01 or HFP01SC #3 as reported on sensor calibration sheet [uV/(W m-2)]
#EndIf
#If (SENSOR_HFP01SC) Then  
Const CAL_INTERVAL              = 1440     'Unique:  HFP01SC insitu calibration interval (minutes) (Recommended >360 minutes. Only applicable to HFP01SC plates) .
#EndIf 

#EndIf 
EndConstTable
'End of Constants Customization Section

'* Composite Boolean variables for variables above
Const SENSOR_Rn            = (SENSOR_CNR4 OR SENSOR_NR01 OR SENSOR_SN500 OR SENSOR_NRLIT)
Const SENSOR_HFP           = (SENSOR_HFP01 OR SENSOR_HFP01SC)
Const SENSOR_CS6XX         = (SENSOR_CS616 OR SENSOR_CS65X)
Const SCAN_INTERVAL_WEIGHT = SLW_SCN_INTV/(60*1000*OUTPUT_INTV)           'Used to calculate the fraction of day time in an scan interval  

  
'***************************************************
'*** END OF USER-DEFINED CONFIGURATION CONSTANTS ***
'***************************************************
  
'*******************************************
'*** DEFAULT SETTING FOR CR6 AND PROGRAM ***
'******************************************* 
PipeLineMode
AngleDegrees         'Angle degree used throughout the program
SDMBeginPort(C1)     'Starting port for SDM (valid starting ports: C1, U1, U5, or U9). 
'*** END of DEFAULT SETTING FOR CR6 AND PROGRAM ***


'***********************************************
'*** ABBREVIATIONS IN COMMENTS AND VARIABLES ***
'***********************************************
'AG     analog ground
'amb    ambient 
'CSAT   CSAT3A or sonic anemometer in IRGASON
'CS6XX  CS616, CS650, or CS655
'CS65X  CS650 or CS655
'cumul  cumulative
'deg    degree
'dia    diameter
'diag   diagnostic
'dir    direction
'dist   distance
'f      flag (information or program control, dim variable)
'flg    flag (user interactive flag, public variable)
'FP     footprint
'Freq   frequency
'frac   fraction
'FTPRNT footprint
'FW     FW05, FW1, or FW3(FW is an abbreviation for fine wire thermocouple)
'G      ground (i.e. power ground)
'hfp    HFP01 or HFP01SC soil heat flux plate sensor
'intrst interest
'IRGA   EC150 or IRGASON InfraRed Gas Analyzer
'nmbr   number
'pct    percent
'press  Pressure
'Pyran  pyranometer
'RH     relative humidity
'rng    range
'QC     quality control or quality classification
'shf    soil heat flux
'sig    signal
'strgth strength
'win    within
'wnd    wind
'wtr    water


'*******************************
'*** NOTES AND EXPLANATIONS ***
'*******************************
'* SIGN CONVENTION
' Positive fluxes are away from the ground surface, and negative towards the ground surface.

'* LAGS
' Instrument scan lag: Before computing online fluxes and writing to the time series data table, an instrument scan lag for each variable is introduced
' to account for the fixed instrument delays so that any pair of variables for covariance are aligned at the time resolution of the scan rate. Scan lags
' depend on instrument settings and/or the datalogger scan interval. In the case of the IRGASON or EC150 with CSAT3A, the instrument delay is determined
' by the bandwidth setting in the EC100 electronics (see appendix A of IRGASON manual, Revision 6/14).  For analog measurements such as FW sensors,
' the measurements are assumed to have no scan delay. After instrument scan lags are applied, the data are recorded in the time series output table. 
' After instrument lag, any two variables from the flow to all sensors at the same time are paired as measured at the same time.  

' Sensing time lag: After the instrument scan lag is applied, an additional lag called the sensing time lag may be applied if there is a spatial separation
' between the scalar sensor (e.g. FW or IRGA) and CSAT. The sensing lag is positive if wind passed the CSAT first followed by the scalar sensor; otherwise,
' the sensing lag is negative. The size of sensing time lag depends on wind speed and sensor separation. An algorithm in the program selects a lag that maximizes
' covariances and is physically possible. The final outputs in the flux output table have sensing time lags applied.
' *** END OF NOTES AND EXPLANATIONS ***

'************************
'*** UNIT DEFINITIONS ***
'************************
'SYMBOL      UNIT
'C           Celsius
'degrees     angle degrees
'frac_v_wtr  Fraction volumetric water content
'g           grams
'J           Joules
'Hz          Hertz
'kg          kilograms
'kPa         kilopascals
'm           meters
'mg          milligrams
'mmol        millimoles
'mol         moles
'ms          milliseconds
's           seconds
'umol        micromoles
'usec        microseconds
'V           volts
'W           Watts
'*** UNIT DEFINITIONS ***
  

'**************************  
'*** WIRING INSTRUCTIONS ***
'***************************

'*** Beginning of Power Supply Wiring *** 
'CR6 BAT +     Positive of 12Vdc battery or external power supply 
'CR6 BAT -     Negative of 12Vdc battery or external power supply 

'CR6 CHG +     Positive of charger (used only if CR6 charger will charge battery)   
'CR6 CHG -     Negative of charger (used only if CR6 charger will charge battery)
'*** End of Power Supply Wiring *** 
  
'*** Beginning of EC100 Wiring *** 
'CR6 C1                                   EC100 SDM C1
'CR6 C2                                   EC100 SDM C2                   
'CR6 C3                                   EC100 SDM C3                   
'CR6 G                                    EC100 SDM G                    
  
' Positive of power supply or CR6 BAT +   EC100 12V
' Negative of power supply or CR6 BAT -   EC100 G                        
'*** End of EC100 Wiring *** 

#If (SENSOR_GPS) Then
Const GPS16X_PORT       = U1          'Pulse input channel
Const GPS16X_COM_PORT   = COMU1       'Pulse input channel
Const TIME_DIFF_RST_CR6 = 1.0         'The maximum difference in ms between the CR6 and GPS clocks before CR6 clock is reset.
'*** Beginning of GPS16X wiring ***
'CR6 U1     PPS (grey) 
'CR6 U2     TXD (white)
'CR6 G      Power switch to keep on (yellow) 
'CR6 G      Rx data, datalogger-based configuration (blue) 
'CR6 AG     Shield (clear)
  
'CR6 12V    Power positive (red) 
'CR6 G      Power negative (black)
'*** End of GPS16X wiring ***
#EndIf

#If (SENSOR_CS616) Then
Const CS616_ANALOG_INPUT = U3       'Starting single-ended analog input channel.
Const CS616_POWER_CTRL   = C4       'Control port for CS616.
'*** Beginning of CS616 wiring ***
'CR6 U3     Signal #1 (green)
'CR6 C4     Enable control #1 (orange)
'CR6 AG     Signal reference #1 (black)
'CR6 12V    Power #1 (red)
'CR6 G      Power ground #1 (clear)
#If (NMBR_CS6xx > 1) Then  
'CR6 U4     Signal #2 (green)
'CR6 C4     Enable control #2 (orange)
'CR6 AG     Signal reference #2 (black)
'CR6 12V    Power #2 (red)
'CR6 G      Power ground #2 (clear)
#EndIf 
#If (NMBR_CS6xx > 2) Then 
'CR6 U10     Signal #3 (green)
'CR6 C4     Enable control #3 (orange)
'CR6 AG     Signal reference #3 (black)
'CR6 12V    Power #3 (red)
'CR6 G      Power ground #3 (clear)
#EndIf  
'*** End of CS616 wiring ***
#EndIf
  
#If (SENSOR_CS65X) Then
Const CS65X_SDI12_PORT = U3       'SDI port.
'*** Beginning of CS65X wiring ***
'CR6 U3      SDI-12 data #1 (green)
'CR6 12V     SDI-12 power #1 (red)
'CR6 G       SDI-12 data/power reference #1 (black)
'CR6 G       Orange wire #1 (orange) is not used
'CR6 AG      Shield #1 (clear)
 #If (NMBR_CS6xx > 1) Then 
'CR6 U3      SDI-12 data #2 (green)
'CR6 12V     SDI-12 power #2 (red)
'CR6 G       SDI-12 data/power reference #2 (black)
'CR6 G       Orange wire #2 (orange) is not used   
'CR6 AG      Shield #2 (clear)
 #EndIf 
 #If (NMBR_CS6xx > 2) Then 
'CR6 U3      SDI-12 data #3 (green)
'CR6 12V     SDI-12 power #3 (red)
'CR6 G       SDI-12 data/power reference #3 (black)
'CR6 G       Orange wire #3 (orange) is not used   
'CR6 AG      Shield #3 (clear)
 #EndIf 
'*** End of CS65X wiring ***
#EndIf

#If (SENSOR_CNF4) Then 
Const CNF4_TACHMTR_INPUT = U5 
'CR6 U5     CNF4 tachometer signal (green)
'CR6 AG     CNF4 tachometer reference (grey)
#EndIf
  
#If (SENSOR_TE525) Then
Const TE525_PULSE_INPUT = U6                'Pulse input channel rain gauge.
'*** Beginning of TE525mm wiring ***
'CR6 U6      Precipitation signal (black)
'CR6 AG      Signal reference (white)
'CR6 AG      Shield (clear)
'*** End of TE525mm wiring ***
#EndIf
  
#If (SENSOR_T_RH) Then
Const TMPR_RH_ANALOG_INPUT = U7         
'*** Beginning of HC2S3, HMP, and EE181 wiring ***
'CR6 U7   Temperature signal (brown/yellow)
'CR6 U8   Relative humidity signal (white/blue)
'CR6 AG   Signal reference (yellow/white)
'CR6 AG   Shield (clear/clear)

'12V  Power (green/red)
'G    Power reference (grey/black)
'*** End of HC2S3, HMP, and EE181 wiring ***
#EndIf

#If (SENSOR_CS320) Then                                            'CS320 is not allowed to use if CNR4, NR01, SN500, or CS300 is used already
  Const CS320_SDI12_PORT = U9                                      'SDI port.
  '*** Beginning of Pyranometer wiring ***
  'CR6 U9    Pyranometer signal (white)
  'CR6 AG    Pyranometer signal reference (blue)
  'CR6 AG    Shield (clear)
  'CR6 12V   Pyranometer power positive (red)
  'CR6 G     Pyranometer power Negative (black)
  '*** End of pyranometer wiring ***
#EndIf

#If (SENSOR_NRLIT) Then
Const NRLITE_ANALOG_INPUT = U11
Const NRLITE_CAL = 1000.0/NRLIT_SNSTVT  'Multiplier for NR Lite [w/(m^2 mV)].
'*** Beginning of NR Lite wiring ***
'CR6 U11     Signal (white)
'CR6 U12     Signal reference (green)
'CR6 AG      Short jumper wire to U12
'CR6 AG      Shield (clear)
'*** End of NR Lite wiring ***
#EndIf

#If (DVC_CDM_A116) Then  
'*** Beginning of CDM-A116 Wiring to CR6 *** 
' CR6 CPI port                               CDM-A116 CPI PORT (Use Cat5 or Cat6 Ethernet cable)
' Positive of power supply or CR6 BAT +      CDM-A116 12V                      
' Negative of power supply or CR6 BAT -      CDM-A116 G                        
'*** End of CDM-A116 Wiring to CR6 *** 
#EndIf

#If (SENSOR_TCAV) Then
Const TCAV_ANALOG_INPUT = 1                  'Staring differential analog input channel in CDM-A116 for TCAV.
'*** Beginning of TCAV wiring ***
' CDM-A116 1H     Signal #1 (purple)
' CDM-A116 1L     Signal reference #1 (red)
' CDM-A116 AG     Shield #1 (clear)
#If (NMBR_TCAV > 1) Then 
' CDM-A116 2H     Signal #2 (purple)
' CDM-A116 2L     Signal reference #2 (red)
' CDM-A116 AG     Shield #2 (clear)
#EndIf 
#If (NMBR_TCAV > 2) Then 
' CDM-A116 3H     Signal #3 (purple)
' CDM-A116 3L     Signal reference #3 (red)
' CDM-A116 AG     Shield #3 (clear)
#EndIf 

'*** End of TCAV wiring ***
#EndIf
  
#If (SENSOR_HFP) Then
'Soil heat flux plates
Const SHF_ANALOG_INPUT = 5                     'Starting differential analog input channel in CDM-A116.
Data 1000.0/HFP_SNSTVT_1                       'Multiplier for HFP #1 [w/(m^2 mV)].
#If (NMBR_HFP >1) Then      
Data 1000.0/HFP_SNSTVT_2                       'Multiplier for HFP #2 [w/(m^2 mV)].
#EndIf
#If (NMBR_HFP >2) Then      
Data 1000.0/HFP_SNSTVT_3                       'Multiplier for HFP #3 [w/(m^2 mV)].
#EndIf                      

'*** Beginning of HFP01/HFP01SC wiring ***
' CDM-A116 5H     Signal #1 (white)
' CDM-A116 5L     Signal reference #1 (green)
' CDM-A116 AG     Shield #1 (clear)
#If (NMBR_HFP >1) Then 
' CDM-A116 6H     Signal #2 (white)
' CDM-A116 6L     Signal reference #2 (green)
' CDM-A116 AG     Shield #2 (clear)
#EndIf 
#If (NMBR_HFP >2) Then 
' CDM-A116 7H     Signal #3 (white)
' CDM-A116 7L     Signal reference #3 (green)
' CDM-A116 AG     Shield #3 (clear)
#EndIf 
'*** End of HFP01//HFP01SC wiring ***
  
#If (SENSOR_HFP01SC) Then
Const SHF_HEATER_ANALOG_INPUT = 13               'Starting differential analog input channel in CDM-A116 to measure the heater of HFP01SC #1.
'*** Beginning of HFP01SC heater wiring ***
' CDM-A116 13H    Heater resistor signal #1 (yellow)
' CDM-A116 13L    Heater resistor signal reference #1 (purple)
' CDM-A116 SW12-1 Heater power positive #1 (red)
' CDM-A116 G      Heater power negative #1 (black)
' CDM-A116 AG     Heater shield #1 (clear)
#If (NMBR_HFP > 1) Then 
' CDM-A116 14H    Heater resistor signal #2 (yellow)
' CDM-A116 14L    Heater resistor signal reference #2 (purple)
' CDM-A116 SW12-1 Heater power positive #2 (red)
' CDM-A116 G      Heater power negative #2 (black)
' CDM-A116 AG     Heater shield #2 (clear)
#EndIf
#If (NMBR_HFP > 2) Then 
' CDM-A116 16H    Heater resistor signal #3 (yellow)
' CDM-A116 16L    Heater resistor signal reference #3 (purple)
' CDM-A116 SW12-2 Heater power positive #3 (red)
' CDM-A116 G      Heater power negative #3 (black)
' CDM-A116 AG     Heater shield #3 (clear)
#EndIf 
'*** End of HFP01SC heater wiring ***
#EndIf
#EndIf 'Ends conditional code for all wiring of HFPs

#If (SENSOR_FW) Then
Const FW_ANALOG_INPUT = 15                    'Differential analog input channel in CDM-A116 for FW (Input channels 2, 3, 6, 7, 10, 11, 14, or 15 are recommended)
'*** Beginning of FW wiring ***
' CDM-A116 15H     FW signal (purple)
' CDM-A116 15L     FW signal reference (red)
' CDM-A116 AG      FW shield (clear)
'*** End of FW wiring ***
#EndIf  

#If (SENSOR_NR01 OR SENSOR_CNR4) Then
Const NR_ANALOG_INPUT   = 9                    '1st differential analog input channel CDM-A116 for a 4-way net radiation sensor.
Const T_NR_ANALOG_INPUT = 4                    'Differential analog input channel in CDM-A116 to measure body temperature of 4-way radiation sensor. 
Const SW_IN_CAL  = 1000/SW_IN_SNSTVT           'Multiplier for NR01/CNR4 shortwave downwelling (incoming) radiation [w/(m^2 mV)].
Const SW_OUT_CAL = 1000/SWOUT_SNSTVT           'Multiplier for NR01/CNR4 shortwave upwelling (outgoing) radiation [w/(m^2 mV)].
Const LW_IN_CAL  = 1000/LW_IN_SNSTVT           'Multiplier for NR01/CNR4 longwave downwelling (incoming) radiation [w/(m^2 mV)].
Const LW_OUT_CAL = 1000/LWOUT_SNSTVT           'Multiplier for NR01/CNR4 longwave upwelling (outgoing) radiation [w/(m^2 mV)].
#EndIf

#If (SENSOR_NR01) Then
Const T_NR_CURRENT_EXCITATION = X1             'Current excitation channel in CDM-A116.

'*** Beginning of NR01 wiring ***
'Cable 1
' CDM-A116 9H     Downwelling (incoming) shortwave radiation signal (red)
' CDM-A116 9L     Downwelling (incoming) shortwave radiation signal reference (blue)
' CDM-A116 AG     Shield (clear)
' CDM-A116 AG     Short jumper wire to 9L  
' CDM-A116 10H    Upwelling (outgoing) shortwave radiation signal (white)
' CDM-A116 10L    Upwelling (outgoing) shortwave radiation signal reference (green/black)
' CDM-A116 AG     Short jumper wire to 10L
' CDM-A116 11H    Downwelling (incoming) longwave radiation signal (brown/grey or orange)
' CDM-A116 11L    Downwelling (incoming) longwave radiation signal reference (yellow)
' CDM-A116 AG     Short jumper wire to 11L 
' CDM-A116 12H    Upwelling (outgoing) longwave radiation signal (purple or pink/brown)
' CDM-A116 12L    Upwelling (outgoing) longwave radiation signal reference (grey/green)
' CDM-A116 AG     Short jumper wire to 12L 
'Cable 2 
' CDM-A116 4H     Pt100 signal (white)
' CDM-A116 4L     Pt100 signal reference (green)
' CDM-A116 AG     Pt100 shield (silver/bare)
' CDM-A116 X1     Current excitation (red)
' CDM-A116 AG     Current excitation reference (blue)

#If (NOT SENSOR_HFP01SC) Then 
' CDM-A116 SW12-1   Heater power (brown, not used in this code)
' CDM-A116 G        Heater Ground (yellow)
#Else 
' CR6 SW12-1        Heater power (brown, not used in this code)
 ' CR6 G             Heater Ground (yellow)
#EndIf  

' CDM-A116 G      Ground (purple/pink) 
' CDM-A116 G      Shield (Grey) 
'*** End of NR01 wiring ***
#EndIf

#If (SENSOR_CNR4) Then
Const T_NR_VOLTAGE_EXCITATION = X1               'Voltage excitation channel in CDM-A116.

'*** Beginning of CNR4 wiring ***
'Cable 1
' CDM-A116 9H     Downwelling (incoming) shortwave radiation signal (red)
' CDM-A116 9L     Downwelling (incoming) shortwave radiation signal reference (blue)
' CDM-A116 AG     Shield (clear)
'                 Short jumper wire to 9L
' CDM-A116 10H    Upwelling (outgoing) shortwave radiation signal (white)
' CDM-A116 10L    Upwelling (outgoing) shortwave radiation signal reference (black)
' CDM-A116 AG     Short jumper wire to 10L
' CDM-A116 11H    Downwelling (incoming) longwave radiation signal (grey)
' CDM-A116 11L    Downwelling (incoming) longwave radiation signal reference (yellow)
' CDM-A116 AG     Short jumper wire to 11L
' CDM-A116 12H    Upwelling (outgoing) longwave radiation signal (brown)
' CDM-A116 12L    Upwelling (outgoing) longwave radiation signal reference (green)
' CDM-A116 AG     Short jumper wire to 12L
'Cable 2
' CDM-A116 4H     Thermistor signal (white)
' CDM-A116 AG     Thermistor signal reference (black)
' CDM-A116 AG     Shield (clear)
' CDM-A116 X1     Thermistor voltage excitation (red)

#If (SENSOR_CNF4) Then
Const CNF4_FAN_SW5_PORT = 1
Const CNF4_HEATER1_SW5_PORT = 2
Const CNF4_HEATER2_SW5_PORT = 3

' A21 REL-12 and CNF4 cable
' Ordered as shown in A21REL-12 

' A21 REL-12 +12V               Positive in an external 12V power source (Neither CR6 12V nor CDMA 12V)
' A21 REL-12 G (near +12V)      Negative in an external 12V power source (Neither CR6 12V nor CDMA 12V  

' A21 REL-12 G (near REL 1 COM) CNF4 ventilator, Heater 1, and heater 2 negative (brown, red, and blue)
'                               CDM-A116 G 

' A21 REL-12 REL 1 COM          Jump to A21 REL-12 +12V 
' A21 REL-12 REL 1 NO           CNF4 ventilator positive, 0.4A at 12 V (yellow)
' A21 CTRL 1                    CDM-A116 SW5V 1 (user-defined color)

' A21 REL-12 REL 2 COM          Jump to A21 REL 1 COM 
' A21 REL-12 REL 2 NO           CNF4 heater 1 positive, 0.5A at 12 V (White)
' A21 CTRL 2                    CDM-A116 SW5V 2 (user-defined color) 

' A21 REL-12 REL 3 COM          Jump to A21 REL 2 COM 
' A21 REL-12 REL 3 NO           CNF4 heater 2 positive, 0.5A at 12 V (Black)
' A21 CTRL 3                    CDM-A116 SW5V 3 (user-defined color) 

' CR6 U5                        CNF4 tachometer signal (green)
' CR6 AG                        CNF4 tachometer reference (grey)
 #EndIf                                             

'*** End of CNR4 wiring ***
#EndIf

#If (SENSOR_SN500) Then
Const SN500_SDI12_PORT = U9   'SDI input port.
'*** Beginning of SN500 wiring ***
'U9      SDI-12 data (white if SN1086 or later and black if SN1085 or earlier)
'12V     SDI-12 power (Red, external 12V power is recommended because SN500 has a heater))
'G       SDI-12 Ground (black if SN1086 or later and clear if SN1085 or earlier)
'        Shield #1 (clear if SN1086 or later and N/A if SN1085 or earlier))
'*** End of SN500 wiring ***
#EndIf  


#If (DVC_CDM_A116) Then  

#If (SENSOR_CS301) Then
Const PYRAN_ANALOG_INPUT  = 9     'Differential analog input channel in CDM-A116 for CS300 Pyranometer.
'*** Beginning of Pyranometer wiring ***
' CDM-A116 9H     Pyranometer signal (red)
' CDM-A116 9L     Pyranometer signal reference, jump to AG (black)
' CDM-A116 AG     Shield (clear)
'*** End of pyranometer wiring  ***
#EndIf
  
#If (SENSOR_CS310) Then
Const QUANTUM_ANALOG_INPUT  = 10     'Differential analog input channel in CDM-A116 for quantum PAR sensor
'*** Beginning of Quantum wiring ***
' CDM-A116 10H    Quantum signal (red)
' CDM-A116 10L    Quantum signal reference, jump to AG (black)
' CDM-A116 AG     Shield (clear)
'***  End of quantum wiring   ***
#EndIf
  
#If (SENSOR_SI111) Then
Const SI111_ANALOG_INPUT   = 11    'Differential analog input channel in CDM_116 for SI-111 sensor
Const SI111_EXCITATION     = X3    'Voltage excitation channel for SI-111 sensor
'*** Beginning of SI-111 precision infrared radiometer wiring ***
' CDM-A116 11H    SI111 target signal (red)
' CDM-A116 11L    SI111 target signal reference. Jump to AG (black)
' CDM-A116 AG     SI111 shield (clear)
' CDM-A116 12H    SI111 body temperature signal (green)
' CDM-A116 AG     SI111 body temperature signal reference (blue)
' CDM-A116 X3     SI111 voltage excitation (white)
'***  End of SI-111 precision infrared radiometer ***
#EndIf

#EndIf  '(DVC_CDM_A116)

'*** END OF WIRING INSTRUCTIONS *** 

'*************************************************
'*** BEGINNING OF STATION CONSTANTS AND VARIABLES ***
'*************************************************
Const NMBR_DAY_CPU     = 7                                          'Number of days of flux data to store on the CPU.
Const FLUX_SIZE_CPU    = Ceiling ((NMBR_DAY_CPU*1440)/OUTPUT_INTV)  'Number of records that are in NMBR_DAY_CPU [(days*1440 minutes/day)/(minutes/record)] = records].
Const OFFSET           = 46                                         'An offset delay for lagging irga and FW data against CSAT data (Max needed: (4000/5-Hz bandwidth)/50-Hz scan interval + 1 + MAM_LAG = 46.
Const SCAN_BUFFER_SIZE = 290*INT (1000/SCN_INTV)                    'Compute a 290-second scan buffer (The buffer less than 5 minutes because of 5-minute interval for QC-computational data tables.
Const FIRST_NOTCH_FREQ_MAIN_SCAN = 3750                             'Measurement integration frequency. The frequency of 3750 Hz allows CDM-A100 series to perform a 0.2667 ms integration for 20Hz main scan rate.

'***Variables used to estimate the number of days for MicroSD to be continuously used
Public card_bytes_free                                              'Free bytes of MicroSD in bytes
Dim    card_bytes_free_assgnd                                       'Free bytes of MicroSD that were assigned for more DataTable
Dim    card_bytes_free_unassgnd                                     'Free bytes of MicroSD were not asigned for more DataTables
Dim    day_snc_0101_1990                                            'Days since Jan 01, 1990. 

'Time_Series Table whose size is pre-allocated.
Dim bytes_rcd_Time_Series                                           'Bytes used in MicroSD for each record of Time_Series table  
Dim bytes_tbl_Time_Series                                           'Bytes used in MicroSD for one Time_Series table whose size in days is defined by a user  
Dim days_actv_tbl_Time_Series                                       'Days of free bytes inside active Time_Series table 
Dim days_more_tbl_Time_Series                                       'Days of free bytes for more Time_Series table  
Dim days_totl_tbl_Time_Series                                       'Total days of free bytes possibly used Time_Series table 

Public LastFileName_Time_Series      As String *36 = NaN            'Used to monitor the completion of Time_Series datatable                       
Dim    LastFileName_Time_Series_prev As String *36 = NaN   

'Flux Table in AmeriFlux format (not pre-allocated)
Dim bytes_rcd_AmeriFluxFormat                                       'Bytes used in MicroSD for each record of flux table in AmeriFluxFormat   
Dim bytes_tbl_AmeriFluxFormat                                       'Bytes used in MicroSD for one AmeriFluxFormat table  

'Flux table in CS format whose size is pre-allocated. 
Dim bytes_rcd_flux_CSFormat                                         'Bytes used in MicroSD for each record of flux table in CSFormat  
Dim bytes_tbl_flux_CSFormat                                         'Bytes used in MicroSD for one Flux_CSFormat table whose size in days is defined by a user  
#If (ONE_FL_TABLE) Then
Dim days_actv_tbl_flux_CSFormat                                     'Days of free bytes inside active Flux_CSFormat table 
Dim days_more_tbl_flux_CSFormat                                     'Days of free bytes for more Flux_CSFormat table
Dim days_totl_tbl_flux_CSFormat                                     'Total days of free bytes possibly used for Flux_CSFormat table
#Else
'Flux notes table whose size is pre-allocated.   
Dim bytes_rcd_flux_notes                                            'Bytes used in MicroSD for each record of Flux_CSFormat table  
Dim bytes_tbl_flux_notes                                            'Bytes used in MicroSD for one Flux_CSFormat table whose size in days is defined by a user  
Dim days_actv_tbl_flux_CSFormat_notes                               'Days of free bytes inside active Flux_CSFormat and Flux_notes tables 
Dim days_more_tbl_flux_CSFormat_notes                               'Days of free bytes for more Flux_CSFormat and Flux_notes tables 
Dim days_totl_tbl_flux_CSFormat_notes                               'Total days of free bytes possibly used for Flux_CSFormat and Flux_notes tables 
#EndIf 
Public LastFileName_flux_CSFormat       As String *36               'Used to monitor the completion of Flux_in CSFormat table                       
Public LastFileName_flux_CSFormat_prev  As String *36   

Public card_storage_available_days                                  'The number of extra days for MicroSD to store more data. This variable will be referenced by EasyFlux_web
Units  card_storage_available_days = days

'Variables for constructing time stamp in AmeriFlux format
Dim CR6_clock As String *22
Public TimeStamp_AmeriFluxFormat(2) As String *12
Alias TimeStamp_AmeriFluxFormat(1) = TIMESTAMP_START
Alias TimeStamp_AmeriFluxFormat(2) = TIMESTAMP_END  

Dim stn_conf_array_file      As Long             'Filehandle for the configuration data stored in the CPU.
Dim stn_conf_array_file_size As Long             'Size of the station configuration file stored on the CPU.

Const NMBR_STN_VAR       = (17 - 1*SENSOR_GPS - 3*SENSOR_FW - 3*((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))))   'Number of station variables below
Public stn_conf_array(NMBR_STN_VAR)              'These station parameters are entered using the datalogger keypad while program is running after compiled.
Alias stn_conf_array(1)  = sonic_azimuth         'Azimuth angle (degrees) (see Section 3.1.1 CSAT3A Azimuth in the OPEC manual).
Alias stn_conf_array(2)  = latitude              'Latitude (degrees)
Alias stn_conf_array(3)  = hemisphere_NS         '"1" for north and "-1" for south, following GPS convention
Alias stn_conf_array(4)  = longitude             'Longitude (degrees)
Alias stn_conf_array(5)  = hemisphere_EW         '"1" for east and "-1" for west, following GPS convention
Alias stn_conf_array(6)  = altitude              'Altitude (m)
Alias stn_conf_array(7)  = height_measurement    'Measurement height (m)
Alias stn_conf_array(8)  = surface_type          'crop = 1, grass = 2, forest = 3, shrub = 4, bare land = 5, and water = 6
Alias stn_conf_array(9)  = height_canopy         'canopy height (m).
Alias stn_conf_array(10) = displacement_user    'User-entered displacement height (m) [If 0 (default), then auto calculate]
Alias stn_conf_array(11) = roughness_user        'User-entered roughness length (m) [If 0 (default), then auto calculate and continuously updated by recalculation when netrual stratification]
Alias stn_conf_array(12) = separation_x_irga     'x coordinate of IRGA optical path center along the CSAT x-coordinate axis (m)
Alias stn_conf_array(13) = separation_y_irga     'y coordinate of IRGA optical path center along the CSAT y-coordinate axis (m)
Alias stn_conf_array(14) = dist_intrst_60_300    'Distance of interest for wind directions 0~<=60 and >300~360 degrees in CSAT coordinate system (m)
Alias stn_conf_array(15) = dist_intrst_60_170    'Distance of interest for wind directions >60 and <=170 degrees in CSAT coordinate system (m)
Alias stn_conf_array(16) = dist_intrst_170_190   'Distance of interest for wind directions >170 and <=190 degrees in CSAT coordinate system (m)
Alias stn_conf_array(17) = dist_intrst_190_300   'Distance of interest for wind directions >190 and <=300 degree in CSAT coordinate system (m)

Units sonic_azimuth       = Decimal degrees
Units latitude            = Decimal degrees
Units hemisphere_NS       = adimensional         '"adimensional" indicates no units (i.e dimensionless)
Units longitude           = Decimal degrees
Units hemisphere_EW       = adimensional         '"adimensional" indicates no units (i.e. dimensionless)
Units altitude            = m
Units height_measurement  = m
Units surface_type        = adimensional         '"adimensional" indicates no unit (i.e. dimensionless)
Units height_canopy       = m
Units displacement_user   = m
Units roughness_user      = m
Units separation_x_irga   = m
Units separation_y_irga   = m
Units dist_intrst_60_300  = m
Units dist_intrst_60_170  = m
Units dist_intrst_170_190 = m
Units dist_intrst_190_300 = m

#If (SENSOR_GPS) Then
Alias stn_conf_array(18) = height_GPS16X         'GPS installation height above the ground surface (m)
Units height_GPS16X      = m
#EndIf

#If (SENSOR_FW) Then
Alias stn_conf_array(18 - 1*SENSOR_GPS) = separation_x_FW   'Coordinate x of FW junction in the CSAT coordinate system (m)
Alias stn_conf_array(19 - 1*SENSOR_GPS) = separation_y_FW   'Coordinate y of FW junction in the CSAT coordinate system (m)
Alias stn_conf_array(20 - 1*SENSOR_GPS) = FW_diameter       'Diameter of fine wire (m)
Units separation_x_FW = m
Units separation_y_FW = m
Units FW_diameter     = m
#EndIf

#If (SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X)) Then
Alias stn_conf_array(18 - 1*SENSOR_GPS - 3*SENSOR_FW) = soil_bulk_density    'Soil bulk density (kg/m^3)
Alias stn_conf_array(19 - 1*SENSOR_GPS - 3*SENSOR_FW) = Cds                  'Specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
Alias stn_conf_array(20 - 1*SENSOR_GPS - 3*SENSOR_FW) = thick_abv_SHFP       'Thickness of soil above soil heat flux plate (m)
Units soil_bulk_density  = kg m-3
Units Cds                = J kg-1 k-1
Units thick_abv_SHFP      = m
#EndIf

Dim stn_conf_array_prev(NMBR_STN_VAR)                     'Hold previous station parameters to check for new user-entered values

'After a user inputs, used to assign a sign to latitude and longitude
Const NORTH =  1
Const SOUTH = -1
Const EAST  =  1
Const WEST  = -1

'Used to assign a value for surface_type
Const CROP     = 1
Const GRASS    = 2
Const FOREST   = 3
Const SHRUB    = 4
Const BARELAND = 5
Const WATER    = 6
Const ICE      = 7

Dim surface_type_array(7) As String * 9 = {"Crop", "Grass", "Forest", "Shrub", "Bare land", "Water", "Ice"}
Dim surface_type_text     As String * 9   'Used to record the surface type in data table

#If (SENSOR_FW) Then
Const FW05DIA  = 1.27e-5                  'Diameter of FW05 fine wire that is selected for FW diameter(m)
Const FW1_DIA  = 2.54e-5                  'Diameter of FW1 fine wire that is selected for FW diameter(m)
Const FW2_DIA  = 5.08e-5                  'Diameter of FW2 fine wire that is selected for FW diameter(m)
Const FW3_DIA  = 7.62e-5                  'Diameter of FW3 fine wire that is selected for FW diameter(m)
#EndIf

'*** END OF STATION CONSTANTS AND VARIABLES ***

#If (SENSOR_GPS) Then
'************************************************
'*** BEGINNING GPS16X CONSTANTS AND VARIABLES ***
'************************************************
Dim nmea_sentence(2) As String * 100         'Hold NMEA sentences: nmea_sentence(1) for GPRMC and nmea_sentence(2) for GPGGA.

Dim gps_array(15)
Alias gps_array(1) = latitude_GPS_degree     'Degrees latitude (+ = North; - = South)
Alias gps_array(2) = latitude_GPS_minute     'Minutes latitude
Alias gps_array(3) = longitude_GPS_degree    'Degrees longitude (+ = East; - = West)
Alias gps_array(4) = longitude_GPS_minute    'Minutes longitude
Alias gps_array(5) = speed                   'Speed
Alias gps_array(6) = course                  'Course over ground
Alias gps_array(7) = magnetic_variation      'Magnetic variation from true north (+ = East; - = West)
Alias gps_array(8) = fix_quality             'GPS fix quality: 0 = invalid, 1 = GPS, 2 = differential GPS, 6 = estimated
Alias gps_array(9) = nmbr_satellites         'Number of satellites used for fix
Alias gps_array(10) = altitude_GPS           'Antenna altitude (m)
Alias gps_array(11) = pps                    'usec into sec of system clock when PPS rising edge occurs, typically 990,000 once synced
Alias gps_array(12) = dt_since_gprmc         'Time since last GPRMC string, normally less than 1 second
Alias gps_array(13) = gps_ready              'Counts from 0 to 10, 10 = ready
Alias gps_array(14) = max_clock_change       'Maximum value the clock was changed in msec
Alias gps_array(15) = nmbr_clock_change      'Number of times the clock was changed
Units latitude_GPS_degree    = degrees
Units latitude_GPS_minute    = minutes
Units longitude_GPS_degree   = degrees
Units longitude_GPS_minute   = minutes
Units speed                  = m s-1
Units course                 = decimal degrees
Units magnetic_variation     = decimal degrees
Units fix_quality            = adimensional
Units nmbr_satellites        = counts
Units altitude_GPS           = m
Units pps                    = us
Units dt_since_gprmc         = s
Units gps_ready              = adimensional
Units max_clock_change       = ms
Units nmbr_clock_change      = counts

Dim gps_ready_best As Long
'*** END OF GPS16X CONSTANTS AND VARIABLES ***
#EndIf

'*** Variables for solar position ***  
Public solar_position_array(5)
Alias solar_position_array(1) = sun_azimuth
Alias solar_position_array(2) = sun_elevation
Alias solar_position_array(3) = hour_angle
Alias solar_position_array(4) = sun_declination
Alias solar_position_array(5) = air_mass_coeff
Units sun_azimuth     = decimal degrees
Units sun_elevation   = decimal degrees
Units hour_angle      = decimal degrees
Units sun_declination = decimal degrees
Units air_mass_coeff  = adimensional

Public daytime As Long             'Day = 1 and night = 0
Dim    daytime_frac_scan_intv      'To calculate the day time fraction in an output interval using Totalize instruction  
Units  daytime_frac_scan_intv = fraction  
  
'*** End of variables for solar position ***  
  
 '*** BEGINNING OF REAL TIME VARIABLES ***   
 Dim realtime_array(9)             'Hold real time to calculated the time length of the 1st time averaging interval that starts anytime   
 '*** END OF REAL TIME VARIABLES *** 
 
'*****************************************************************
'*** BEGINNING CONSTANTS AND VARIABLES FOR ATMOSPHERIC PHYSICS ***
'*** [Unless noted, see page 467 in Wallace AND Hobbs (2006)]  ***
'*****************************************************************
    
Const Cpd     = 1004.0             'specific heat of dry air at constant pressure [J/(kg K)]
Const Cpw     = 1952.0             'specific heat of water vapor at constant pressure [J/(kg K)]
Const Cw      = 4218.0             'specific heat of liquid water at 0 C [J/(kg K)]
Const epsilon = 18.016/28.97       'molecular mass ratio of water vapor to dry air
Const g0      = 9.81               'acceleration due to gravity at sea level (m/s^2)
Const k       = 0.41               'von Karman constant (Dyer & Hicker 1970, Webb 1970)
Const MU_WPL  = 28.97/18.016       'molecular mass ratio of dry air to water vapor (used in WPL correction)
Const Omega   = 7.292e-5           'Angular velocity of the earth for calculation of Coriolis Force (2PI/sidreal_day, where sidereal day = 23 hr 56 min. [rad/s]
Const R       = 8.3143e-3          'Universal gas constant [kPa m^3/(K mol)]
Const Rd      = R/28.97            'Gas constant for dry air [kPa m^3/(K g)]
Const Rv      = R/18.016           'Gas constant for water vapor [kPa m^3/(K g)]
Const PI      = 3.1415926          'Pi (just use the seven digits after decimal, commonly used) 
Const Sigma_SB= 5.6718e-8          'Stefan-Boltzmann constant in air [J/(K^4 m^2 s), see page 336 in McGee (1988)] 
Const T_0C_K  = 273.15             'Temperature in K at 0 degree C

Public Cp                          'specific heat of moist air at constant pressure, calculated using measurements from EC100 data [J/(kg deg C)]
Units  Cp = J kg-1 deg C-1

Public Lv                          'Latent heat of vaporization, calculated using air temperature [J/g].
Units  Lv = J g-1
'*** END OF CONSTANTS AND VARIABLES FOR ATMOSPHERIC PHYSICS ******

'*******************************************
'*** BEGIN PROGRAM WORKING VARIABLES ***
'*******************************************
Dim scan_count                 As Long       'Number scans executed. Working variable used to judge the scan loop, from which data processing starts.

Dim slowsequence_finished_f   As Boolean     'Flag used to indicate that the slowSequence has finished its scan.
Dim slowsequence_disable_f    As Boolean     'Flag used to decimate statistics in main scan.

Dim i, i_slow, j_slow, k_slow As Long        'Index variables for the outmost loop. "i" in main scan and "i_slow" in slow scan sequence
Dim array_index               As Long        'Used for array index that must be calculated using loop index (to simplify expression and reduce computation for array index)

Dim n As Long = 1                            'Used to count the number of samples
Units n = samples

Dim dly_data_out(8)                          'Array used to temporarily store the lagged record from the raw data table (hidden)

Dim x_tmp, T_tmp                             'Temporary variable used in intermediate calculations

Dim truefalse(2) As String * 5 = {"TRUE", "FALSE"} 'Use to store a Boolean variable to a string of TRUE or FALSE

Dim process_time                             'Used to monitor processing time and reported in flux_notes table
Units process_time = ms                      'Converted from us to ms that is easy to read

Dim buff_depth                               'Used to monitor buffer depth and reported in flux_notes table
Units buff_depth = scans
'*** END OF PROGRAM WORKING VARIABLES ***


'*******************************************************
'*** BEGIN DATALOGGER SELF-MEASUREMENT VARIABLES ***
'*******************************************************
Public panel_tmpr                                          'CR6 panel temperature 
Units  panel_tmpr = deg C

#If (DVC_CDM_A116) Then
'*** Beginning of CDM-A116 panel temperature ***
Public panel_tmpr_CDM_A116(4)
Alias  panel_tmpr_CDM_A116(1) = panel_tmpr_CDM_A116_1      'CDM-A116 panel temperature #1
Alias  panel_tmpr_CDM_A116(2) = panel_tmpr_CDM_A116_2      'CDM-A116 panel temperature #2
Alias  panel_tmpr_CDM_A116(3) = panel_tmpr_CDM_A116_3      'CDM-A116 panel temperature #3
Alias  panel_tmpr_CDM_A116(4) = panel_tmpr_CDM_A116_4      'CDM-A116 panel temperature #4
'*** End of CDM-A116 panel temperature ***      
#EndIf 

Public batt_volt                                           'Voltage of power connected to CR6
Units  batt_volt  = V
'*** END OF DATALOGGER SELF-MEASUREMENT VARIABLES ***
 

'*******************************************************
'*** BEGINNING OF CORRECTION CONSTANTS AND VARIABLES ***
'*******************************************************
' Rotation angles from the instrument to the natural flow coordinate system. Notations are consistent with Wilczak et al (2001)
Public alpha                                'Angle of counterclockwise rotation about y-axis (pitch)
Public beta                                 'Angle of counterclockwise rotation about x-axis (roll)
Public gamma                                'Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha = Decimal degrees
Units  beta  = Decimal degrees
Units  gamma = Decimal degrees

Public alpha_5min                            '5-minute data for data QC. Angle of counterclockwise rotation about y-axis (pich)
Public beta_5min                             '5-minute data for data QC. Angle of counterclockwise rotation about x-axis (roll)
Public gamma_5min                            '5-minute data for data QC. Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha_5min = Decimal degrees
Units  beta_5min  = Decimal degrees
Units  gamma_5min = Decimal degrees

' Rotation angles for planar fit rotations
'1) Program chooses planar fit rotation of Wilczak et al. (2001) if one of the eight angles in an array: planar_fit_angle_conf_array(4,2) is not zero.
'2) Program chooses conventional rotation of Tanner and Thurtell (1969) if the following eight angles are all zero.
Dim planar_fit_angle_conf_array_file      As Long           'Filehandle for the planar fit angle configuration data stored in the CPU.
Dim planar_fit_angle_conf_array_file_size As Long           'Size of the station configuration file stored on the CPU.
Dim planar_fit_angle_conf_array_prev(4,2)                   'Remembering variable: Hold previous angles for Planar Fit

Public planar_fit_angle_conf_array(4,2)                     'Hold angles for Planar Fit in the four sectors as described below
Units  planar_fit_angle_conf_array      = Decimal degrees

' Alpha_PF_xxx_xxx angle between instrument and natural flow z-axis in the instrument x-z plane.
Alias planar_fit_angle_conf_array (1,1) = alpha_PF_60_300   'for wind direction of 0~<=60 and >300~360 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (2,1) = alpha_PF_60_170   'for wind direction of >60  and <=170 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (3,1) = alpha_PF_170_190  'for wind direction of >170 and <=190 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (4,1) = alpha_PF_190_300  'for wind direction of >190 and <=300 degrees in the CSAT coordinate system [degrees]

' Betal_PF_xxx_xxx angle between instrument and natural flow z-axis in the instrument y-z plane.
Alias planar_fit_angle_conf_array (1,2) = beta_PF_60_300    'for wind direction of 0~<=60 and >300~360 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (2,2) = beta_PF_60_170    'for wind direction of >60  and <=170 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (3,2) = beta_PF_170_190   'for wind direction of >170 and <=190 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (4,2) = beta_PF_190_300   'for wind direction of >190 and <=300 degrees in the CSAT coordinate system [degrees]

Public Planar_Fit_flg As Boolean                            'TRUE if Planar Fit is used (e.g. any element of planar_fit_angle_conf_array() is not zero)

' Atmospheric stability
Public MO_LENGTH                             'Monin-Obukhov length (m)
Public PBLH                                  'planetary boundary layer height (m)  
Public d                                     'displacement height (m)
Public z0                                    'roughness length (m)
Public z                                     'aerodynamic height: z = measurement height - d  (m)
Dim    z_prev                                'Previous z, used to judge whether or not the distance of interest needs to be re-evaluated 
Public ZL                                    'atmospheric surface-layer stability (dimensionless)
Dim    ZL_prev                               'previous ZL (dimensionless)
Units  MO_LENGTH  = m
Units  PBLH       = m 
Units  d          = m
Units  z0         = m
Units  z          = m
Units  ZL         = adimensional

' Constants used for numerical integration in calculating the freq correction factors
Const START_FREQ           = 10e-6     'Starting cyclic freq for numerical integration of cospectrum times transfer function
Const END_FREQ             = 10000.0   'Ending cyclic freq for numerical integration of cospectrum times transfer function
Const FREQ_BIN             = 100.0     'The number of bins for cyclic freq
Const STEP_BASE_FREQ       = EXP((LN(END_FREQ)- LN(START_FREQ))/FREQ_BIN)   'freq interval base for numerical integration of cospectra and transfer functions (e.g. 100 bins from 0.000001 to 10000 Hz).
Const ACCURACY_FREQ_FACTOR = 0.0001    'The accuracy target of freq factor to approach the "true" value (|current freq factor - previous freq factor|) [page 106: Foken et al. (2012)]
Const MAX_LAG              = 5         'Maximum number of lags in scans that is used to maximizing the covariance. This number of 2 is believed to be adequate for CSAT with EC150 and/or FW


' Frequency (freq) correction
Public iteration_FreqFactor As Long                             'count iterations while correcting wu, wv, and wTs for accurate Monin-Obukhov length
Public FreqFactor_UW_VW         = 1                            'freq correction factor for covariance of vertical with horizontal wind that are measured using CSAT
Dim    FreqFactor_UW_VW_Prev    = 1 - 2*ACCURACY_FREQ_FACTOR   'previous FreqFactor_UW_VW
Public FreqFactor_WT_SONIC      = 1                            'freq correction factor for covariance of vertical wind with sonic temperature that are measured using CSAT
Dim    FreqFactor_WT_SONIC_Prev = 1 - 2*ACCURACY_FREQ_FACTOR   'previous FreqFactor_WT_SONIC
Public FreqFactor_WCO2_WH2O     = 1                            'freq correction factor for covariance of vertical wind with IRGA h2o or co2 that are measured using a CSI OPEC system 
Units FreqFactor_UW_VW     = adimensional
Units FreqFactor_WT_SONIC  = adimensional
Units FreqFactor_WCO2_WH2O = adimensional

#If (SENSOR_FW) Then
Public FreqFactor_WFW                        'freq correction factor for covariance of vertical wind with temperature that are measured using CSAT and FW
Units  FreqFactor_WFW = adimensional
#EndIf

' ------ Numerical wTs transfer function Dijk (2002): alternatively kl and transfer function value where k is wavenumber and l is path length ------
' Hold following numerical values of transfer function of line averaging for wTs of CSAT measurements from Table 1 in Dijk (2012)
Dim tran_func_LA_data_Dijk(2,35) = { _
0.00,0.01,0.10,0.20,0.50,1.00,1.20,1.40,1.60,1.80,2.00,2.20,2.40,2.60,2.80,3.00,4.00,5.00,6.00,7.00,8.00,9.00,10.0,14.0,20.0,30.0,40.0,50.0,60.0,70.0,80.0,90.0,100,300,10000, _
1.00000,1.00000,0.99920,0.99760,0.99000,0.96700,0.95500,0.94170,0.92740,0.91220,0.89620,0.87970,0.86260,0.84520,0.82740,0.80960,0.72010,0.63530, _
0.55880,0.49220,0.43550,0.38790,0.34810,0.24450,0.17000,0.11340,0.08503,0.06802,0.05668,0.04859,0.04251,0.03779,0.03401,1.89888e-2,1.6168e-4}  
' The data points were extended to kl= 300 and 10000 according to the numerical derivative of transfer function with respect to kl from kl= 70 to 100.
' ----------------------------------------- End of numerical wTs transfer function values from Dijk (2002) ------------------------------------------
'*** END OF CORRECTION CONSTANTS AND VARIABLES ***


'******************************************************************************************
'*** BEGINNING OF EC100 CONFIGURE, ZERO, AND SPAN: CONSTANTS, VARIABLES, AND SUBROUTINE ***
'******************************************************************************************
'Constants and variables that are used to select options in data pad 
Const BB          = 0                    'BB = 0 for EC100 built-in Basic Barometer (EC100 built-in basic pressure transducer)
Const UB          = 1                    'UB = 1 for EC100 User-added Barometer (pressure transducer)
Const EB          = 2                    'EB = 2 for EC100 CS106, Enhanced Barometer (pressure transducer)
Const POWER_ON    = 0                    'IRGA power on 
Const POWER_OFF   = 1                    'IRGA power off
Const HEATER_AUTO = -2                   'Heater auto
Const HEATER_MAX  = 0                    'Heater max at 4.5375 V. 
Const HEATER_OFF  = -1                   'Heater off
Const FAST_ON     = TRUE                 'Use the alternative CO2 density that is computed from Ts and H2O for spectroscopic effects (see Helbig et al. 2016).
Const FAST_OFF    = FALSE                'Conventional CO2
Const CORR_ON     = 1                    'ON = apply shadow correction 
Const CORR_OFF    = 0                    'OFF = do not apply shadow correction

Public press_source                      'Hold current option of pressure tranducer
Public heater                            'Hold current option of heater 
Public IRGA_power_off                    'Hold current status of IRGA power
Dim    CO2_fast_tmpr        As Boolean = TRUE 'Hold current option of CO2 for computation 
Public select_CO2_fast_tmpr As Boolean = TRUE 'Used to change CO2_fast_tmpr after confirmation by set_CO2_fast_tmpr_flg as true   
Public shadow_corr                       'Hold current option of shadow correction

Public CO2_span_gas                      'CO2 standard gas for CO2 span (umol/mol, read from the CO2 gas cylinder bottle)
Units  CO2_span_gas = umol mol-1
Public T_DP_span_gas                     'Dew point temperature for H2O span (C, read from the setting of dew point generator)
Units  T_DP_span_gas = deg C
'Constants used to pre-configue EC100
Const DIFFERENTIAL_PRESS  = 0            '0 = disabled. Not applicable to an OPEC system. Should be disabled  
Const PRESS_SOURCE_OPTION = BB           '0 = built-in Basic Barometer, 1 = User-added Barometer, 2 = Enhanced Barometer (i.e. CS106)   
Const TEMPERATURE_SOURCE  = 0            '0 = defaut ambient temperature sensor that gas analyzer has
Const HEATER_OPTION       = HEATER_AUTO  '-2= heater auto,-1 = heater off, and 0 = heater max at 4.5375 V
Const SHADOW_CORR_OPTION  = CORR_OFF     '1 = on, 0 = off  

'Array used to configue EC100
Dim ec100_setting_array(10, 2) = {100, NAN, 102, NAN, 107, NAN, 114, NAN, 115, NAN, 116, NAN, 117, NAN, 118, NAN, 121, NAN, 125, NAN}  'Used to get the EC100 current setting for notes
Dim ec100_reset_array  (10, 2) = {0,   NAN,   2, NAN,   7, NAN,  14, NAN,  15, NAN,  16, NAN,  17, NAN,  18, NAN,  21, NAN,  25, NAN}  'Used to reset the EC100 configuration for notes
Dim config_ec100_array (6, 2)  = {0, BANDWIDTH, 2, PRESS_SOURCE_OPTION, 3, DIFFERENTIAL_PRESS, 7, TEMPERATURE_SOURCE, 18, HEATER_OPTION, 25, SHADOW_CORR_OPTION}
Dim press_source_array (1, 2)  = {2, NAN}          '1st col 2--> barometer set commend, 2nd col  pressure source, BB=0--> EC100 built-in Basic Barometer, EB=2 Enhanced Barometer.
Dim zero_array         (1, 2)  = {11, 1}           'Used for zeroing operation: 1st col 11--> Zero/Span command, 2nd col 0--> Inactive, 1--> Zero, 2--> SpanCO2, 3--> SpanH2O.
Dim span_CO2_array     (2, 2)  = {12, 0, 11, 2}    'Used for CO2 span operation: 1st col 12->CO2 concentration span, 2nd col CO2 span concentration value (0 as default), 3rd and 4th cols are zero_array above.
Dim span_H2O_array     (2, 2)  = {13, 0, 11, 3}    'Used for H2O span operation: 1st col 13->H2O dew point temperature span, 2nd col span dew point temperature (0 as default), 3rd and 4th cols are zero_array above.
Dim heater_option_array(1, 2)  = {18, NAN}         '1st col: 18 controls lense heaters of gas analyzer, 2nd col: HEATER = -2 auto, HEATER = 0 max at  4.5375 V, HEATER = -1 off. 
Dim IRGA_power_array   (1, 2)  = {21, 0}           'Used for power off IRGA (not for EC100): 1st col 21 control power commend and 2nd col 0 --> power on and 1 --> power off IRGA
Dim shadow_corr_array  (1, 2)  = {25, NAN}         'Apply sonic shadow correction, value read from EC100 on compile.

'Flags to configure EC100 
Dim    config_ec100_f          As Boolean = TRUE   'Default: Configure EC100 as soon as this program starts
Dim    config_ec100_initial_f  As Boolean = TRUE   'Default: Configure EC100 as soon as this program starts
Dim    get_ec100_config_f      As Boolean = TRUE   'The flag to meet the variable needed in SUB Config. Kept true all time.  

Public set_press_source_flg  As Boolean
Public set_zero_flg          As Boolean
Public set_CO2_span_flg      As Boolean
Public set_H2O_span_flg      As Boolean
Public set_heater_flg        As Boolean
Public set_IRGA_power_flg    As Boolean
Public set_CO2_fast_tmpr_flg As Boolean
Public set_shadow_corr_flg   As Boolean    

Dim    NaN_cnt               As Long


'**********************************************
'*** EC100 CONFIGURATION SETTING SUBROUTING ***
'**********************************************

Sub Config (cmd_array(10, 2), num_cmd As Long, retry_config_f As Boolean)
  Dim i_cnfg                As Long
  Dim config_result    As Long
  Dim save_flash_f     As Boolean
  Dim SkippedScan_prev As Long

  save_flash_f      = FALSE
  SkippedScan_prev = status.SkippedScan
  
  For i_cnfg = 1 To num_cmd
    EC100Configure (config_result, EC100SDM_ADDR, cmd_array(i_cnfg, 1), cmd_array(i_cnfg, 2))
    If (config_result = NAN) Then (ExitFor)
    
    If (NOT save_flash_f) AND (cmd_array(i_cnfg, 1) < 100) Then 
     
     Select Case cmd_array(i_cnfg, 1)                      
            Case 0, 2, 11, 12, 13, 14, 15, 16, 17, 18, 21, 25  
                '0:Bandwidth, 2: pressure source, 11: zeroing, 12: CO2 span, 13: H2O span, 14: CO2 zero value
                '15:CO2 span value, 16: H2O zero value, 17: H2O span value, 18: heater control, 21: IRGA power, 25: shadow correction 

            save_flash_f = TRUE                      
    
     EndSelect 
    
    EndIf
  Next i_cnfg

  If ((i_cnfg = num_cmd + 1)  AND (save_flash_f) AND (config_result <> NAN)) Then
   
      EC100Configure (config_result, EC100SDM_ADDR, 99, 2718)
      retry_config_f = FALSE
 
  EndIf

  SetStatus ("SkippedScan", SkippedScan_prev)
EndSub
'*** END OF EC100 CONFIGURATION SETTING SUBROUTING ***

'******************************************
'*** EC100 SETTING AND CO2 OPTION NOTES ***
'******************************************
DataTable (Config_Setting_Notes, TRUE, 1)
  CardOut(0, 10*DAY_FLUX_CRD)
  
  Sample (1, ec100_setting_array(1, 2), IEEE4)
  FieldNames ("bandwidth_freq")
  Sample (1, ec100_setting_array(2, 2), IEEE4)
  FieldNames ("press_source")
  Sample (1, ec100_setting_array(3, 2), IEEE4)
  FieldNames ("tmpr_source")
  Sample (1, ec100_setting_array(4, 2), IEEE4)
  FieldNames ("CO2_zero_coeff")
  Sample (1, ec100_setting_array(5, 2), IEEE4)
  FieldNames ("CO2_span_coeff")
  Sample (1, ec100_setting_array(6, 2), IEEE4)
  FieldNames ("H2O_zero_coeff")
  Sample (1, ec100_setting_array(7, 2), IEEE4)
  FieldNames ("H2O_span_coeff")
  Sample (1, CO2_span_gas, IEEE4)
  FieldNames ("CO2_span_mixra")
  Sample (1, T_DP_span_gas, IEEE4)
  FieldNames ("H2O_span_T_DP")
  Sample (1, ec100_setting_array(8, 2), IEEE4)
  FieldNames ("Heat_control")
  Sample (1, ec100_setting_array(9, 2), IEEE4)
  FieldNames ("IRGA_power")
  Sample (1, truefalse (2 + CO2_fast_tmpr), String)        'TRUR: fast temperature used spectroscopic correction and FALSE: 107 temperature used
  FieldNames ("CO2_fast_tmpr")
  Sample (1, ec100_setting_array(10, 2), IEEE4)
  FieldNames ("shadow_corr")
EndTable
'*** END OF EC100 CONFIGURE, ZERO, AND SPAN: CONSTANTS, VARIABLES, SUBROUTINE TABLE***
 
 
'**********************************************************************************
'*** BEGINNING OF CSAT SONIC HEAD：CONSTANTS, VARIABLES, AND WORKING DATA TABLES ***
'**********************************************************************************
Const PATH_LENGTH_CSAT = 0.1154701       'CSAT path length = 10 cm/sin(pi/3) (m)

Public sonic(5)                          'Hold CSAT data aligned in scan with data from IRGA and/or fine wire thermocouple
Alias  sonic(1) = Ts
Alias  sonic(2) = Ux
Alias  sonic(3) = Uy
Alias  sonic(4) = Uz
Alias  sonic(5) = diag_sonic
Units  Ts = deg C
Units  Ux      = m s-1
Units  Uy      = m s-1
Units  Uz      = m s-1
Units  diag_sonic = adimensional

Dim U_rslt                                 'Used to calculate Maximum resultant wind speed in an averaging period   


Dim   diag_bits_sonic(6) As Long           'Sonic warning flags
Alias diag_bits_sonic(1) = sonic_amp_l_f   'Amplitude low warning flag
Alias diag_bits_sonic(2) = sonic_amp_h_f   'Amplitude high warning flag
Alias diag_bits_sonic(3) = sonic_sig_lck_f 'Poor signal lock warning flag
Alias diag_bits_sonic(4) = sonic_del_T_f   'Delta temperature warning flag
Alias diag_bits_sonic(5) = sonic_aq_sig_f  'Sonic acquiring signals warning flag
Alias diag_bits_sonic(6) = sonic_cal_err_f 'Signature error in reading CSAT sonic head calibration data
Units diag_bits_sonic    = adimensional

Dim sonic_irga_raw(14)                     'Hold the data from EC100 (CSAT, IRGA, temperature sensor, and barometer raw data before applying instrument scan lag)

Dim diag_sonic_tmp  As Long                'Working variable used to break out the CSAT sonic head diagnostic bits
Dim sonic_disable_f As Boolean             'TRUE when any CSAT diagnostic warning flag is on, CSAT has not sent data, or an SDM signature error is reported

Public diag_sonic_aggregate As Long        'Aggregated diagnosis code within an output interval, indicating the ocurrance of all flags.
Units diag_sonic_aggregate = adimensional

Dim mask            As Long                'Masking the diagnosis code
Dim Ts_K                                   'Sonic temperature in K

Dim cov_out_sonic(20)                      'CSAT sonic statistics
Alias cov_out_sonic(1)  = Ux_Avg               
Alias cov_out_sonic(2)  = Ux_SIGMA          
Alias cov_out_sonic(3)  = UxUy_Cov         
Alias cov_out_sonic(4)  = UxUz_Cov           
Alias cov_out_sonic(5)  = Uy_Avg                
Alias cov_out_sonic(6)  = Uy_SIGMA          
Alias cov_out_sonic(7)  = UyUz_Cov
Alias cov_out_sonic(8)  = Uz_Avg
Alias cov_out_sonic(9)  = Uz_SIGMA
Alias cov_out_sonic(10) = Ts_Avg          'Ts averaged over an averaging interval (AmeriFlux notation) 
Alias cov_out_sonic(11) = Ts_SIGMA        'Ts standard deviation is stored here. Unlike standard deviation of momentum variable, it is not related to coordinate rotation (AmeriFlux notation) 
Alias cov_out_sonic(12) = TsUx_Cov
Alias cov_out_sonic(13) = TsUy_Cov
Alias cov_out_sonic(14) = TsUz_Cov
Alias cov_out_sonic(15) = WS
Alias cov_out_sonic(16) = WS_RSLT         'Result wind speed (AmeriFlux notation) 
Alias cov_out_sonic(17) = WD_SONIC        'wind direction of 0 to 360 degree in the CSAT coordinate system, equal to Gamma in coordination rotation.
Alias cov_out_sonic(18) = WD_SIGMA
Alias cov_out_sonic(19) = WS_MAX          'Maximum wind speed over an averaging interval (AmeriFlux notation)
Alias cov_out_sonic(20) = WD              'wind direction in compass convention (AmeriFlux notation) 
Units Ux_Avg   = m s-1
Units Ux_SIGMA = m s-1
Units UxUy_Cov = m2 s-2
Units UxUz_Cov = m2 s-2
Units Uy_Avg   = m s-1
Units Uy_SIGMA = m s-1
Units UyUz_Cov = m2 s-2
Units Uz_Avg   = m s-1
Units Uz_SIGMA = m s-1
Units Ts_Avg   = deg C
Units Ts_SIGMA = deg C
Units TsUx_Cov = deg C m s-1
Units TsUy_Cov = deg C m s-1
Units TsUz_Cov = deg C m s-1
Units WS       = m s-1
Units WS_RSLT  = m s-1
Units WD_SONIC = decimal degrees
Units WD_SIGMA = decimal degrees
Units WS_MAX   = m s-1
Units WD       = decimal degrees

' Variables after coordinate rotations as indicated by the last letter of "R".
' 3D wind components before coordinate roations are Ux, Uy, and Uz, and afterwards they are referred to as U, V, and W, respectively.
' Sonic temperatiure is denoted by Ts before coordinate roations and by T_SONIC afterwards
Dim USTAR_R                                'Friction velocity after coordinate rotations
Dim U
Dim U_SIGMA
Dim UV_Cov
Dim UW_Cov
Dim V
Dim V_SIGMA
Dim VW_Cov
Dim W
Dim W_SIGMA
Dim T_SONIC        
Dim T_SONIC_SIGMA
Dim UT_SONIC_Cov
Dim VT_SONIC_Cov
Dim WT_SONIC_Cov

Units USTAR_R = m s-1
Units U       = m s-1
Units U_SIGMA = m s-1
Units UV_Cov  = m2 s-2
Units UW_Cov  = m2 s-2
Units V       = m s-1
Units V_SIGMA = m s-1
Units VW_Cov  = m2 s-2
Units W       = m s-1
Units W_SIGMA = m s-1
Units T_SONIC = deg C        
Units T_SONIC_SIGMA = deg C
Units UT_SONIC_Cov  = deg C m s-1
Units VT_SONIC_Cov  = deg C m s-1
Units WT_SONIC_Cov  = deg C m s-1

Public TKE                           'specific turbulent kinetic energy
Units  TKE = m2 s-2                  '[kg (m/s)^2]/kg

' Variables after frequency corrections have an "_fc" appended.
' Note, however, there are exceptions such as H for sensible heat flux and TAU for momentum flux, both of which are after freq corrections.

Dim TAU                              'Drag force (stress) at surface (momentum flux) after coordinate rotations and freq corrections
Dim USTAR                            'Friction velocity after coordinate rotations and freq corrections
Dim WT_SONIC_Cov_fc
Dim UW_Cov_fc
Dim VW_Cov_fc

Units TAU             = kg m-1 s-2  'Equivalent to (kg/m^3)(m/s)^2
Units USTAR           = m s-1
Units WT_SONIC_Cov_fc = deg C m s-1
Units UW_Cov_fc       = m2 s-2
Units VW_Cov_fc       = m2 s-2

Public WT_SONIC_Cov_fc_SND         'Covariance of sonic temperature with vertical velocity after rotation, freq, and SND corrections
Public TSTAR                       'Scaling temperature
Public H                           'Sensible heat flux: Derived from covariance of sonic temperatur after rotation, freq, and SND corrections

Units  WT_SONIC_Cov_fc_SND = deg C m s-1
Units  TSTAR               = deg C
Units  H                   = W m-2

'*** Data quality classification: Constant and variables
Const OUTPUT_INTERVAL_SST = 5      'Sub-interval to calculate the statistics for Steady State Test (SST) [minutes]

' Steady State Test (SST)
Public RN_UW_VW_cov                'Relative Non-Stationarity (RN) for momentum covariance (UW_Cov and VW_Cov)
Public RN_UW_cov                   'Relative non-Stationarity for UW_Cov. It is also used for the sum of UxUz_Cov_SST below from 5-min sub-intervals.
Public RN_VW_cov                   'Relative non-Stationarity for VW_Cov. It is also used for the sum of UyUz_Cov_SST below from 5-min sub-intervals.
Public RN_WT_SONIC_cov             'Relative non-Stationarity for wTs_cov_R. It is also used for the sum of TsUz_Cov_SST below from 5-min sub-intervals.
Public nmbr_interval_qc_csat       'Number of sub-intervals = (OUTPUT_INTV)/(OUTPUT_INTERVAL_SST)

Dim cov_out_sonic_SST(17)          'CSAT sonic head statistics for Steady State Test (SST)
Alias cov_out_sonic_SST(1)  = Ux_Avg_SST
Alias cov_out_sonic_SST(2)  = Ux_Var_SST
Alias cov_out_sonic_SST(3)  = UxUy_Cov_SST
Alias cov_out_sonic_SST(4)  = UxUz_Cov_SST
Alias cov_out_sonic_SST(5)  = Uy_Avg_SST
Alias cov_out_sonic_SST(6)  = Uy_Var_SST
Alias cov_out_sonic_SST(7)  = UyUz_Cov_SST
Alias cov_out_sonic_SST(8)  = Uz_Avg_SST
Alias cov_out_sonic_SST(9)  = Uz_Var_SST
Alias cov_out_sonic_SST(10) = T_SONIC_Var_SST
Alias cov_out_sonic_SST(11) = TsUx_Cov_SST
Alias cov_out_sonic_SST(12) = TsUy_Cov_SST
Alias cov_out_sonic_SST(13) = TsUz_Cov_SST
Alias cov_out_sonic_SST(14) = WS_SST
Alias cov_out_sonic_SST(15) = WS_RSLT_SST
Alias cov_out_sonic_SST(16) = WD_SONIC_SST       'Wind direction in CSAT coordinate system (0 to 360 degree)
Alias cov_out_sonic_SST(17) = WD_SIGMA_SST

' Variables for steady State Test after coordinate rotations
Dim U_SST
Dim U_Var_SST
Dim UV_Cov_SST
Dim UW_Cov_SST
Dim V_SST
Dim V_Var_SST
Dim VW_Cov_SST
Dim W_SST
Dim W_Var_SST
Dim UT_SONIC_Cov_SST
Dim VT_SONIC_Cov_SST
Dim WT_SONIC_Cov_SST

' Data quality grading
Public TAU_SSITC_TEST As Long        'Results of the Steady State and Integral Turbulence Characteristics for TAU according to Foken et al (2004)
Public H_SSITC_TEST   As Long        'Results of the Steady State and Integral Turbulence Characteristics for H according to Foken et al (2004)
Units  TAU_SSITC_TEST = adimensional
Units  H_SSITC_TEST   = adimensional

Public TAU_QC As Long                 'Overall grade of data QC for momentum flux (i.e. for variable: TAU) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
Public H_QC   As Long                 'Overall grade of data QC for sensible heat flux (i.e. for variable: H) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
Units TAU_QC = grade
Units H_QC   = grade

'*** Footprint characteristics: Constant and variables ***
' Footprint characteristics
Const  NMBR_INT_INTERV_SEGMENT = 20  'Base number of numerical integration intervals for footprint characteristics in each integration segment

Public FETCH_MAX                     'Upwind location of source/sink that contributes most to the measured flux
Public FETCH_90                      'Upwind range within which the source/sink contributes 90% to the measured flux
Public FETCH_55                      'Upwind range within which the source/sink contributes 55% to the measured flux
Public FETCH_40                      'Upwind range within which the source/sink contributes 40% to the measured flux
Public UPWND_DIST_INTRST             'Upwind distant of interest
Public FP_DIST_INTRST                'Cumulative footprint of measured scalar flux within upwind range of interest

Units FETCH_MAX = m
Units FETCH_90  = m
Units FETCH_55  = m
Units FETCH_40  = m
Units UPWND_DIST_INTRST  = m
Units FP_DIST_INTRST = %

Public FP_EQUATION As String * 14   '"Kljun et al" or "KormannMeixner"
Units  FP_EQUATION = authors

'Raw data table
DataTable (delay_3d, TRUE, OFFSET)
  TableHide
  Sample (4, sonic_irga_raw(1), IEEE4)             'Sonic data: Ux, Uy, Uz, and Ts 
  Sample (1, sonic_irga_raw(5), Long)              'Sonic data: diag_sonic 
EndTable

'5-minute covariance of CSAT data for steady state tests
DataTable (comp_cov_3d_5min, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL_SST, Min, 0)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
  Average    (1, Ux, IEEE4, sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4, sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
  Average    (1, Uy, IEEE4, sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4, sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz from CSAT data.
  Average    (1,Uz, IEEE4, sonic_disable_f)       'Using sonic(4)
  Covariance (1,Uz, IEEE4, sonic_disable_f, 1)    'Using sonic(4)

  'Compute covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
  Covariance (4, Ts, IEEE4, sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)
EndTable

' 30-minute covariance of CSAT data
DataTable (comp_cov_3d, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
  Average    (1, Ux, IEEE4,sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4,sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
  Average    (1, Uy, IEEE4,sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4,sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz (i.e. variance) from CSAT data.
  Average    (1, Uz, IEEE4,sonic_disable_f)      'Using sonic(4)
  Covariance (1, Uz, IEEE4,sonic_disable_f, 1)   'Using sonic(4)

  'Compute Ts mean and covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
  Average    (1, Ts, IEEE4,sonic_disable_f)      'Using sonic(1)
  Covariance (4, Ts, IEEE4,sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)
  
  'Compute the maximum of wind speed in an averaging interval 
  Maximum (1, U_rslt, IEEE4, sonic_disable_f, False)

EndTable
'*** END OF CSAT SONIC HEAD：CONSTANTS, VARIABLES, AND WORKING DATA TABLES ***
  

'************************************************************************
'*** BEGINNING OF IRGA CONSTANTS, VARIABLES, AND WORKING DATA TABLES ***
'************************************************************************
Const DELAY_EC100               = INT ((4000/BANDWIDTH)/SCN_INTV)      'Automatically compute the electronic instrument lag of EC100 data in scan number
Const EC100_REC_BCK             = OFFSET - DELAY_EC100                 'Number of records back for aligning EC100 data with other sensor data in scan
Const PATH_LENGTH_IRGA          = 0.1531                               'IRGA path length (m).
Const CO2_SIG_STRGTH_THRESHOLD  = 0.7                                  'CO2 signal strength threshold below which the CO2 data are not used in instructions of AVERAGE and COVARIANCE, but kept in time series data table
Const H2O_SIG_STRGTH_THRESHOLD  = 0.7                                  'H2O signal strength threshold below which the H2O data are not used in instructions of AVERAGE and COVARIANCE, but kept in time series data table
Const CO2_RNG_TOP_LIMIT         = 1527.0                               'CO2 top range in mg/m^3. given IRGA calibrated in range of 0 ~ 1000 ppm CO2 in dry air at 25 C of air temperature in lab and at 86 kPa of pressure in Logan 
Const H2O_RNG_TOP_LIMIT         = 45.8                                 'H2O top range in g/m^3. given IRGA calibrated in range to dew point temperature at 25 C of air temperature in lab and at 86 kPa of pressure in Logan 

' Variables for separation corrections
Public separation_lat_dist_irga    'Effective separation distance (m) in direction normal to wind direction. Used for separation correction
Public separation_lag_dist_irga    'Effective separation distance (m) along wind direction. Used for lag maximization of covariance
Public separation_lag_scan_irga    'Lag of wind passing over IRGA (scans) after (+ lag) or before (- lag) passing CSAT. Its unit is a scan number, but not necessary to use an integer

Units  separation_lat_dist_irga  =  m
Units  separation_lag_dist_irga  =  m
Units  separation_lag_scan_irga  =  scans

' Data from IRGA
Public irga(22)                     'Hold IRGA data
Alias irga(1)  = CO2_density        'Conventional CO2 if CO2_fast_tmpr = FALSE or alternative CO2 from fast air temperature for spectroscopic effects if CO2_fast_tmpr = TRUE. 
Alias irga(2)  = H2O_density
Alias irga(3)  = diag_irga
Alias irga(4)  = amb_tmpr           'Air temperature measured by temperature probe connected to EC100
Alias irga(5)  = amb_press          'Pressure measured by a barometer connected to EC100
Alias irga(6)  = CO2_sig_strgth
Alias irga(7)  = H2O_sig_strgth
Alias irga(8)  = amb_RH             'Relative humidity (%): derived from amb_tmpr, H2O, and amb_press
Alias irga(9)  = amb_T_DP           'Dew point temperature (C): derived from amb_tmpr, H2O, and amb_press
Alias irga(10) = amb_e_sat          'Saturation vapor pressure (kPa): derived from amb_tmpr, H2O, and amb_press
Alias irga(11) = amb_e              'Vapor pressure (kPa): derived from amb_tmpr, H2O, and amb_press
Alias irga(12) = amb_rho_d          'Dry air density (g/m^3): derived from amb_tmpr, H2O, and amb_press
Alias irga(13) = amb_rho_a          'Moist air density (kg/m^3): derived from amb_tmpr, H2O, and amb_press
Alias irga(14) = Tc                 'Air temperature (C), found from IRGASON Ts, H2O, and amb_press
Alias irga(15) = RH                 'Relative humidity (%): derived from Tc, H2O, and amb_press
Alias irga(16) = T_DP               'Dew point temperature (C): derived from Tc, H2O, and amb_press
Alias irga(17) = e_sat              'Saturation vapor pressure (kPa): derived from Tc, H2O, and amb_press
Alias irga(18) = e                  'Vapor pressure (kPa): derived from Tc, H2O, and amb_press
Alias irga(19) = rho_d              'Dry air density (g/m^3): derived from Tc, H2O, and amb_press
Alias irga(20) = rho_a              'Moist air density (g/m^3): derived from Tc, H2O, and amb_press
Alias irga(21) = CO2_mixratio       'CO2 mixing ratio calculated from CO2 and rho_d
Alias irga(22) = H2O_mixratio       'H2O mixing ratio
Units CO2_density     = mg m-3
Units H2O_density     = g m-3
Units diag_irga       = adimensional
Units amb_tmpr        = deg C
Units amb_press       = kPa
Units CO2_sig_strgth  = fraction
Units H2O_sig_strgth  = fraction
Units amb_RH          = %
Units amb_T_DP        = deg C
Units amb_e_sat       = kPa
Units amb_e           = kPa
Units amb_rho_d       = g m-3
Units amb_rho_a       = kg m-3
Units Tc              = deg C
Units RH              = %
Units T_DP            = deg C
Units e_sat           = kPa
Units e               = kPa
Units rho_d           = g m-3
Units rho_a           = kg m-3
Units CO2_mixratio    = umol/mol
Units H2O_mixratio    = mmol/mol

Dim CO2_density_slow_tmpr                        'Used for coventional CO2 density in Time_series table 
Dim CO2_density_fast_tmpr                        'Used for alternative CO2 from fast air temperature for spectroscopic effects [see Helbig el al (2016)] 

Public diag_irga_aggregate As Long               'Aggregated diagnosis code within an output interval, indicating the ocurrance of all flags.
Units diag_irga_aggregate = adimensional

Dim diag_bits_irga(22) As Boolean                'Gas analyzer warning flags
Alias diag_bits_irga(1)  = irga_bad_data_f       'Gas analyzer bad data warning flag
Alias diag_bits_irga(2)  = irga_gen_fault_f      'General fault warning flag
Alias diag_bits_irga(3)  = irga_startup_f        'Gas analyzer starting up warning flag
Alias diag_bits_irga(4)  = irga_motor_spd_f      'Gas analyzer motor speed out of bounds warning flag
Alias diag_bits_irga(5)  = irga_tec_tmpr_f       'Thermoelectric cooler temperature out of bounds warning flag
Alias diag_bits_irga(6)  = irga_src_pwr_f        'Gas analyzer source power out of bounds warning flag
Alias diag_bits_irga(7)  = irga_src_tmpr_f       'Gas analyzer source temperature out of bounds warning flag
Alias diag_bits_irga(8)  = irga_src_curr_f       'Gas analyzer source current out of bounds warning flag
Alias diag_bits_irga(9)  = irga_off_f            'Gas analyzer head is powered down
Alias diag_bits_irga(10) = irga_sync_f           'Gas analyzer not synchronized with home pulse warning flag
Alias diag_bits_irga(11) = irga_amb_tmpr_f       'Invalid ambient temperature warning flag
Alias diag_bits_irga(12) = irga_amb_press_f      'Invalid ambient pressure warning flag
Alias diag_bits_irga(13) = irga_CO2_I_f          'CO2 I out of bounds warning flag
Alias diag_bits_irga(14) = irga_CO2_Io_f         'CO2 Io out of bounds warning flag
Alias diag_bits_irga(15) = irga_H2O_I_f          'H2O I out of bounds warning flag
Alias diag_bits_irga(16) = irga_H2O_Io_f         'H2O Io out of bounds warning flag
Alias diag_bits_irga(17) = irga_CO2_Io_var_f     'CO2 Io moving variation out of bounds warning flag
Alias diag_bits_irga(18) = irga_H2O_Io_var_f     'H2O Io moving variation out of bounds warning flag
Alias diag_bits_irga(19) = irga_CO2_sig_strgth_f 'CO2 signal strength warning flag
Alias diag_bits_irga(20) = irga_H2O_sig_strgth_f 'H2O signal strength warning flag
Alias diag_bits_irga(21) = irga_cal_err_f        'Gas analyzer calibration data signature error
Alias diag_bits_irga(22) = irga_htr_ctrl_off_f   'Gas analyzer heater control disabled by EC100
Units diag_bits_irga     = adimensional

'Working variables
Dim divisor                                      'Temporary variable used to find molar mixing ratio.
Dim diag_irga_tmp  As Long                       'Temporary variable used to break out the EC150 diagnostic bits.
Dim irga_disable_f As Boolean                    'TRUE when Gas analyzer sends bad data.

Dim sigma_wpl                                    'Webb et al. sigma = density of water vapor/density of dry air.
Dim Td_gp, Tc_K                                  'Working variables: Dew point temperature for general use (gu) and Tc in K.
Dim Enhance_Factor1, Enhance_Factor2             'Enhancement factors, both used for calculations of dew point temperature

' CO2: Lag maximization
Dim cov_array_CO2(2* MAX_LAG + 1, 5)          'Arrays used to hold the CO2 data with -MAX_LAG,..., -1, 0, 1, ..., MAX_LAG scan lags relative to CSAT data in order to find
'the lag that maximizes the covariance of CO2 with w. Once the optimum lag is found, it is also applied to
'H2O to find the maximum covariance of H2O with w because CO2 and H2O are measured using the same IRGA.
'Data are held in an array for more convenient calculation of covariances.
'Row used for lag of -MAX_LAG,..., -1, 0, 1, ..., MAX_LAG scans. Columns used for CO2_density, Ux, Uy, Uz, and CO2 (umolCO2 mol-1).

Dim irga_bad_data_flg_array (2* MAX_LAG + 1) As Boolean
Dim CO2_bad_rng_sig_array (2* MAX_LAG + 1)   As Boolean    'Set high if CO2 out of range or CO2 signal strength below the CO2 signal strength threshold
Dim H2O_bad_rng_sig_array (2* MAX_LAG + 1)   As Boolean    'Set high if H2O out of range or H2O signal strength below the H2O signal strength threshold

Dim Cov_out_CO2(7*(2*MAX_LAG + 1))                     'CO2 variable and CO2-related covariance variables
'b5 indicates backward 5 scans.
Alias Cov_out_CO2(1)  = CO2_Avg_lag_b5                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(2)  = CO2_Var_lag_b5                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(3)  = CO2_density_Avg_lag_b5         'CO2 in mg m-3  
Alias Cov_out_CO2(4)  = CO2_density_Var_lag_b5         'CO2 in mg m-3  
Alias Cov_out_CO2(5)  = UxCO2_Cov_lag_b5               'CO2 in mg m-3  
Alias Cov_out_CO2(6)  = UyCO2_Cov_lag_b5               'CO2 in mg m-3   
Alias Cov_out_CO2(7)  = UzCO2_Cov_lag_b5               'CO2 in mg m-3  

'b4 indicates backward 4 scans.
Alias Cov_out_CO2(8)  = CO2_Avg_lag_b4                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(9)  = CO2_Var_lag_b4                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(10) = CO2_density_Avg_lag_b4         'CO2 in mg m-3  
Alias Cov_out_CO2(11) = CO2_density_Var_lag_b4         'CO2 in mg m-3  
Alias Cov_out_CO2(12) = UxCO2_Cov_lag_b4               'CO2 in mg m-3  
Alias Cov_out_CO2(13) = UyCO2_Cov_lag_b4               'CO2 in mg m-3   
Alias Cov_out_CO2(14) = UzCO2_Cov_lag_b4               'CO2 in mg m-3  

'b3 indicates backward 3 scans.
Alias Cov_out_CO2(15)  = CO2_Avg_lag_b3                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(16)  = CO2_Var_lag_b3                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(17)  = CO2_density_Avg_lag_b3        'CO2 in mg m-3  
Alias Cov_out_CO2(18)  = CO2_density_Var_lag_b3        'CO2 in mg m-3  
Alias Cov_out_CO2(19)  = UxCO2_Cov_lag_b3              'CO2 in mg m-3  
Alias Cov_out_CO2(20)  = UyCO2_Cov_lag_b3              'CO2 in mg m-3   
Alias Cov_out_CO2(21)  = UzCO2_Cov_lag_b3              'CO2 in mg m-3  

'b2 indicates backward 2 scans.
Alias Cov_out_CO2(22)  = CO2_Avg_lag_b2                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(23)  = CO2_Var_lag_b2                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(24)  = CO2_density_Avg_lag_b2        'CO2 in mg m-3  
Alias Cov_out_CO2(25)  = CO2_density_Var_lag_b2        'CO2 in mg m-3  
Alias Cov_out_CO2(26)  = UxCO2_Cov_lag_b2              'CO2 in mg m-3  
Alias Cov_out_CO2(27)  = UyCO2_Cov_lag_b2              'CO2 in mg m-3   
Alias Cov_out_CO2(28)  = UzCO2_Cov_lag_b2              'CO2 in mg m-3  

'b1 indicates backward 1 scan
Alias Cov_out_CO2(29)  = CO2_Avg_lag_b1                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(30)  = CO2_Var_lag_b1                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(31) = CO2_density_Avg_lag_b1         'CO2 in mg m-3                
Alias Cov_out_CO2(32) = CO2_density_Var_lag_b1         'CO2 in mg m-3  
Alias Cov_out_CO2(33) = UxCO2_Cov_lag_b1               'CO2 in mg m-3  
Alias Cov_out_CO2(34) = UyCO2_Cov_lag_b1               'CO2 in mg m-3  
Alias Cov_out_CO2(35) = UzCO2_Cov_lag_b1               'CO2 in mg m-3  

'0 indicates neither backward nor forward. 
Alias Cov_out_CO2(36) = CO2_Avg_lag_0                  'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(37) = CO2_Var_Lag_0                  'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(38) = CO2_density_Avg_lag_0          'CO2 in mg m-3      
Alias Cov_out_CO2(39) = CO2_density_Var_lag_0          'CO2 in mg m-3
Alias Cov_out_CO2(40) = UxCO2_Cov_lag_0                'CO2 in mg m-3
Alias Cov_out_CO2(41) = UyCO2_Cov_lag_0                'CO2 in mg m-3
Alias Cov_out_CO2(42) = UzCO2_Cov_lag_0                'CO2 in mg m-3

'f1 indicates forward 1 scan. 
Alias Cov_out_CO2(43) = CO2_Avg_lag_f1                 'CO2 in umolCO2 mol-1 
Alias Cov_out_CO2(44) = CO2_Var_lag_f1                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(45) = CO2_density_Avg_lag_f1         'CO2 in mg m-3            
Alias Cov_out_CO2(46) = CO2_density_Var_lag_f1         'CO2 in mg m-3
Alias Cov_out_CO2(47) = UxCO2_Cov_lag_f1               'CO2 in mg m-3
Alias Cov_out_CO2(48) = UyCO2_Cov_lag_f1               'CO2 in mg m-3
Alias Cov_out_CO2(49) = UzCO2_Cov_lag_f1               'CO2 in mg m-3

'f2 indicates forward 2 scans
Alias Cov_out_CO2(50) = CO2_Avg_lag_f2                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(51) = CO2_Var_lag_f2                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(52) = CO2_density_Avg_f2             'CO2 in mg m-3              
Alias Cov_out_CO2(53) = CO2_density_Var_lag_f2         'CO2 in mg m-3
Alias Cov_out_CO2(54) = UxCO2_Cov_lag_f2               'CO2 in mg m-3
Alias Cov_out_CO2(55) = UyCO2_Cov_lag_f2               'CO2 in mg m-3
Alias Cov_out_CO2(56) = UzCO2_Cov_lag_f2               'CO2 in mg m-3

'f3 indicates forward 3 scans
Alias Cov_out_CO2(57) = CO2_Avg_lag_f3                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(58) = CO2_Var_lag_f3                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(59) = CO2_density_Avg_f3             'CO2 in mg m-3              
Alias Cov_out_CO2(60) = CO2_density_Var_lag_f3         'CO2 in mg m-3
Alias Cov_out_CO2(61) = UxCO2_Cov_lag_f3               'CO2 in mg m-3
Alias Cov_out_CO2(62) = UyCO2_Cov_lag_f3               'CO2 in mg m-3
Alias Cov_out_CO2(63) = UzCO2_Cov_lag_f3               'CO2 in mg m-3

'f4 indicates forward 4 scans
Alias Cov_out_CO2(64) = CO2_Avg_lag_f4                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(65) = CO2_Var_lag_f4                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(66) = CO2_density_Avg_f4             'CO2 in mg m-3              
Alias Cov_out_CO2(67) = CO2_density_Var_lag_f4         'CO2 in mg m-3
Alias Cov_out_CO2(68) = UxCO2_Cov_lag_f4               'CO2 in mg m-3
Alias Cov_out_CO2(69) = UyCO2_Cov_lag_f4               'CO2 in mg m-3
Alias Cov_out_CO2(70) = UzCO2_Cov_lag_f4               'CO2 in mg m-3

'f5 indicates forward 5 scans
Alias Cov_out_CO2(71) = CO2_Avg_lag_f5                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(72) = CO2_Var_lag_f5                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(73) = CO2_density_Avg_f5             'CO2 in mg m-3              
Alias Cov_out_CO2(74) = CO2_density_Var_lag_f5         'CO2 in mg m-3
Alias Cov_out_CO2(75) = UxCO2_Cov_lag_f5               'CO2 in mg m-3
Alias Cov_out_CO2(76) = UyCO2_Cov_lag_f5               'CO2 in mg m-3
Alias Cov_out_CO2(77) = UzCO2_Cov_lag_f5               'CO2 in mg m-3

' Variables after coordinate rotations as indicated by W for Uz
Dim   WCO2_Cov_lag (2*MAX_LAG + 1)                     'Hold covariance of scan-lagged CO2 with W after coordinate rotation. Used for MaxSpa instruction
Alias WCO2_Cov_lag (1)  = WCO2_Cov_lag_b5              'b5 indicates backward 5 scans.
Alias WCO2_Cov_lag (2)  = WCO2_Cov_lag_b4              'b4 indicates backward 4 scans.
Alias WCO2_Cov_lag (3)  = WCO2_Cov_lag_b3              'b3 indicates backward 3 scans.
Alias WCO2_Cov_lag (4)  = WCO2_Cov_lag_b2              'b2 indicates backward 2 scans.
Alias WCO2_Cov_lag (5)  = WCO2_Cov_lag_b1              'b1 indicates backward 1 scans.
Alias WCO2_Cov_lag (6)  = WCO2_Cov_lag_0               '0 indicates 0 lag in scans.
Alias WCO2_Cov_lag (7)  = WCO2_Cov_lag_f1              'f1 indicates forward 1 scans.
Alias WCO2_Cov_lag (8)  = WCO2_Cov_lag_f2              'f2 indicates forward 2 scans.
Alias WCO2_Cov_lag (9)  = WCO2_Cov_lag_f3              'f2 indicates forward 3 scans.
Alias WCO2_Cov_lag (10) = WCO2_Cov_lag_f4              'f2 indicates forward 4 scans.
Alias WCO2_Cov_lag (11) = WCO2_Cov_lag_f5              'f2 indicates forward 5 scans.

Dim WCO2_Cov_major_sign                                'Summarize the direction of CO2 flux (positive: up and negative: down)

' Variables after coordinate rotations as indicated by U for Ux and by V for Uy
Dim   UCO2_VCO2_Cov_lag(2*MAX_LAG + 1, 2)              'Hold the covariance of scan-lagged CO2 with U or V after coordinate rotation
Alias UCO2_VCO2_Cov_lag(1, 1)  = UCO2_Cov_lag_b5       'b5 indicates backward 5 scans. 
Alias UCO2_VCO2_Cov_lag(1, 2)  = VCO2_Cov_lag_b5
Alias UCO2_VCO2_Cov_lag(2, 1)  = UCO2_Cov_lag_b4       'b4 indicates backward 4 scans. 
Alias UCO2_VCO2_Cov_lag(2, 2)  = VCO2_Cov_lag_b4
Alias UCO2_VCO2_Cov_lag(3, 1)  = UCO2_Cov_lag_b3       'b3 indicates backward 3 scans. 
Alias UCO2_VCO2_Cov_lag(3, 2)  = VCO2_Cov_lag_b3
Alias UCO2_VCO2_Cov_lag(4, 1)  = UCO2_Cov_lag_b2       'b2 indicates backward 2 scans. 
Alias UCO2_VCO2_Cov_lag(4, 2)  = VCO2_Cov_lag_b2
Alias UCO2_VCO2_Cov_lag(5, 1)  = UCO2_Cov_lag_b1       'b1 indicates backward 1 scans.
Alias UCO2_VCO2_Cov_lag(5, 2)  = VCO2_Cov_lag_b1
Alias UCO2_VCO2_Cov_lag(6, 1)  = UCO2_Cov_lag_0        '0  indicates 0 lag in scans.
Alias UCO2_VCO2_Cov_lag(6, 2)  = VCO2_Cov_lag_0
Alias UCO2_VCO2_Cov_lag(7, 1)  = UCO2_Cov_lag_f1       'f1 indicates forward 1 scans.
Alias UCO2_VCO2_Cov_lag(7, 2)  = VCO2_Cov_lag_f1
Alias UCO2_VCO2_Cov_lag(8, 1)  = UCO2_Cov_lag_f2       'f2 indicates forward 2 scans.
Alias UCO2_VCO2_Cov_lag(8, 2)  = VCO2_Cov_lag_f2
Alias UCO2_VCO2_Cov_lag(9, 1)  = UCO2_Cov_lag_f3       'f3 indicates forward 3 scans.
Alias UCO2_VCO2_Cov_lag(9, 2)  = VCO2_Cov_lag_f3
Alias UCO2_VCO2_Cov_lag(10, 1) = UCO2_Cov_lag_f4       'f4 indicates forward 4 scans.
Alias UCO2_VCO2_Cov_lag(10, 2) = VCO2_Cov_lag_f4
Alias UCO2_VCO2_Cov_lag(11, 1) = UCO2_Cov_lag_f5       'f5 indicates forward 5 scans.
Alias UCO2_VCO2_Cov_lag(11, 2) = VCO2_Cov_lag_f5
Units UCO2_VCO2_Cov_lag        = mg m-2 s-1

Dim   WCO2_Cov_lag_max (2)                            'Array used in MaxSpa instruction to hold the max covariance and the location of the max covariance in array: WCO2_Cov_lag_R()
Alias WCO2_Cov_lag_max (1) = WCO2_Cov                 'Max covariance found from lagged covariance array [i.e. wCO2_cov_lag_R()] and will be used for CO2 flux after freq correction
Alias WCO2_Cov_lag_max (2) = lag_irga                 'Lag in number of scans, also used for sequential number in array index of lag in UCO2_UCO2_Cov_lag_R()
Units WCO2_Cov             = mg m-2 s-1
Units lag_irga             = scans

' H2O: Lag maximization
Dim cov_array_H2O(2*MAX_LAG+1, 5)  'Arrays used to hold the H2O data with -MAX_LAG, ... -1, 0, 1, ..., MAX_LAG scan lags relative to CSAT data. The optimum lag_irga found during maximization
'of covariance of CO2 with W is assumed to also be the optimum lag for H2O data since the same IRGA measures both CO2 and H2O in an open measurement volume.
'Data are held in an array for more convenient calculation of covariances.
'Row used for lag of -MAX_LAG, ... -1, 0, 1, ..., MAX_LAG scans. Columns used for H2O_density, Ux, Uy, and Uz, H2O (mmolH2O mol-1).

Dim Cov_out_H2O(7*(2*MAX_LAG + 1))                     'H2O variables and H2O-related covariances
'b5 indicates backward 5 scans
Alias Cov_out_H2O(1)  = H2O_Avg_lag_b5                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(2)  = H2O_Var_lag_b5                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(3)  = H2O_density_Avg_lag_b5         'H2O in g m-3
Alias Cov_out_H2O(4)  = H2O_density_Var_lag_b5         'H2O in g m-3
Alias Cov_out_H2O(5)  = UxH2O_Cov_lag_b5               'H2O in g m-3
Alias Cov_out_H2O(6)  = UyH2O_Cov_lag_b5               'H2O in g m-3
Alias Cov_out_H2O(7)  = UzH2O_Cov_lag_b5               'H2O in g m-3

'b4 indicates backward 4 scans
Alias Cov_out_H2O(8)  = H2O_Avg_lag_b4                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(9)  = H2O_Var_lag_b4                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(10) = H2O_density_Avg_lag_b4         'H2O in g m-3
Alias Cov_out_H2O(11) = H2O_density_Var_lag_b4         'H2O in g m-3
Alias Cov_out_H2O(12) = UxH2O_Cov_lag_b4               'H2O in g m-3
Alias Cov_out_H2O(13) = UyH2O_Cov_lag_b4               'H2O in g m-3
Alias Cov_out_H2O(14) = UzH2O_Cov_lag_b4               'H2O in g m-3

'b3 indicates backward 3 scans
Alias Cov_out_H2O(15)  = H2O_Avg_lag_b3                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(16)  = H2O_Var_lag_b3                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(17)  = H2O_density_Avg_lag_b3         'H2O in g m-3
Alias Cov_out_H2O(18)  = H2O_density_Var_lag_b3         'H2O in g m-3
Alias Cov_out_H2O(19)  = UxH2O_Cov_lag_b3               'H2O in g m-3
Alias Cov_out_H2O(20)  = UyH2O_Cov_lag_b3               'H2O in g m-3
Alias Cov_out_H2O(21)  = UzH2O_Cov_lag_b3               'H2O in g m-3

'b2 indicates backward 2 scans
Alias Cov_out_H2O(22)  = H2O_Avg_lag_b2                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(23)  = H2O_Var_lag_b2                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(24)  = H2O_density_Avg_lag_b2         'H2O in g m-3
Alias Cov_out_H2O(25)  = H2O_density_Var_lag_b2         'H2O in g m-3
Alias Cov_out_H2O(26)  = UxH2O_Cov_lag_b2               'H2O in g m-3
Alias Cov_out_H2O(27)  = UyH2O_Cov_lag_b2               'H2O in g m-3
Alias Cov_out_H2O(28)  = UzH2O_Cov_lag_b2               'H2O in g m-3

'b1 indicates backward 1 scan
Alias Cov_out_H2O(29) = H2O_Avg_lag_b1                  'H2O in mmolH2O mol-1
Alias Cov_out_H2O(30) = H2O_Var_lag_b1                  'H2O in mmolH2O mol-1
Alias Cov_out_H2O(31) = H2O_density_Avg_lag_b1          'H2O in g m-3    
Alias Cov_out_H2O(32) = H2O_density_Var_lag_b1          'H2O in g m-3
Alias Cov_out_H2O(33) = UxH2O_Cov_lag_b1                'H2O in g m-3
Alias Cov_out_H2O(34) = UyH2O_Cov_lag_b1                'H2O in g m-3
Alias Cov_out_H2O(35) = UzH2O_Cov_lag_b1                'H2O in g m-3

'0 indicates neither backward nor forward
Alias Cov_out_H2O(36) = H2O_Avg_lag_0                  'H2O in mmolH2O mol-1
Alias Cov_out_H2O(37) = H2O_Var_lag_0                  'H2O in mmolH2O mol-1
Alias Cov_out_H2O(38) = H2O_density_Avg_lag_0          'H2O in g m-3    
Alias Cov_out_H2O(39) = H2O_density_Var_lag_0          'H2O in g m-3
Alias Cov_out_H2O(40) = UxH2O_Cov_lag_0                'H2O in g m-3
Alias Cov_out_H2O(41) = UyH2O_Cov_lag_0                'H2O in g m-3
Alias Cov_out_H2O(42) = UzH2O_Cov_lag_0                'H2O in g m-3

'f1 indicates forward 1 scan
Alias Cov_out_H2O(43) = H2O_Avg_lag_f1                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(44) = H2O_Var_lag_f1                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(45) = H2O_density_Avg_lag_f1         'H2O in g m-3    
Alias Cov_out_H2O(46) = H2O_density_Var_lag_f1         'H2O in g m-3
Alias Cov_out_H2O(47) = UxH2O_Cov_lag_f1               'H2O in g m-3
Alias Cov_out_H2O(48) = UyH2O_Cov_lag_f1               'H2O in g m-3
Alias Cov_out_H2O(49) = UzH2O_Cov_lag_f1               'H2O in g m-3

'f2 indicates forward 2 scans
Alias Cov_out_H2O(50) = H2O_Avg_lag_f2                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(51) = H2O_Var_lag_f2                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(52) = H2O_density_Avg_lag_f2         'H2O in g m-3    
Alias Cov_out_H2O(53) = H2O_density_Var_lag_f2         'H2O in g m-3
Alias Cov_out_H2O(54) = UxH2O_Cov_lag_f2               'H2O in g m-3
Alias Cov_out_H2O(55) = UyH2O_Cov_lag_f2               'H2O in g m-3
Alias Cov_out_H2O(56) = UzH2O_Cov_lag_f2               'H2O in g m-3

'f3 indicates forward 3 scans
Alias Cov_out_H2O(57) = H2O_Avg_lag_f3                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(58) = H2O_Var_lag_f3                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(59) = H2O_density_Avg_lag_f3         'H2O in g m-3    
Alias Cov_out_H2O(60) = H2O_density_Var_lag_f3         'H2O in g m-3
Alias Cov_out_H2O(61) = UxH2O_Cov_lag_f3               'H2O in g m-3
Alias Cov_out_H2O(62) = UyH2O_Cov_lag_f3               'H2O in g m-3
Alias Cov_out_H2O(63) = UzH2O_Cov_lag_f3               'H2O in g m-3

'f4 indicates forward 4 scans
Alias Cov_out_H2O(64) = H2O_Avg_lag_f4                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(65) = H2O_Var_lag_f4                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(66) = H2O_density_Avg_lag_f4         'H2O in g m-3    
Alias Cov_out_H2O(67) = H2O_density_Var_lag_f4         'H2O in g m-3
Alias Cov_out_H2O(68) = UxH2O_Cov_lag_f4               'H2O in g m-3
Alias Cov_out_H2O(69) = UyH2O_Cov_lag_f4               'H2O in g m-3
Alias Cov_out_H2O(70) = UzH2O_Cov_lag_f4               'H2O in g m-3

'f5 indicates forward 5 scans
Alias Cov_out_H2O(71) = H2O_Avg_lag_f5                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(72) = H2O_Var_lag_f5                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(73) = H2O_density_Avg_lag_f5         'H2O in g m-3    
Alias Cov_out_H2O(74) = H2O_density_Var_lag_f5         'H2O in g m-3
Alias Cov_out_H2O(75) = UxH2O_Cov_lag_f5               'H2O in g m-3
Alias Cov_out_H2O(76) = UyH2O_Cov_lag_f5               'H2O in g m-3
Alias Cov_out_H2O(77) = UzH2O_Cov_lag_f5               'H2O in g m-3

'Before coordinate rotation (If measured by EC150+CSAT3A, lag due to separation is used to locate the covariance although it was found after coordinate rotaion).  
Dim Cov_out_cs(29)                                     'IRGA statistics.
Alias Cov_out_cs(1)  = CO2                             'Average CO2 mixing ratio in umolCO2 mol-1
Alias Cov_out_cs(2)  = CO2_SIGMA                       'CO2 mixing ratio standard deviation in umolCO2 mol-1
Alias Cov_out_cs(3)  = CO2_density_Avg                 'Average CO2 mass density in mg m-3
Alias Cov_out_cs(4)  = CO2_density_SIGMA               'CO2 mass density standard deviation in mg m-3
Alias Cov_out_cs(5)  = UxCO2_Cov                       'Covariance of CO2 mass density with Ux in mg m-2 s-1
Alias Cov_out_cs(6)  = UyCO2_Cov                       'Covariance of CO2 mass density with Uy in mg m-2 s-1
Alias Cov_out_cs(7)  = UzCO2_Cov                       'Covariance of CO2 mass density with Uz in mg m-2 s-1
Alias Cov_out_cs(8)  = H2O                             'Average H2O mixing ratio in mmolH2O mol-1
Alias Cov_out_cs(9)  = H2O_SIGMA                       'H2O mixing ratio standard deviation in mmolH2O mol-1
Alias Cov_out_cs(10) = H2O_density_Avg                 'Average H2O mass density in g m-3
Alias Cov_out_cs(11) = H2O_density_SIGMA               'H2O mass density standard deviation in g m-3
Alias Cov_out_cs(12) = UxH2O_Cov                       'Covariance of H2O mass density with Ux in g m-2 s-1
Alias Cov_out_cs(13) = UyH2O_Cov                       'Covariance of H2O mass density with Uy in g m-2 s-1
Alias Cov_out_cs(14) = UzH2O_Cov                       'Covariance of H2O mass density with Uz in g m-2 s-1
Alias Cov_out_cs(15) = TA_1_1_1                        'Average temperature from 107-probe connected to EC100
Alias Cov_out_cs(16) = RH_1_1_1                        'Average relative humidity (%): derived from 107 probe temperature (amb_tmpr), H2O, and amb_press
Alias Cov_out_cs(17) = T_DP_1_1_1                      'Average dew point temperature (C): derived from 107 probe temperature (amb_tmpr), H2O, and amb_press
Alias Cov_out_cs(18) = amb_e_sat_Avg                   'Average saturation vapor pressure (kPa): derived from amb_tmpr, H2O, and amb_press
Alias Cov_out_cs(19) = amb_e_Avg                       'Average vapor pressure (kPa): derived from amb_tmpr, H2O, and amb_press
Alias Cov_out_cs(20) = amb_rho_d_Avg                   'Density of dry air (g/m^3). calculated using the average data of amb_tmpr, H2O, and amb_press
Alias Cov_out_cs(21) = amb_rho_a_Avg                   'Density of moist air (kg/m^3). calculated using the average data of amb_tmpr, H2O, and amb_press
Alias Cov_out_cs(22) = TA_2_1_1                        'Average air temperature (C), found from IRGASON sonic temperature, H2O, and amb_press
Alias Cov_out_cs(23) = RH_2_1_1                        'Average relative humidity (%): derived from IRGASON sonic temperature, H2O, and amb_press
Alias Cov_out_cs(24) = T_DP_2_1_1                      'Average dew point temperature (C): derived from IRGASON sonic temperature, H2O, and amb_press
Alias Cov_out_cs(25) = e_sat_Avg                       'Average saturation vapor pressure (kPa): derived from Tc, H2O, and amb_press
Alias Cov_out_cs(26) = e_Avg                           'Average vapor pressure (kPa): derived from Tc, H2O, and amb_press
Alias Cov_out_cs(27) = rho_d_Avg                       'Density of dry air (g/m^3). calculated using the average data of Tc, H2O, and amb_press
Alias Cov_out_cs(28) = rho_a_Avg                       'Density of moist air (kg/m^3). calculated using the average data of Tc, H2O, and amb_press
Alias Cov_out_cs(29) = PA                              'Average atmospheric pressure 
Units CO2               = umolCO2 mol-1
Units CO2_SIGMA         = umolCO2 mol-1
Units CO2_density_Avg   = mg m-3
Units CO2_density_SIGMA = mg m-3
Units UxCO2_Cov         = mg m-2 s-1
Units UyCO2_Cov         = mg m-2 s-1
Units UzCO2_Cov         = mg m-2 s-1
Units H2O               = mmolH2O mol-1
Units H2O_SIGMA         = mmolH2O mol-1
Units H2O_density_Avg   = g m-3
Units H2O_density_SIGMA = g m-3
Units UxH2O_Cov         = g m-2 s-1
Units UyH2O_Cov         = g m-2 s-1
Units UzH2O_Cov         = g m-2 s-1
Units TA_1_1_1          = deg C
Units RH_1_1_1          = %
Units T_DP_1_1_1        = deg C
Units amb_e_sat_Avg     = kPa
Units amb_e_Avg         = kPa
Units amb_rho_d_Avg     = g m-3
Units amb_rho_a_Avg     = kg m-3
Units TA_2_1_1          = deg C
Units RH_2_1_1          = %
Units T_DP_2_1_1        = deg C
Units e_sat_Avg         = kPa
Units e_Avg             = kPa
Units rho_d_Avg         = g m-3
Units rho_a_Avg         = kg m-3
Units PA                = kPa

Public VPD                                               'ambient water vapor pressure deficit
Units  VPD = hPa

'After coordinate rotations as indicated by U for Ux, V for Uy and W for Uz
Dim UCO2_Cov
Dim VCO2_Cov
'For WCO2_Cov, see WCO2_Cov_lag_max (1)
Units UCO2_Cov  = mg m-2 s-1
Units VCO2_Cov  = mg m-2 s-1

Dim UH2O_Cov
Dim VH2O_Cov
Dim WH2O_Cov                        'Found using lag_irga that was found while WCO2_cov was found
Units UH2O_Cov  = g m-2 s-1
Units VH2O_Cov  = g m-2 s-1
Units WH2O_Cov  = g m-2 s-1

' After coordinate rotations and freq corrections as indicated by "fc"
Dim WCO2_Cov_fc
Dim WH2O_Cov_fc
Units WCO2_Cov_fc = mg m-2 s-1
Units WH2O_Cov_fc = g m-2 s-1

' WPL correction terms after coordinate rotations and freq corrections as indicated by "WPL_fc"
Dim CO2_E_WPL_fc                    'Carbon dioxide flux, WPL term due to water vapor flux (covariance of water vapor with vertical velocity)
Dim CO2_T_WPL_fc                    'Carbon dioxide flux, WPL term due to temperature flux (covariance of temperature with vertical velocity)
Dim H2O_E_WPL_fc                    'Water vapor flux, WPL term due to water vapor flux (covariance of water vapor with vertical velocity)
Dim H2O_T_WPL_fc                    'Water vapor flux, WPL term due to temperature flux (covariance of temperature with vertical velocity)
Units CO2_E_WPL_fc = mg m-2 s-1
Units CO2_T_WPL_fc = mg m-2 s-1
Units H2O_E_WPL_fc = g m-2 s-1
Units H2O_T_WPL_fc = g m-2 s-1

' After coordinate rotations, freq corrections, and WPL correction
Public FC                            'Carbon dioxide flux after coordinate rotation, freq, and WPL corrections in umol/(m^2 s)
Public FC_mass                       'Carbon dioxide flux after coordinate rotation, freq, and WPL corrections in mg/(m^2 s)
Public LE                            'Latent heat flux after coordinate rotation, freq, and WPL corrections
Public ET                            'Evapotranspiration 
Units FC      = umolCO2 m-2 s-1
Units FC_mass = mg m-2 s-1
Units LE      = W m-2
Units ET      = mm hour-1

Public Bowen_ratio
Units  Bowen_ratio = fraction

'*** Variables for data QC
' Steady State Test
Public RN_WCO2_Cov                  'Relative Non-stationarity (RN) for wCO2_cov_R.
Public RN_WH2O_Cov                  'Relative non-stationarity for wH2O_cov_R.
Public nmbr_interval_qc_irga        'Number of sub-intervals = (OUTPUT_INTV in min)/(5 min)

Dim cov_out_irga_SST(8)             'IRGA statistics for Steady State Test (SST)
Alias cov_out_irga_SST(1) = CO2_density_var_SST
Alias cov_out_irga_SST(2) = UxCO2_Cov_SST
Alias cov_out_irga_SST(3) = UyCO2_Cov_SST
Alias cov_out_irga_SST(4) = UzCO2_Cov_SST
Alias cov_out_irga_SST(5) = H2O_density_var_SST
Alias cov_out_irga_SST(6) = UxH2O_Cov_SST
Alias cov_out_irga_SST(7) = UyH2O_Cov_SST
Alias cov_out_irga_SST(8) = UzH2O_Cov_SST

' After coordinate rotations
Dim UCO2_Cov_SST
Dim VCO2_Cov_SST
Dim WCO2_Cov_SST
Dim UH2O_Cov_SST
Dim VH2O_Cov_SST
Dim WH2O_Cov_SST

' Overall grade of data quality for CO2 and H2O fluxes
Public FC_SSITC_TEST As Long          'Results of the Steady State and Integral Turbulence Characteristics for FC according to Foken et al (2004)
Public LE_SSITC_TEST As Long          'Results of the Steady State and Integral Turbulence Characteristics for LE according to Foken et al (2004)
Units  FC_SSITC_TEST = adimensional
Units  LE_SSITC_TEST = adimensional

Public FC_QC As Long                  'Overall grade of data quality for CO2 flux (i.e. for variable: FC and FC_mass) [1 (highest) to 9 (lowest)]
Public LE_QC As Long                  'Overall grade of data quality for latent heat flux (LE) and rvapotranspiration (ET) [1 (highest) to 9 (lowest)]
Units  FC_QC = Grade
Units  LE_QC = Grade

'Data table for delayed data from IRGA
DataTable (delay_cs, TRUE, (OFFSET + MAX_LAG))
  TableHide
  Sample (1,sonic_irga_raw(6), IEEE4)   'conventional CO2 if CO2_fast_T is false; otherwise, Helbig et al. (2016) CO2 density
  Sample (1,sonic_irga_raw(7), IEEE4)   'H2O
  Sample (1,sonic_irga_raw(8), Long)    'diag_irga
  Sample (4,sonic_irga_raw(9), IEEE4)   'amb_tmpr, amb_press, CO2_sig_strgth, and H2O_sig_strgth
  Sample (1,sonic_irga_raw(13),IEEE4)   'conventional CO2 if CO2_fast_T is true; otherwise, Helbig et al. (2016) CO2 density
EndTable

' 5-minute statistics
DataTable (comp_cov_cs_5min, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL_SST, Min, 0)
  
  Covariance (4, cov_array_CO2((MAX_LAG + 1), 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(MAX_LAG + 1) OR CO2_bad_rng_sig_array(MAX_LAG+1)),4)
  Covariance (4, cov_array_H2O((MAX_LAG + 1), 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(MAX_LAG + 1) OR H2O_bad_rng_sig_array(MAX_LAG+1)),4)

EndTable

'Compute covariance of CO2 against CSAT wind data.
DataTable (comp_cov_CO2, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average    (1, cov_array_CO2(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(1, 1), IEEE4, (irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)))
  Covariance (4, cov_array_CO2(1, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)),4)

  Average    (1, cov_array_CO2(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(2, 1), IEEE4, (irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)))
  Covariance (4, cov_array_CO2(2, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)),4)

  Average    (1, cov_array_CO2(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(3, 1), IEEE4, (irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)))
  Covariance (4, cov_array_CO2(3, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)),4)

  Average    (1, cov_array_CO2(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(4, 1), IEEE4, (irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)))
  Covariance (4, cov_array_CO2(4, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)),4)

  Average    (1, cov_array_CO2(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(5, 1), IEEE4, (irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)))
  Covariance (4, cov_array_CO2(5, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)),4)

  Average    (1, cov_array_CO2(6, 5), IEEE4, (irga_bad_data_flg_array(6) OR CO2_bad_rng_sig_array(6)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(6, 5), IEEE4, (irga_bad_data_flg_array(6) OR CO2_bad_rng_sig_array(6)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(6, 1), IEEE4, (irga_bad_data_flg_array(6) OR CO2_bad_rng_sig_array(6)))
  Covariance (4, cov_array_CO2(6, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(6) OR CO2_bad_rng_sig_array(6)),4)
  
  Average    (1, cov_array_CO2(7, 5), IEEE4, (irga_bad_data_flg_array(7) OR CO2_bad_rng_sig_array(7)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(7, 5), IEEE4, (irga_bad_data_flg_array(7) OR CO2_bad_rng_sig_array(7)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(7, 1), IEEE4, (irga_bad_data_flg_array(7) OR CO2_bad_rng_sig_array(7)))
  Covariance (4, cov_array_CO2(7, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(7) OR CO2_bad_rng_sig_array(7)),4)
  
  Average    (1, cov_array_CO2(8, 5), IEEE4, (irga_bad_data_flg_array(8) OR CO2_bad_rng_sig_array(8)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(8, 5), IEEE4, (irga_bad_data_flg_array(8) OR CO2_bad_rng_sig_array(8)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(8, 1), IEEE4, (irga_bad_data_flg_array(8) OR CO2_bad_rng_sig_array(8)))
  Covariance (4, cov_array_CO2(8, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(8) OR CO2_bad_rng_sig_array(8)),4)

  Average    (1, cov_array_CO2(9, 5), IEEE4, (irga_bad_data_flg_array(9) OR CO2_bad_rng_sig_array(9)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(9, 5), IEEE4, (irga_bad_data_flg_array(9) OR CO2_bad_rng_sig_array(9)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(9, 1), IEEE4, (irga_bad_data_flg_array(9) OR CO2_bad_rng_sig_array(9)))
  Covariance (4, cov_array_CO2(9, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(9) OR CO2_bad_rng_sig_array(9)),4)

  Average    (1, cov_array_CO2(10, 5), IEEE4, (irga_bad_data_flg_array(10) OR CO2_bad_rng_sig_array(10)))                     'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(10, 5), IEEE4, (irga_bad_data_flg_array(10) OR CO2_bad_rng_sig_array(10)),1)                   'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(10, 1), IEEE4, (irga_bad_data_flg_array(10) OR CO2_bad_rng_sig_array(10)))
  Covariance (4, cov_array_CO2(10, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(10) OR CO2_bad_rng_sig_array(10)),4)

  Average    (1, cov_array_CO2(11, 5), IEEE4, (irga_bad_data_flg_array(11) OR CO2_bad_rng_sig_array(11)))                     'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(11, 5), IEEE4, (irga_bad_data_flg_array(11) OR CO2_bad_rng_sig_array(11)),1)                   'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(11, 1), IEEE4, (irga_bad_data_flg_array(11) OR CO2_bad_rng_sig_array(11)))
  Covariance (4, cov_array_CO2(11, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(11) OR CO2_bad_rng_sig_array(11)),4)

EndTable

'Compute covariance of H2O against CSAT wind data.
DataTable (comp_cov_H2O, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average    (1, cov_array_H2O(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(1, 1), IEEE4, (irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)))
  Covariance (4, cov_array_H2O(1, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)),4)

  Average    (1, cov_array_H2O(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(2, 1), IEEE4, (irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)))
  Covariance (4, cov_array_H2O(2, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)),4)

  Average    (1, cov_array_H2O(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(3, 1), IEEE4, (irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)))
  Covariance (4, cov_array_H2O(3, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)),4)

  Average    (1, cov_array_H2O(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(4, 1), IEEE4, (irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)))
  Covariance (4, cov_array_H2O(4, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)),4)

  Average    (1, cov_array_H2O(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(5, 1), IEEE4, (irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)))
  Covariance (4, cov_array_H2O(5, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)),4)

  Average    (1, cov_array_H2O(6, 5), IEEE4, (irga_bad_data_flg_array(6) OR H2O_bad_rng_sig_array(6)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(6, 5), IEEE4, (irga_bad_data_flg_array(6) OR H2O_bad_rng_sig_array(6)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(6, 1), IEEE4, (irga_bad_data_flg_array(6) OR H2O_bad_rng_sig_array(6)))
  Covariance (4, cov_array_H2O(6, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(6) OR H2O_bad_rng_sig_array(6)),4)

  Average    (1, cov_array_H2O(7, 5), IEEE4, (irga_bad_data_flg_array(7) OR H2O_bad_rng_sig_array(7)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(7, 5), IEEE4, (irga_bad_data_flg_array(7) OR H2O_bad_rng_sig_array(7)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(7, 1), IEEE4, (irga_bad_data_flg_array(7) OR H2O_bad_rng_sig_array(7)))
  Covariance (4, cov_array_H2O(7, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(7) OR H2O_bad_rng_sig_array(7)),4)
  
  Average    (1, cov_array_H2O(8, 5), IEEE4, (irga_bad_data_flg_array(8) OR H2O_bad_rng_sig_array(8)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(8, 5), IEEE4, (irga_bad_data_flg_array(8) OR H2O_bad_rng_sig_array(8)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(8, 1), IEEE4, (irga_bad_data_flg_array(8) OR H2O_bad_rng_sig_array(8)))
  Covariance (4, cov_array_H2O(8, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(8) OR H2O_bad_rng_sig_array(8)),4)
  
  Average    (1, cov_array_H2O(9, 5), IEEE4, (irga_bad_data_flg_array(9) OR H2O_bad_rng_sig_array(9)))                       'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(9, 5), IEEE4, (irga_bad_data_flg_array(9) OR H2O_bad_rng_sig_array(9)),1)                     'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(9, 1), IEEE4, (irga_bad_data_flg_array(9) OR H2O_bad_rng_sig_array(9))
  Covariance (4, cov_array_H2O(9, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(9) OR H2O_bad_rng_sig_array(9)),4)
  
  Average    (1, cov_array_H2O(10, 5), IEEE4, (irga_bad_data_flg_array(10) OR H2O_bad_rng_sig_array(10)))                    'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(10, 5), IEEE4, (irga_bad_data_flg_array(10) OR H2O_bad_rng_sig_array(10)),1)                  'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(10, 1), IEEE4, (irga_bad_data_flg_array(10) OR H2O_bad_rng_sig_array(10)))
  Covariance (4, cov_array_H2O(10, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(10) OR H2O_bad_rng_sig_array(10)),4)
  
  Average    (1, cov_array_H2O(11, 5), IEEE4, (irga_bad_data_flg_array(11) OR H2O_bad_rng_sig_array(11)))                    'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(11, 5), IEEE4, (irga_bad_data_flg_array(11) OR H2O_bad_rng_sig_array(11)),1)                  'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(11, 1), IEEE4, (irga_bad_data_flg_array(11) OR H2O_bad_rng_sig_array(11)))
  Covariance (4, cov_array_H2O(11, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(11) OR H2O_bad_rng_sig_array(11)),4)
EndTable

'Compute Tc-related data.
DataTable (comp_mean, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)
  Average (1, amb_tmpr, IEEE4, irga_amb_tmpr_f)
  Average (1, amb_RH,   IEEE4, (irga_disable_f OR (amb_RH > 102) OR H2O_bad_rng_sig_array(MAX_LAG +1))
  Average (5, amb_T_DP, IEEE4, (irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1))                                         'amb_T_DP, amb_e_sat, amb_e, amb_rho_d, amb_rho_a
  
  Average (1, Tc,       IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1))
  Average (1, RH,       IEEE4, (irga_disable_f OR sonic_disable_f OR (RH > 102) OR H2O_bad_rng_sig_array(MAX_LAG +1))
  Average (5, T_DP,     IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1))                      'T_DP, e_sat, e, rho_d, rho_a

  Average (1, amb_press, IEEE4, irga_amb_press_f)

EndTable
'*** END OF IRGA： CONSTANTS, VARIABLES, AND WORKING DATA TABLES ***

#If (DVC_CDM_A116) Then
'**********************************************
'*** BEGINNING OF CDM_A100 SERIES CONSTANTS ***
'**********************************************
Const CDM_MODEL               = CDM_A116               'CDM Model
Const CDM_1ST_PANEL_TMPR_CHAN = 1                      'Starting terminal group for CDM panel temperature measurement (1, 2, 3, or 4)
Const NMBR_PANEL_TMPR_CDM     = 4                      'Number of terminal groups (terminal panel temperature measurements). There are 4 panel temperature measurements.
'*** END OF CDM_A100 SERIES CONSTANTS ***      
#EndIf 


#If (SENSOR_FW) Then  
'*********************************************************************
'*** BEGINNING OF FW: CONSTANTS, VARIABLES, AND WORKING DATA TABLE ***
'*********************************************************************
Public time_const_FW = 0.001            'Default value (seconds). It will be recalculated inside the program
Units  time_const_FW = s

Public FW                               'Air temperature measured using a fine wire thermocouple of FW05, FW1, FW2, or FW3
Units  FW = deg C

'Raw and not lagged FW data.
Dim FW_raw                              'Air temperature measured using a fine wire thermocouple of FW05, FW1, FW2, or FW3
Dim diag_FW_raw                         'Boolean type is not used because this variable is an element of numerical array: dly_data_out() 
Dim dly_data_FW_out(2)                  'Array used to temporarily store the lagged record from the raw data table for FW measurements (hidden)

Public separation_lat_dist_FW           'effective separation distance in direction normal to wind direction. Used for separation correction.    
Public separation_lag_dist_FW           'effective separation distance along wind direction. Used for time lag maximization.  
Public separation_lag_scan_FW           'lag in scan number. Wind passing FW after (+) or before (-) passing CSAT. Not necessary to use an integer.
Units  separation_lat_dist_FW = m 
Units  separation_lag_dist_FW = m
Units  separation_lag_scan_FW = scans

Dim Cov_array_FW(2* MAX_LAG + 1, 4)      'Arrays used to hold the FW data with -MAX_LAG,..., -1, 0, 1, ..., MAX_LAG in scan lags relative to CSAT data in order 
                                         'to find the max covariance of FW with Uz using lag_FW found in maximization for covariance of FW with Uz
                                         'In form of array for use in the COVARIANCE instructions. 
                                         'Row for lag -MAX_LAG,..., -1, 0, 1, ..., MAX_LAG scans, column: FW, Ux, Uy, and Uz.   
Dim FW_bad_data_flg (2* MAX_LAG + 1) As Boolean

Dim Cov_out_FW(6*(2*MAX_LAG + 1))                'FW statistics and FW-related covariance
'b5 indicates backward 5 scans 
Alias Cov_out_FW(1)  = FW_Avg_lag_b5                 
Alias Cov_out_FW(2)  = FW_Var_lag_b5   
Alias Cov_out_FW(3)  = UxFW_Cov_lag_b5
Alias Cov_out_FW(4)  = UyFW_Cov_lag_b5
Alias Cov_out_FW(5)  = UzFW_Cov_lag_b5
Alias Cov_out_FW(6)  = nmbr_smpl_FW_lag_b5

'b4 indicates backward 4 scans 
Alias Cov_out_FW(7)  = FW_Avg_lag_b4                 
Alias Cov_out_FW(8)  = FW_Var_lag_b4   
Alias Cov_out_FW(9)  = UxFW_Cov_lag_b4
Alias Cov_out_FW(10)  = UyFW_Cov_lag_b4
Alias Cov_out_FW(11)  = UzFW_Cov_lag_b4
Alias Cov_out_FW(12)  = nmbr_smpl_FW_lag_b4

'b3 indicates backward 3 scans 
Alias Cov_out_FW(13)  = FW_Avg_lag_b3                 
Alias Cov_out_FW(14)  = FW_Var_lag_b3   
Alias Cov_out_FW(15)  = UxFW_Cov_lag_b3
Alias Cov_out_FW(16)  = UyFW_Cov_lag_b3
Alias Cov_out_FW(17)  = UzFW_Cov_lag_b3
Alias Cov_out_FW(18)  = nmbr_smpl_FW_lag_b3

'b2 indicates backward 2 scans 
Alias Cov_out_FW(19)  = FW_Avg_lag_b2                 
Alias Cov_out_FW(20)  = FW_Var_lag_b2   
Alias Cov_out_FW(21)  = UxFW_Cov_lag_b2
Alias Cov_out_FW(22)  = UyFW_Cov_lag_b2
Alias Cov_out_FW(23)  = UzFW_Cov_lag_b2
Alias Cov_out_FW(24)  = nmbr_smpl_FW_lag_b2

'b1 indicates backward 1 scan 
Alias Cov_out_FW(25)  = FW_Avg_lag_b1                
Alias Cov_out_FW(26)  = FW_Var_lag_b1   
Alias Cov_out_FW(27)  = UxFW_Cov_lag_b1
Alias Cov_out_FW(28) = UyFW_Cov_lag_b1
Alias Cov_out_FW(29) = UzFW_Cov_lag_b1
Alias Cov_out_FW(30) = nmbr_smpl_FW_lag_b1

'0 indicates neither backward nor forward 
Alias Cov_out_FW(31) = FW_Avg_lag_0                 
Alias Cov_out_FW(32) = FW_Var_lag_0    
Alias Cov_out_FW(33) = UxFW_Cov_lag_0
Alias Cov_out_FW(34) = UyFW_Cov_lag_0
Alias Cov_out_FW(35) = UzFW_Cov_lag_0
Alias Cov_out_FW(36) = nmbr_smpl_FW_lag_0

'f1 indicates forward 1 scan lag
Alias Cov_out_FW(37) = FW_Avg_lag_f1                 
Alias Cov_out_FW(38) = FW_Var_lag_f1   
Alias Cov_out_FW(39) = UxFW_Cov_lag_f1
Alias Cov_out_FW(40) = UyFW_Cov_lag_f1
Alias Cov_out_FW(41) = UzFW_cov_lag_f1
Alias Cov_out_FW(42) = nmbr_smpl_FW_lag_f1

'f2 indicates forward 2 scans
Alias Cov_out_FW(43) = FW_Avg_lag_f2                 
Alias Cov_out_FW(44) = FW_Var_lag_f2   
Alias Cov_out_FW(45) = UxFW_Cov_lag_f2
Alias Cov_out_FW(46) = UyFW_Cov_lag_f2
Alias Cov_out_FW(47) = UzFW_Cov_lag_f2
Alias Cov_out_FW(48) = nmbr_smpl_FW_lag_f2

'f3 indicates forward 3 scans
Alias Cov_out_FW(49) = FW_Avg_lag_f3                 
Alias Cov_out_FW(50) = FW_Var_lag_f3   
Alias Cov_out_FW(51) = UxFW_Cov_lag_f3
Alias Cov_out_FW(52) = UyFW_Cov_lag_f3
Alias Cov_out_FW(53) = UzFW_Cov_lag_f3
Alias Cov_out_FW(54) = nmbr_smpl_FW_lag_f3

'f4 indicates forward 4 scans
Alias Cov_out_FW(55) = FW_Avg_lag_f4                 
Alias Cov_out_FW(56) = FW_Var_lag_f4   
Alias Cov_out_FW(57) = UxFW_Cov_lag_f4
Alias Cov_out_FW(58) = UyFW_Cov_lag_f4
Alias Cov_out_FW(59) = UzFW_Cov_lag_f4
Alias Cov_out_FW(60) = nmbr_smpl_FW_lag_f4

'f5 indicates forward 5 scans
Alias Cov_out_FW(61) = FW_Avg_lag_f5                 
Alias Cov_out_FW(62) = FW_Var_lag_f5   
Alias Cov_out_FW(63) = UxFW_Cov_lag_f5
Alias Cov_out_FW(64) = UyFW_Cov_lag_f5
Alias Cov_out_FW(65) = UzFW_Cov_lag_f5
Alias Cov_out_FW(66) = nmbr_smpl_FW_lag_f5

' Variables after coordinate rotations as indicated by U for Ux, V for Uy, and W for Uz 
Dim   WFW_Cov_lag (2*MAX_LAG + 1)                'Used for instruction of MaxSpa
Alias WFW_Cov_lag (1)  = WFW_Cov_lag_b5          'b5 indicates backward 5 scans   
Alias WFW_Cov_lag (2)  = WFW_Cov_lag_b4          'b4 indicates backward 4 scans  
Alias WFW_Cov_lag (3)  = WFW_Cov_lag_b3          'b3 indicates backward 3 scans 
Alias WFW_Cov_lag (4)  = WFW_Cov_lag_b2          'b2 indicates backward 2 scans   
Alias WFW_Cov_lag (5)  = WFW_Cov_lag_b1          'b1 indicates backward 1 scan  
Alias WFW_Cov_lag (6)  = WFW_Cov_lag_0           '0 indicates neither backward nor forward   
Alias WFW_Cov_lag (7)  = WFW_Cov_lag_f1          'f1 indicates forward 1 scan    
Alias WFW_Cov_lag (8)  = WFW_Cov_lag_f2          'f2 indicates forward 2 scans  
Alias WFW_Cov_lag (9)  = WFW_Cov_lag_f3          'f3 indicates forward 3 scans    
Alias WFW_Cov_lag (10) = WFW_Cov_lag_f4          'f4 indicates forward 4 scans 
Alias WFW_Cov_lag (11) = WFW_Cov_lag_f5          'f5 indicates forward 5 scans    
Units WFW_Cov_lag     = deg C m s-1

Dim   WFW_cov_major_sign                        'Summarize the sign of wFW1_cov: From above array, chose max if positive (up) and min if negative (down)  

Dim   UFW_VFW_Cov_lag(2*MAX_LAG + 1, 2)         'Hold the covariance of lagged FW with U or V after coordinate rotation  
Alias UFW_VFW_Cov_lag(1, 1)  = UFW_Cov_lag_b5   'b5 indicates backward 5 scans  
Alias UFW_VFW_Cov_lag(1, 2)  = VFW_Cov_lag_b5
Alias UFW_VFW_Cov_lag(2, 1)  = UFW_Cov_lag_b4   'b4 indicates backward 4 scans  
Alias UFW_VFW_Cov_lag(2, 2)  = VFW_Cov_lag_b4
Alias UFW_VFW_Cov_lag(3, 1)  = UFW_Cov_lag_b3   'b3 indicates backward 3 scans  
Alias UFW_VFW_Cov_lag(3, 2)  = VFW_Cov_lag_b3
Alias UFW_VFW_Cov_lag(4, 1)  = UFW_Cov_lag_b2   'b2 indicates backward 2 scans  
Alias UFW_VFW_Cov_lag(4, 2)  = VFW_Cov_lag_b2
Alias UFW_VFW_Cov_lag(5, 1)  = UFW_Cov_lag_b1   'b1 indicates backward 1 scan  
Alias UFW_VFW_Cov_lag(5, 2)  = VFW_Cov_lag_b1
Alias UFW_VFW_Cov_lag(6, 1)  = UFW_Cov_lag_0    '0 indicates neither backward nor forward   
Alias UFW_VFW_Cov_lag(6, 2)  = VFW_Cov_lag_0
Alias UFW_VFW_Cov_lag(7, 1)  = UFW_Cov_lag_f1   'f1 indicates forward 1 scan    
Alias UFW_VFW_Cov_lag(7, 2)  = VFW_Cov_lag_f1
Alias UFW_VFW_Cov_lag(8, 1)  = UFW_Cov_lag_f2   'f2 indicates forward 2 scans  
Alias UFW_VFW_Cov_lag(8, 2)  = VFW_Cov_lag_f2
Alias UFW_VFW_Cov_lag(9, 1)  = UFW_Cov_lag_f3   'f3 indicates forward 3 scans    
Alias UFW_VFW_Cov_lag(9, 2)  = VFW_Cov_lag_f3
Alias UFW_VFW_Cov_lag(10, 1) = UFW_Cov_lag_f4   'f4 indicates forward 4 scans  
Alias UFW_VFW_Cov_lag(10, 2) = VFW_Cov_lag_f4
Alias UFW_VFW_Cov_lag(11, 1) = UFW_Cov_lag_f5   'f5 indicates forward 5 scans  
Alias UFW_VFW_Cov_lag(11, 2) = VFW_Cov_lag_f5
Units UFW_VFW_Cov_lag       = deg C m s-1

'Variables found from Cov_out_FW(), WFW_Cov_lag_R(), and UFW_VFW_Cov_lag_R() according to the lag  
Dim   WFW_Cov_lag_max (2)
Alias WFW_Cov_lag_max (1) = WFW_Cov             'Max covariance among lagged covariance values and will be used for sensible heat flux after freq correction    
Alias WFW_Cov_lag_max (2) = lag_FW              'Lag number in scans, also used for sequential number in an array index for lag Cov_out_FW(), WFW_Cov_lag() and UFW_VFW_cov_lag()    
Units WFW_Cov             = deg C m s-1
Units lag_FW              = scans 

Dim   FW_Avg                                    'Selected from cov_out_FW() according to lag maximization using lag_FW    
Dim   FW_SIGMA                                  'Selected from cov_out_FW() according to lag maximization using lag_FW   
Units FW_Avg   = deg C  
Units FW_SIGMA = deg C

Dim   UxFW_Cov                                  'Selected from cov_out_FW() using lag_FW  
Dim   UyFW_Cov                                  'Selected from cov_out_FW() using lag_FW   
Dim   UzFW_Cov                                  'Selected from cov_out_FW() using lag_FW  
Units UxFW_Cov  = deg C m s-1
Units UyFW_Cov  = deg C m s-1
Units UzFW_Cov  = deg C m s-1

Dim nmbr_smpl_FW                                'Number of samples used for flux statistics related to FW 
Units nmbr_smpl_FW = Samples

Dim   UFW_Cov                                   'Selected from UFW_VFW_cov_lag() according to lag maximization using lag_FW  
Dim   VFW_Cov                                   'Selected from UFW_VFW_cov_lag() according to lag maximization using lag_FW
'For "WFW_Cov", see "wFW_Cov_lag_max (1)"  
Units UFW_Cov = deg C m s-1
Units VFW_Cov = deg C m s-1

' Variables after coordinate rotations and freq corrections as indicated by "fc"
Dim   WFW_Cov_fc
Units WFW_Cov_fc = deg C m s-1
 
' Sensible heat flux 
Public H_FW
Units  H_FW = W m-2

'Delay table for high frequency data
DataTable (delay_fw, TRUE, (OFFSET + MAX_LAG))   ' + MAX_LAG. Add more records of MAX_LAG for use in finding a lag for FW 
  TableHide
  Sample (1, FW_raw,      IEEE4)
  Sample (1, diag_FW_raw, IEEE4)
EndTable

'Compute covariance of FW against CSAT wind data over an output interval
DataTable (comp_cov_fw, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average    (1, Cov_array_FW(1, 1), IEEE4, FW_bad_data_flg(1))
  Covariance (4, Cov_array_FW(1, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(1)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(1)))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b5")
  
  Average    (1, Cov_array_FW(2, 1), IEEE4, FW_bad_data_flg(2))
  Covariance (4, Cov_array_FW(2, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(2)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(2)))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b4")
   
  Average    (1, Cov_array_FW(3, 1), IEEE4, FW_bad_data_flg(3))
  Covariance (4, Cov_array_FW(3, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(3)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(3))))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b3")  

  Average    (1, Cov_array_FW(4, 1), IEEE4, FW_bad_data_flg(4))
  Covariance (4, Cov_array_FW(4, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(4)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(4)))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b2")

  Average    (1, Cov_array_FW(5, 1), IEEE4, FW_bad_data_flg(5))
  Covariance (4, Cov_array_FW(5, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(5)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(5)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b1")
  
  Average    (1, Cov_array_FW(6, 1), IEEE4, FW_bad_data_flg(6))
  Covariance (4, Cov_array_FW(6, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(6)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(6)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_0")
  
  Average    (1, Cov_array_FW(7, 1), IEEE4, FW_bad_data_flg(7))
  Covariance (4, Cov_array_FW(7, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(7)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(7)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f1")
  
  Average    (1, Cov_array_FW(8, 1), IEEE4, FW_bad_data_flg(8))
  Covariance (4, Cov_array_FW(8, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(8)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(8)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f2")
  
  Average    (1, Cov_array_FW(9, 1), IEEE4, FW_bad_data_flg(9))
  Covariance (4, Cov_array_FW(9, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(9)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(9)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f3")
  
  Average    (1, Cov_array_FW(10, 1), IEEE4, FW_bad_data_flg(10))
  Covariance (4, Cov_array_FW(10, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(10)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(10)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f4")
  
  Average    (1, Cov_array_FW(11, 1), IEEE4, FW_bad_data_flg(11))
  Covariance (4, Cov_array_FW(11, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(11)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(11)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f5")
EndTable
'*** END OF FW: CONSTANTS, VARIABLES, AND WORKING DATA TABLE *** 
#EndIf  

  
#If (SENSOR_T_RH) Then
'************************************************************************************************
'*** BEGINNING OF TEMPERATURE AND HUMIDITY PROBE CONSTANTS, VARIABLES, AND WORKING DATA TABLE ***
'************************************************************************************************
Public tmpr_rh(7)
Alias tmpr_rh(1) = T_probe                    'Temperature/humidity probe: Temperature
Alias tmpr_rh(2) = RH_probe                   'Temperature/humidity probe: Relative humidity
Alias tmpr_rh(3) = T_DP_Probe                 'Temperature/humidity probe: Dew point temperature 
Alias tmpr_rh(4) = e_probe                    'Temperature/humidity probe: vapor pressure
Alias tmpr_rh(5) = e_sat_probe                'Temperature/humidity probe: Saturate vapor pressure
Alias tmpr_rh(6) = H2O_probe                  'Temperature/humidity probe: Water vapor density 
Alias tmpr_rh(7) = rho_d_probe                'Temperature/humidity probe: Dry air density 
Units T_probe     = deg C
Units RH_probe    = %
Units T_DP_Probe  = deg C
Units e_probe     = kPa
Units e_sat_probe = kPa  
Units H2O_probe   = g/m^3
Units rho_d_probe = g/m^3
    
Dim Enhance_factor1_probe                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim Enhance_factor2_probe                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim x_tmp_probe                               'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim Td_gp_probe                               'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature

Dim stats_out_tmpr_rh(8)                      'Temperature/humidity probe: statistics
Alias stats_out_tmpr_rh(1) = TA_3_1_1         'Average temperature measured using temperature/humidity probe
Alias stats_out_tmpr_rh(2) = RH_3_1_1         'Average temperature measured using temperature/humidity probe
Alias stats_out_tmpr_rh(3) = T_DP_3_1_1       'Average dew point temperature measured using temperature/humidity probe 
Alias stats_out_tmpr_rh(4) = e_probe_Avg      'Average vapor pressure measured using temperature/humidity probe
Alias stats_out_tmpr_rh(5) = e_sat_probe_Avg  'Average saturation vapor pressure measured using temperature/humidity probe
Alias stats_out_tmpr_rh(6) = H2O_probe_Avg    'Average vapor density measured using temperature/humidity probe
Alias stats_out_tmpr_rh(7) = rho_d_probe_Avg  'Average dry air density measured using temperature/humidity probe
Alias stats_out_tmpr_rh(8) = rho_a_probe_Avg  'Average moist air density measured using Temperature/humidity probe
Units TA_3_1_1        = deg C
Units RH_3_1_1        = %
Units T_DP_3_1_1      = deg C
Units e_probe_Avg     = kPa
Units e_sat_probe_Avg = kPa
Units H2O_probe_Avg   = g m-3
Units rho_d_probe_Avg = g m-3
Units rho_a_probe_Avg = kg m-3

DataTable (stats_tmpr_rh,TRUE,1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average (7, T_probe, IEEE4, slowsequence_disable_f)

EndTable
'*** END OF TEMPERATURE AND HUMIDITY PROBE CONSTANTS, VARIABLES, AND WORKING DATA TABLE ***
#EndIf

#If (SENSOR_TE525) Then
'*****************************************************
'*** BEGINNING OF TE525MM: CONSTANTS AND VARIABLES ***
'*****************************************************
Public P
Units  P = mm

Dim P_cumul_win_interval                     'Use to indicate the rain within current interval to judge poor_energy_closure_flg 
Units P_cumul_win_interval = mm
'*** END OF TE525MM: CONSTANTS AND VARIABLES ***
#EndIf

#If (SENSOR_Rn) Then
'********************************************************************
'*** BEGINNING OF NET RADIOMETER: CONSTANTS, VARIABLES, AND TABLE ***
'********************************************************************
Dim NETRAD_raw                                         'Net radiation: Measured time series data

Public nr_mean(7 - 1*SENSOR_SN500)                     'Radiation components measured from one net radiometer or one 4-way net radiometer.
Alias nr_mean(1) = NETRAD                              'Net radiation: mean over an averaging interval
Units NETRAD     = W m-2

#If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
Alias nr_mean(2) = ALB                                 'Albedo in AmerFlux format
Alias nr_mean(3) = SW_IN_net_rdmtr                     'Incoming (downwelling) short wave radiation (This variable should be SW_IN in the final storage
'being name this way for the eventual use of SW_IN if other sensor (e.g. CS300) is used for Incoming SW radiation)
Alias nr_mean(4) = SW_OUT                              'Outgoing (upwelling) short wave radiation
Alias nr_mean(5) = LW_IN                               'Incoming (downwelling) long wave radiation
Alias nr_mean(6) = LW_OUT                              'Outgoing (upwelling) long wave radiation
Alias nr_mean(7) = T_nr_Avg                            'Sensor body temperature. 
#If (SENSOR_SN500) Then
Alias nr_mean(8) = T_nr_out_Avg                        'Sensor body temperature of SN500 for long-wave outgoing 
#EndIf 
Units ALB             = %
Units SW_IN_net_rdmtr = W m-2
Units SW_OUT          = W m-2
Units LW_IN           = W m-2
Units LW_OUT          = W m-2
Units T_nr_Avg        = Klvin
#If (SENSOR_SN500) Then
Units T_nr_out_Avg    = Klvin
#EndIf 
#EndIf

#If (SENSOR_NRLIT) Then
'*** Beginning of NR Lite constants and variables ***
Dim   NETRAD_meas                                    'Measured Rn uncorrected by horizontal wind speed
Units NETRAD_meas = W m-2
#EndIf 

#If (SENSOR_NRLIT OR (SENSOR_CNR4 AND SENSOR_CNF4)) Then
'Calculate the wind speed within last 3 seconds for NRLIT or CNF4  
Const  NMBR_WND_SAMPLES = 3000/SCN_INTV              'Number of measurements to compute a three-second mean of horizontal wind to correct measured NETRAD_meas as NETRAD_raw  
Dim hor_wind_raw                                     'Resultant wind at the frequency of scans. This data will be used in AvgRun instruction to calculate hor_wind
Dim hor_wind                                         'Running average from hor_wind_raw over three seconds
Dim hor_wind_diag                                    'Diagnosis code: non-zero if any of recent sonic_irga_raw(5) over the running average interval of last 3 seconds
#EndIf 
#If (SENSOR_NRLIT) Then
'*** End of NR Lite constants AND variables ***
#EndIf

#If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
'*** Beginning of 4-way net radiometer constants and variables ****
Public nr(7 - 1*(SENSOR_NR01 OR SENSOR_CNR4))      'Radiation components measured from a 4-way net radiometer.
Alias nr(1) = albedo
Alias nr(2) = R_SW_in              'Incoming (downwelling) short wave radiation
Alias nr(3) = R_SW_out             'Outgoing (upwelling) short wave radiation
Alias nr(4) = R_LW_in              'Incoming (downwelling) long wave radiation
Alias nr(5) = R_LW_out             'Outgoing (upwelling) long wave radiation
Alias nr(6) = T_nr                 'Sensor body temperature
#If (SENSOR_SN500) Then 
Alias nr(7) = T_nr_out             'Sensor body temperature of SN500 for outgoing long-wave radiation
#EndIf 
#If (SENSOR_NR01 OR SENSOR_CNR4) Then
Alias nr(7) = R_LW_in_meas         'Measured signal of incoming (downwelling) long wave radiation
Alias nr(8) = R_LW_out_meas        'Measured signal of outgoing (upwelling) long wave radiation
#EndIf
Units albedo        = %
Units R_SW_in       = W m-2
Units R_SW_out      = W m-2
Units R_LW_in       = W m-2
Units R_LW_out      = W m-2
Units T_nr          = Klvin
#If (SENSOR_SN500) Then 
Units T_nr_out      = Klvin        'Sensor body temperature
#EndIf 
#If (SENSOR_NR01 OR SENSOR_CNR4) Then
Units R_LW_in_meas  = W m-2
Units R_LW_out_meas = W m-2
#EndIf

#If (SENSOR_NR01 OR SENSOR_CNR4) Then
Const CNR4NR01_HEATER_T_TD_THRSHLD  = 2                                   'Threshold of difference between air temperature and dew point temperature
#If (SENSOR_NR01) Then 
Dim NR01_heater_secs = SCN_INTV/1000                                      'Totalize the seconds Flux_Notes during which NR01 heater on
Dim NR01_heater_on_f As Boolean
#EndIf 
#EndIf 

#If (SENSOR_CNR4) Then
'YSI 44031 Steinhart-Hart coefficients fit through -40 degrees C (239800 ohms), 20 degrees C (12260 ohms), and 80 degrees C (1458 ohms).
Const A_SHH = 1.0295e-3           'Steinhart-Hart A coefficient (from Kipp & Zonen through email April 16 2015).
Const B_SHH = 2.3910e-4           'Steinhart-Hart B coefficient (from Kipp & Zonen through email April 16 2015).
Const C_SHH = 1.5680e-7           'Steinhart-Hart C coefficient (from Kipp & Zonen through email April 16 2015).
Dim X_cnr4
Dim ln_R

#If (SENSOR_CNF4) Then 
Const CNR4_FAN_WND_THRSHLD      = 8                                          'Wind threshold to turn on CNR4 fan 

Dim cnr4_fan_heater_on(3)  As Boolean 
Alias cnr4_fan_heater_on(1) = cnr4_fan_on_f   
Alias cnr4_fan_heater_on(2) = cnr4_heater_1_on_f   
Alias cnr4_fan_heater_on(3) = cnr4_heater_2_on_f 
 
Dim cnr4_fan_heater_array(3) = {SCN_INTV/1000, SCN_INTV/1000, SCN_INTV/1000} 
Alias cnr4_fan_heater_array(1) = cnr4_fan_secs                               'Totalize the seconds Flux_Notes during which CNR4 fan was on
Alias cnr4_fan_heater_array(2) = cnr4_heater_1_secs                          'Totalize the seconds Flux_Notes during which CNR4 heater #1 was on
Alias cnr4_fan_heater_array(3) = cnr4_heater_2_secs                          'Totalize the seconds Flux_Notes during which CNR4 heater #2 was on
Units cnr4_fan_heater_array = s 
      
Public cnr4_fan_freq
Units  cnr4_fan_freq = Hz      
#EndIf 

#EndIf

#If (SENSOR_SN500) Then 
Dim body_tmpr_SN500(4) 
Alias  body_tmpr_SN500(1) = LW_in_sgnl_mV
Alias  body_tmpr_SN500(2) = LW_in_tmpr
Alias  body_tmpr_SN500(3) = LW_out_sgnl_mV
Alias  body_tmpr_SN500(4) = LW_out_tmpr      
        
Const SN500_HEATER_T_TD_THRSHLD  = 2                                 'Threshold of difference between air temperature and dew point temperature   
     
Dim sn500_heater_set_dummy                                           'Dummy variable 
Dim sn500_heater_on_f As Boolean
Dim sn500_heater_secs = SCN_INTV/1000  
#EndIf

'*** End of 4-way net radiometer constants and variables ****
#EndIf

DataTable (stats_net_radiation, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average (1, NETRAD_raw, IEEE4, slowsequence_disable_f)

  #If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
  Average (6, albedo,   IEEE4, slowsequence_disable_f)  
  #If (SENSOR_SN500) Then
  Average (1, T_nr_out, IEEE4, slowsequence_disable_f)  
  #EndIf
  #EndIf

EndTable
'*** END OF NET RADIOMETER: CONSTANTS, VARIABLES, AND TABLE ***
#EndIf '(SENSOR_Rn)

#If (SENSOR_HFP) Then
'*************************************************************
'*** BEGINNING OF HFP01 OR HFP01SC CONSTANTS AND VARIABLES ***
'*************************************************************
Dim shf_plate_cal(NMBR_HFP)             'Hold calibration of soil heat flux plates

Public shf_plate(NMBR_HFP)              'Soil heat flux through soil heat flux plates
Units shf_plate = W m-2

Public shf_plate_avg(NMBR_HFP)          'Mean soil heat flux through soil heat flux plates
Alias shf_plate_avg(1) = G_plate_1_1_1
#If (NMBR_HFP > 1) Then 
Alias shf_plate_avg(2) = G_plate_2_1_1
#EndIf 
#If (NMBR_HFP > 2) Then 
Alias shf_plate_avg(3) = G_plate_3_1_1
#EndIf   
Units shf_plate_avg = W m-2

#If (SENSOR_HFP01SC) Then
'*** Beginning of HFP01SC constants and variables ***
Const END_CAL = OUTPUT_INTV - 1          'End HFP01SC insitu calibration one minute before the next output.
Dim shf_mV(NMBR_HFP)                     'Voltage measured from soil heat flux plates
Dim shf_mV_run(NMBR_HFP)                 'Running mean of shf_mV
Dim shf_mV_0(NMBR_HFP)                   'Running mean of shf_mV at the beginning of calibration
Dim shf_mV_180(NMBR_HFP)                 'Running mean of shf_mV after 180 seconds since the beginning of calibration
Dim shf_mV_end(NMBR_HFP)                 'Running mean of shf_mV at the end of calibration
Dim V_Rf(NMBR_HFP)                       'Reference voltage
Dim V_Rf_run(NMBR_HFP)                   'Running mean of reference voltage
Dim V_Rf_180(NMBR_HFP)                   'Running mean of reference voltage after 180 seconds since the beginning of calibration
Dim shf_cal_on_f   As Boolean
'*** End of HFP01SC constants and variables ***
#EndIf

DataTable (stats_SHF, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)
  #If (SENSOR_HFP01) Then
  Average (NMBR_HFP, shf_plate(1), IEEE4, slowsequence_disable_f)
  #EndIf

  #If (SENSOR_HFP01SC) Then
  Average (NMBR_HFP, shf_plate(1), IEEE4, (shf_cal_on_f OR slowsequence_disable_f))
  #EndIf
EndTable
'*** END OF HFP01 OR HFP01SC CONSTANTS AND VARIABLES ***
#EndIf
#If (SENSOR_TCAV) Then

'*************************************************
'*** BEGINNING OF TCAV CONSTANTS AND VARIABLES ***
'*************************************************
Public Tsoil(NMBR_TCAV)                 'TCAV soil temperature.
Units Tsoil = deg C
'*** END OF TCAV CONSTANTS AND VARIABLES ***
#EndIf
#If (SENSOR_CS6XX) Then 


'**************************************************
'*** BEGINNING OF CS6xx CONSTANTS AND VARIABLES ***
'**************************************************
#If (SENSOR_CS616) Then
'*** Beginning of CS616 constants and variables ***
Public cs616_wcr(NMBR_CS6xx)            'Water content reflectometer period.
Units cs616_wcr = usec

#If (SENSOR_CS616 AND (NOT SENSOR_TCAV)) Then
Public soil_wtr(NMBR_CS6xx)             'Volumetric soil water content without temperature correction.
Units soil_wtr = frac_v_wtr
#EndIf

#If (SENSOR_CS616 AND SENSOR_TCAV) Then
Dim Tsoil_for_CS616_correct(NMBR_CS6xx) 'Soil temperature used for CS616 temperature correction. This variable is defined in case: NMBR_TCAV <> NMBR_CS6xx
Dim cs616_wcr_T(NMBR_CS6xx)             'Water content reflectometer period with temperature correction.

Public soil_wtr_T(NMBR_CS6xx)           'Volumetric soil water content with temperature correction.
Units soil_wtr_T = frac_v_wtr
#EndIf
'*** End of CS616 constants and variables ***
#EndIf
#If (SENSOR_CS65X) Then
'*** Beginning of CS65X constants and variables ***
Public cs65x_wc(NMBR_CS6xx)             'Volumetric soil water content.
Public cs65x_ec(NMBR_CS6xx)             'Electrical conductivity.
Public cs65x_tmpr(NMBR_CS6xx)           'CS65X probe temperature.
Dim cs65x_raw(3)                        'Hold CS65X raw variables
Units cs65x_wc = %
Units cs65x_ec = dS m-1
Units cs65x_tmpr = deg C
'*** End of CS65X constants and variables ***
#EndIf
'Soil water contents measured using CS655 OR CS616 w/ or w/o soil temperature correction will be moved to this array  
Dim SWC_array(NMBR_CS6xx)              'Soil water contents measured from                
Alias SWC_array(1) = SWC_1_1_1
#If (NMBR_CS6xx > 1) Then 
Alias SWC_array(2) = SWC_2_1_1
#EndIf 
#If (NMBR_CS6xx > 2) Then 
Alias SWC_array(3) = SWC_3_1_1
#EndIf 

Units SWC_array = % 
'*** END OF CS6xx CONSTANTS AND VARIABLES ***
#EndIf

#If (SENSOR_CS65X OR SENSOR_TCAV) Then 
'************************************************************
'*** BEGINNING OF ADDITIONAL VARIABLES FOR CS65X AND TCAV ***
'************************************************************
Dim TS_array(3)                                                                'Soil Temperature measured from TCAV or CS655                
Alias TS_array(1) = TS_1_1_1
Alias TS_array(2) = TS_2_1_1                                                   'The use of this variable depends on the NUMBR_TCAV or NUMBR_CS6xx
Alias TS_array(3) = TS_3_1_1                                                   'The use of this variable depends on the NUMBR_TCAV or NUMBR_CS6xx
Units TS_array = deg C   
'*** END OF ADDITIONAL VARIABLES FOR CS65X AND TCAV ***
#EndIf

#If (SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X)) Then
'********************************************************************************
'*** BEGINNING OF VARIABLES FOR CALCULATION OF SOIL HEAT FLUX AT SOIL SURFACE ***
'********************************************************************************
Const NMBR_SOIL_T_WTR_DEL_SAMPLES = INT((60*1000)/SLW_SCN_INTV +1)    'Number of measurements to compute a one-minute mean of soil temperature and water
                                                                      'If SLW_SCN_INTV < 1 min, the most recent one measurement is used. 
Public G_surface_rep(NMBR_HFP)            'Soil heat flux at the ground surface from individual replications
Alias  G_surface_rep(1) = G_1_1_1
#If (NMBR_HFP > 1) Then 
Alias  G_surface_rep(2) = G_2_1_1
#EndIf 
#If (NMBR_HFP > 2) Then   
Alias  G_surface_rep(3) = G_3_1_1
#EndIf 
Units  G_surface_rep = W m-2


Public G_surface                          'Soil heat flux at the ground surface (In the final storage, this variable was renamed as G, using FieldNames, consistent with AmeriFlux notation)
Units  G_surface = W m-2

Dim Tsoil_current(3)                      'Indididual Tsoil means of last one-minute measurements in the current averaging interval from TCAV or cs65x_tmpr(NMBR_CS6xx) if TCAV unavailable, but CS65x available
Dim Tsoil_prev(3) = {NaN, NaN, NaN}       'Individual Tsiol means of Tsoil_current () at the end of previous averaging interval 
    
Dim soil_wtr_current(NMBR_CS6xx)          'One-minute running mean of cs65x_wc
Dim soil_wtr_prev (3) = {NaN, NaN, NaN}   'Average of soil_wtr_current() at the end of previous averaging interval
    ' Notes for NaN: Tsoil_prev(3) and soil_wtr_prev (3) are assigned as NaN indicating just after compiling and previous values unavailable, then are replaced with the current
    ' measured values. On subsequent averaging intervals, *_prev_Avg will be taken from the running mean of the last minute of the previous averaging interval.
    
Public SG_rep (NMBR_HFP)                  'The soil heat flux into or out of soil as heat storage above soil heat flux plates over an averaging interval for individual replications
Alias  SG_rep (1) = SG_1_1_1
#If (NMBR_HFP > 1) Then 
Alias  SG_rep (2) = SG_2_1_1
#EndIf
#If (NMBR_HFP > 2) Then 
Alias  SG_rep (3) = SG_3_1_1
#EndIf 

Public SG                                 'The soil heat flux into soil as heat storage above soil heat flux plates over an averaging interval
Units  SG = W m-2

' Variables used to calculate the number of seconds from the beginning of the program to the end of the first averaging interval (time interval offset)
Dim Offset_intv_delta_ht_storage          'time interval offset
'*** BEGINNING OF VARIABLES FOR CALCULATION OF SOIL HEAT FLUX AT SOIL SURFACE ***
#EndIf

#If (SENSOR_Rn AND SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X)) Then
'***********************************************************
'*** BEGINNING OF ENERGY BALANCE CONSTANTS AND VARIABLES ***
'***********************************************************
Public energy_closure                  '(LE + H)/(Rn-G_surface)
Units  energy_closure = fraction

#If (SENSOR_TE525) Then 
Public poor_energy_closure_flg As Boolean 
#EndIf
'*** END OF ENERGY BALANCE CONSTANTS AND VARIABLES ***
#EndIf

#If (SENSOR_CS301) Then
'*** BEGINNING OF PYRANOMETER CONSTANTS AND VARIABLES ***
Dim    SW_IN_pyran
Units  SW_IN_pyran = mV
'*** END OF PYRANOMETER CONSTANTS AND VARIABLES ***
#EndIf

#If (SENSOR_CS320) Then
  '********************************************************
  '*** BEGINNING OF PYRANOMETER CONSTANTS AND VARIABLES ***
  '********************************************************
  Public pyran(6)
  Alias pyran(1) = SW_IN_CS320    
  Alias pyran(2) = V_CS320                   'Voltage
  Alias pyran(3) = T_CS320                   'Temperature  
 'Defined in the right-handed coordinate system (x-axis along the wire in the direction pointed by cable pins)  
  Alias pyran(4) = x_incline                 'Positive if above the reference plane and negative if below the reference plane
  Alias pyran(5) = y_incline                 'Positive if above the reference plane and negative if below the reference plane 
  Alias pyran(6) = z_incline                 'Positive in a positive quadrat in the x-y plane and vice versa (author understanding)   
  Units SW_IN_CS320  = W m-2
  Units V_CS320      = mV
  Units T_CS320      = deg C
  Units x_incline    = decimal degrees
  Units y_incline    = decimal degrees
  Units z_incline    = decimal degrees  
  '*** END OF PYRANOMETER CONSTANTS AND VARIABLES ***
#EndIf

#If (SENSOR_CS301 OR SENSOR_CS320 OR SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then 
'*************************************************************************
'*** BEGINNING OF ADDITIONAL VARIABLE FOR SHORT WAVE RADIATION SENSORS ***
'*************************************************************************
Public SW_IN
Units  SW_IN = W m-2
'*** END OF ADDITIONAL VARIABLE FOR SHORT WAVE RADIATION SENSORS ***
#EndIf 

#If (SENSOR_CS310) Then
'****************************************************
'*** BEGINNING OF QUANTUM CONSTANTS AND VARIABLES ***
'****************************************************
Public PPFD_IN
Units  PPFD_IN = umolPhoton m-2 s-1
'*** END OF QUANTUM CONSTANTS AND VARIABLES ***
#EndIf

#If (DVC_CDM_A116) Then 
#If (SENSOR_SI111) Then
'****************************************************************
'*** BEGINNING OF INFRARED RADIOMETER CONSTANTS AND VARIABLES ***
'****************************************************************
Public T_CANOPY              'Temperature of surface that SI111 targets. we consider it as canopy temperature 
Public T_SI111_body          'Temperature of SI111 sensor body
Units  T_CANOPY      = deg C
Units  T_SI111_body  = deg C

Dim m_SI111, b_SI111         'Multiplier and offset in equation to calculate temperature of targeted surface using measured voltage and SI111 body temperature
'*** END OF INFRARED RADIOMETER CONSTANTS AND VARIABLES ***
#EndIf
#EndIf

'******************************
'*** BEGINNING DISPLAY MENU ***
'******************************
DisplayMenu ("System Control", TRUE)
  SubMenu ("Site Var Settings")
    MenuItem ("Meas Height",   height_measurement)
    MenuItem ("Surface Type", surface_type)
      MenuPick (CROP, GRASS, FOREST, SHRUB, BARELAND, WATER, ICE)
    MenuItem ("Canopy Height", height_canopy)
    MenuItem ("d, 0 = auto",   displacement_user)                        'if 0, zero displacement is automatically calculated in the program
    MenuItem ("z0,0 = auto",   roughness_user)                           'if 0, roughness length is automatically calculated in the program
    #If (SENSOR_GPS) Then 
    MenuItem ("GPS Height",    height_GPS16X)   
    #EndIf 

    #If ((SENSOR_HFP) AND (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
    MenuItem ("Bulk Density", soil_bulk_density)
    MenuItem ("C_dry_soil",   Cds)
    MenuItem ("HFP Depth",    thick_abv_SHFP)
    #EndIf

    #If (CSAT3A_EC150) Then 
    MenuItem ("IRGA Coord x", separation_x_irga)
    MenuItem ("IRGA Coord y", separation_y_irga)
    #EndIf

    #If (SENSOR_FW) Then
    MenuItem ("FW Coord x",  separation_x_FW)
    MenuItem ("FW Coord y",  separation_y_FW)
    MenuItem ("FW Dim",      FW_diameter)
      MenuPick (FW05DIA, FW1_DIA, FW2_DIA, FW3_DIA)
    #EndIf

    MenuItem ("Sonic Azmth", sonic_azimuth)
    MenuItem ("Latitude",    latitude)
    MenuItem ("Hemisph_NS",  hemisphere_NS)
      MenuPick (NORTH, SOUTH)
    MenuItem ("Longitude",   longitude)
    MenuItem ("Hemisph_EW",  hemisphere_EW)
      MenuPick (EAST, WEST)
    MenuItem ("Altitude",    altitude)
    
    SubMenu ("Planar Fit Alpha")
      MenuItem ("<=60or>=300",  alpha_PF_60_300)           'Angle in CSAT coordinate system
      MenuItem (">60 & <=170",  alpha_PF_60_170)
      MenuItem (">170 & <190",  alpha_PF_170_190)
      MenuItem (">=190 & <300", alpha_PF_190_300)
    EndSubMenu

    SubMenu ("Planar Fit Beta")
      MenuItem ("<=60or>=300",  beta_PF_60_300)            'Angle in CSAT coordinate system
      MenuItem (">60 & <=170",  beta_PF_60_170)
      MenuItem (">170 & <190",  beta_PF_170_190)
      MenuItem (">=190 & <300", beta_PF_190_300)
    EndSubMenu

    SubMenu ("Footprt Dist Intrst")
      MenuItem ("<=60or>=300",  dist_intrst_60_300)        'Angle in CSAT coordinate system
      MenuItem (">60 & <=170",  dist_intrst_60_170)
      MenuItem (">170 & <190",  dist_intrst_170_190)
      MenuItem (">=190 & <300", dist_intrst_190_300)
    EndSubMenu
  
  EndSubMenu
  
  SubMenu ("Instrument Settings")

    SubMenu ("Change Press Source")
      MenuItem ("Select Source", press_source)
        MenuPick (BB, UB, EB)
      MenuItem ("Set Source",  set_press_source_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    SubMenu ("Switch IRGA Power")
      MenuItem ("IRGA Power", IRGA_power_off)
        MenuPick (POWER_ON, POWER_OFF)
      MenuItem ("Set IRGA Power", set_IRGA_power_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    SubMenu ("Heater Control")
      MenuItem ("Select Heater Control", heater)
        MenuPick (HEATER_AUTO, HEATER_MAX, HEATER_OFF)
      MenuItem ("Set Heater Control", set_heater_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    SubMenu ("Select CO2 for Comp")
      MenuItem ("CO2 fast T", select_CO2_fast_tmpr)
        MenuPick (FAST_ON, FAST_OFF)
      MenuItem ("Set CO2 Selected", set_CO2_fast_tmpr_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    SubMenu ("Shadow Correction")
      MenuItem ("Correction", shadow_corr)
        MenuPick (CORR_ON, CORR_OFF)
      MenuItem ("Set Corr", set_shadow_corr_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu

   EndSubMenu

   SubMenu ("On-Site Zero & Span")
     SubMenu ("CO2 & H2O Zero")
      MenuItem ("Set Zero", set_zero_flg)
      MenuPick (TRUE, FALSE)
     EndSubMenu
     
   SubMenu ("CO2 Span")
      MenuItem ("CO2 umol",     CO2_span_gas)
      MenuItem ("Set CO2 Span", set_CO2_span_flg)
        MenuPick (TRUE, FALSE)
   EndSubMenu
   
   SubMenu ("H2O Span")
      MenuItem ("T_DP",         T_DP_span_gas)
      MenuItem ("Set H2O Span", set_H2O_span_flg)
        MenuPick (TRUE, FALSE)
   EndSubMenu
      
    DisplayValue ("CO2_mixratio", CO2_mixratio)
    DisplayValue ("H2O_mixratio", H2O_mixratio)
    DisplayValue ("T_DP deg C", T_DP)
    
    #If (SENSOR_T_RH) Then
    DisplayValue ("T_DP_Probe deg C", T_DP_Probe)
    #EndIf

  EndSubMenu
EndMenu
'*** END DISPLAY MENU ***
  

'***********************************************'
'*** FLUX TABLE IN AmeriFlux VARIABLE FORMAT ***'
'***********************************************'
DataTable (Flux_AmeriFluxFormat, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTV, Min, 0)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&"_Flux_AmeriFluxFormat_", -259, -1, 0, DAY_FLUX_CRD, day, 0, 0)
  
 'Time stamp
  Sample (2, TIMESTAMP_START, IEEE8)   
  
  '***GASES
  Sample (2, CO2,           IEEE4)  'CO2 and CO2_SIGMA
  Sample (2, H2O,           IEEE4)  'H2O and H2O_SIGMA     
  Sample (1, FC,            IEEE4)  'CO2 flux in umol/(m^2 s) after coordinate rotations, freq corrections, and WPL correction
  Sample (1, FC_SSITC_TEST, Long)   'Results of the Steady State and Integral Turbulence Characteristics for FC according to Foken et al (2004)
  
  '***HEAT  
  Sample (1, LE,            IEEE4)  'Latent heat flux after coordinate rotations, freq corrections, and WPL correction
  Sample (1, LE_SSITC_TEST, Long)   'Results of the Steady State and Integral Turbulence Characteristics for LE and ET according to Foken et al (2004)
  Sample (1, ET,            IEEE4)  'Evapotranspiration after coordinate rotations, freq corrections, and WPL correction
  Sample (1, LE_SSITC_TEST, Long)   'Results of the Steady State and Integral Turbulence Characteristics for LE used for ET according to Foken et al (2004)
  FieldNames ("ET_SSITC_TEST") 
  Sample (1, H,             IEEE4)  'Sensible heat flux (derived from sonic temperature flux with SND correction after coordinate rotations and freq corrections)
  Sample (1, H_SSITC_TEST,  Long)   'Results of the Steady State and Integral Turbulence Characteristics for LE according to Foken et al (2004)   
  
  #If (SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X))  Then
  Sample (1, G_surface,     IEEE4)  'Soil heat flux at the ground surface
  FieldNames ("G")  
  Sample (1, SG,            IEEE4)  'Heat storage in the soil above the soil heat flux plates between the beginning and end of average interval 
  #EndIf

  '***FOOTPRINT 
  Sample (1, FETCH_MAX,     IEEE4)  'Upwind location of source/sink that contributes most to the measured flux
  Sample (1, FETCH_90,      IEEE4)  'Upwind range within which sources/sinks contributes 90% the measured flux
  Sample (1, FETCH_55,      IEEE4)  'Upwind range within which sources/sinks contributes 55% the measured flux
  Sample (1, FETCH_40,      IEEE4)  'Upwind range within which sources/sinks contributes 40% the measured flux  
  
  '***MET_WIND
  Sample (1, WD,             IEEE4)  'Wind direction.
  Sample (1, WS,             IEEE4)  'Resultant wind speed.
  Sample (1, WS_MAX,         IEEE4)  'Maximum wind speed.
  Sample (1, USTAR,          IEEE4)  'Friction velocity after coordinate rotations and freq corrections
  Sample (1, ZL,             IEEE4)  'Atmospheric boundary-layer stability.  
  Sample (1, TAU,            IEEE4)  'Momentum flux after coordinate rotations and freq corrections,
  Sample (1, TAU_SSITC_TEST, Long)   'Results of the Steady State and Integral Turbulence Characteristics for TAU according to Foken et al (2004)    
  Sample (1, MO_LENGTH,      IEEE4)  'Monin-Obukhov length
  Sample (1, U,              IEEE4)  'Average wind speed in stream-wise direction after coordinate rotation   
  Sample (1, U_SIGMA,        IEEE4)  'Standard deviation of wind speed in stream-wise wind direction after coordinate rotation   
  Sample (1, V,              IEEE4)  'Average wind speed in cross-stream direction after coordinate rotation  
  Sample (1, V_SIGMA,        IEEE4)  'Standard deviation of wind speed in cross-stream direction after coordinate rotation  
  Sample (1, W,              IEEE4)  'Average vertical wind speed after coordinate rotation  
  Sample (1, W_SIGMA,        IEEE4)  'Standard deviation of vertical wind after coordinate rotation 
 
  '*** MET_ATM
  Sample (1, PA,             IEEE4)  'Atmospheric pressure 
  Sample (1, TA_1_1_1,       IEEE4)  'Air temperature from EC100 107 temperature probe
  Sample (2, RH_1_1_1,       IEEE4)  'RH_1_1_1 and T_DP_1_1_1. Calculated from 107 temperature, H2O, and pressure. 

  Sample (1, TA_2_1_1,       IEEE4)  'Air temperature calculated from sonic temperature, water vapor density, and pressure
  Sample (2, RH_2_1_1,       IEEE4)  'RH_2_1_1 and T_DP_2_1_1. Calculated from sonic temperature, H2O, and pressure. 
     
  #If (SENSOR_T_RH) Then
  Sample  (3, TA_3_1_1,      IEEE4)  'Measured from temperature and humidity probe: TA_3_1_1, RH_3_1_1, and T_DP_3_1_1
  #EndIf

  Sample (1, VPD,            IEEE4)  'Air vapor pressure deficit
  Sample (1, T_SONIC,        IEEE4)  'Average sonic temperature (Ts_Avg)  
  Sample (1, T_SONIC_SIGMA,  IEEE4)  'Standard deviation of sonic temperature.
  Sample (1, PBLH,           IEEE4)  'Planetary boundary layer height.

  #If (SENSOR_CS6XX OR SENSOR_TCAV) Then 
   'MET_SOIL
  #EndIf 
  
  #If (SENSOR_TCAV) Then
  Average (1, TS_1_1_1, IEEE4, slowsequence_disable_f)          'Soil temperature from TCAV
  FieldNames("TS_1_1_1")
  #If (NMBR_TCAV > 1) Then
  Average (1, TS_2_1_1, IEEE4, slowsequence_disable_f) 
  FieldNames("TS_2_1_1")
  #EndIf
  #If (NMBR_TCAV > 2) Then
  Average (1, TS_3_1_1, IEEE4, slowsequence_disable_f)
  FieldNames("TS_3_1_1")
  #EndIf
  #EndIf
  
  #If ((NOT SENSOR_TCAV) AND SENSOR_CS65X)  Then
  Average (1, TS_1_1_1, IEEE4, slowsequence_disable_f)           'Soil temperature from CS65x 
  FieldNames("TS_1_1_1")
  #If (NMBR_CS6xx > 1) Then
  Average (1, TS_2_1_1, IEEE4, slowsequence_disable_f) 
  FieldNames("TS_2_1_1")
  #EndIf
  #If (NMBR_CS6xx > 2) Then
  Average (1, TS_3_1_1, IEEE4, slowsequence_disable_f)
  FieldNames("TS_3_1_1")
  #EndIf
  #EndIf
  
  #If (SENSOR_CS616 AND SENSOR_TCAV) Then
  Average (1, SWC_1_1_1, IEEE4, slowsequence_disable_f)          'Measured using CS616. Volumetric soil water w/ temperature correction
  #EndIf
  #If (SENSOR_CS616 AND (NOT SENSOR_TCAV)) Then
  Average (1, SWC_1_1_1, IEEE4, slowsequence_disable_f)          'Measured using CS616. Volumetric soil water w/o temperature correction
  #EndIf
  #If (SENSOR_CS65X AND (NOT SENSOR_CS616)) Then
  Average (1, SWC_1_1_1, IEEE4, slowsequence_disable_f)          'Measured using CS65x. Volumetric soil water w/ temperature correction
  #EndIf 
  
  #If (SENSOR_CS6XX) Then 
  FieldNames ("SWC_1_1_1")
  #If (NMBR_CS6xx > 1) Then
  Average (1, SWC_2_1_1, IEEE4, slowsequence_disable_f)
  FieldNames ("SWC_2_1_1")
  #EndIf 
  #If (NMBR_CS6xx > 2) Then
  Average (1, SWC_3_1_1, IEEE4, slowsequence_disable_f)
  FieldNames ("SWC_3_1_1")
  #EndIf   
  #EndIf

  #If (SENSOR_Rn OR SENSOR_CS301 OR SENSOR_CS310 OR SENSOR_CS320) Then 
  'MET_RAD
  #EndIf 
  #If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
  Sample  (1, ALB, IEEE4)                                        'Albedo
  #EndIf
  
  #If (SENSOR_Rn) Then
  Sample (1, NETRAD, IEEE4)
  #EndIf

  #If (SENSOR_CS310) Then
  Average  (1, PPFD_IN, IEEE4, slowsequence_disable_f)
  FieldNames("PPFD_IN")
  #EndIf    

  #If (SENSOR_CS301 OR SENSOR_CS320 OR SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
  Average  (1, SW_IN, IEEE4, slowsequence_disable_f)             'For use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
  FieldNames("SW_IN")
  #EndIf

  #If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
  Sample  (3, SW_OUT, IEEE4)                                     'SW_OUT, LW_IN, and LW_OUT
  #EndIf
   
  #If (SENSOR_TE525) Then
  'MET_PRECIP  
  Totalize (1, P, IEEE4, 0)
  FieldNames("P")
  #EndIf
  
  #If (DVC_CDM_A116) Then 
  #If (SENSOR_SI111) Then
  'BIOLOGY  
  Average  (1, T_CANOPY, IEEE4, slowsequence_disable_f)         'Measured using SI111
  FieldNames("T_CANOPY")
  #EndIf
  #EndIf
  
EndTable  

'*****************************************'
'*** FLUX TABLE IN CSI VARIABLE FORMAT ***'
'*****************************************'
DataTable (Flux_CSFormat, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTV, Min, 0)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&"_Flux_CSFormat_", 64, -1, 0, DAY_FLUX_CRD, day, 0, LastFileName_flux_CSFormat)
    
  '*** flux and quality classification data 
  Sample (1, FC_mass, IEEE4)    'Carbon dioxide flux in mg/(m^2 s) after coordinate rotations, freq corrections, and WPL correction
  Sample (1, FC_QC,   Long)    'Overall grade of data quality for carbon dioxide flux (i.e. for variables: Fc and Fc_mass ) according to Foken et al. (2012)
  Totalize (1, n, Long, (sonic_disable_f OR irga_disable_f OR CO2_bad_rng_sig_array(MAX_LAG +1)))    'Totalize the number of samples for CO2 flux
  FieldNames ("FC_samples")

  Sample (1, LE,      IEEE4)    'Latent heat flux after coordinate rotations, freq corrections, and WPL correction
  Sample (1, LE_QC,   Long)    'Overall grade of data quality for latent heat flux (i.e. for variable: LE) according to Foken et al. (2012)
  Totalize (1, n, Long, (sonic_disable_f OR irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))    'Totalize the number of samples for latent heat flux
  FieldNames ("LE_samples")
          
  Sample (1, H,       IEEE4)    'Sensible heat flux (derived from sonic heat flux with SND correction after coordinate rotations and freq corrections)
  Sample (1, H_QC,    Long)    'Overall grade of data quality for sensible heat flux (i.e. for variable: H) according to Foken et al. (2012)
  Totalize (1, n, Long, (sonic_disable_f OR irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))  'Totalize the number of samples for sensible heat flux
  FieldNames ("H_samples")

  #If (SENSOR_FW) Then
  Sample (1, H_FW, IEEE4)                                         'Sensible heat flux measured using fine wire thermocouple (FW) after coordinate rotations and freq corrections
  Totalize (1, n, Long, (sonic_disable_f OR FW_bad_data_flg))    'Totalize the number of samples for FW-measured sensible heat flux
  FieldNames ("H_FW_samples")
  #EndIf
      
  #If (SENSOR_Rn) Then
  Sample (1, NETRAD, IEEE4)
  #EndIf

  #If (SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X))  Then
  Sample (1, G_surface, IEEE4)           'Soil heat flux at the ground surface
  FieldNames ("G")
  Sample (1, SG, IEEE4)                  'The change in heat storage above soil heat flux plates over the averaging interval 
  #EndIf
   
  #If (SENSOR_Rn AND SENSOR_HFP AND SENSOR_CS6XX AND  (SENSOR_TCAV OR SENSOR_CS65X)) Then
  Sample (1, energy_closure, IEEE4)      'Energy closure
  #If (SENSOR_TE525) Then  
  Sample (1, truefalse (2 + poor_energy_closure_flg), String) 'Flag indicates the drift of zero and span
  FieldNames ("poor_enrg_clsur") 
  #EndIf  
  #EndIf

  Sample (1, Bowen_ratio,   IEEE4)

  Sample (1, TAU,           IEEE4)       'Momentum flux after coordinate rotations and freq corrections,
  Sample (1, TAU_QC,        Long)        'Overall grade of data quality for momentum flux (i.e. for variable: TAU) according to Foken et al. (2012)

  '*** Turbulence characteristic variables
  Sample (1, USTAR,         IEEE4)      'Friction velocity after coordinate rotations and freq corrections
  Sample (1, TSTAR,         IEEE4)      'Scaling temperature after coordinate rotations and freq corrections
  Sample (1, TKE,           IEEE4)      'Specific turbulence kinetic energy after coordinate rotations

  '*** Air temperature and humidity 
  Sample (1, TA_1_1_1,      IEEE4)      'Air temperature from EC100 107 temperature probe
  Sample (2, RH_1_1_1,      IEEE4)      'RH_1_1_1, T_DP_1_1_1. Calculated from 107 temperature(TA_1_1_1), H2O, and pressure.
  Sample (1, amb_e_Avg,     IEEE4)      'Water vapor pressure calculated from 107 temperature(TA_1_1_1), H2O, and pressure.
  FieldNames("amb_e")
  Sample (1, amb_e_sat_Avg, IEEE4)      'Saturated water vapor pressure calculated from 107 temperature(TA_1_1_1), H2O, and pressure.
  FieldNames("amb_e_sat")

  Sample (1, TA_2_1_1,      IEEE4)      'Air temperature calculated from sonic temperature, H2O, and pressure
  Sample (2, RH_2_1_1,      IEEE4)      'RH_2_1_1, T_DP_2_1_1. Calculated from sonic temperature, H2O, and pressure.
  Sample (1, e_Avg,         IEEE4)      'Water vapor pressure calculated from sonic temperature, H2O, and pressure.
  FieldNames("e")
  Sample (1, e_sat_Avg,     IEEE4)      'Saturated water vapor pressure calculated from sonic temperature, H2O, and pressure.
  FieldNames("e_sat")  

  #If (SENSOR_T_RH) Then
  '*** Temperature and humidity probe data   
  Sample (1, TA_3_1_1,      IEEE4)      'Air temperature from temperature and humidity probe
  Sample (2, RH_3_1_1,      IEEE4)      'Measured from temperature and humidity probe: RH_3_1_1, T_DP_3_1_1
  Sample (3, e_probe_Avg,   IEEE4)      'Measured from temperature and humidity probe: e_probe_Avg, e_sat_probe_Avg, H2O_probe_Avg
  FieldNames("e_probe,e_sat_probe,H2O_probe")
  #EndIf
 
  Sample (1, PA,            IEEE4)      'Atmospheric pressure 
  Sample (1, VPD,           IEEE4)      'Air vapor pressure deficit

  '*** CSAT sonic head data 
  Sample (2, Ux_Avg,        IEEE4)      'Ux_avg and Ux_SIGMA before coordinate rotations
  FieldNames ("Ux,Ux_SIGMA")
  Sample (2, Uy_Avg,        IEEE4)      'Uy_avg and Uy_SIGMA before coordinate rotations
  FieldNames ("Uy,Uy_SIGMA")
  Sample (2, Uz_Avg,        IEEE4)      'Uz_avg and Uz_SIGMA before coordinate rotations
  FieldNames ("Uz,Uz_SIGMA")
  Sample (1, T_SONIC,       IEEE4)      'Average sonic temperature  
  Sample (1, T_SONIC_SIGMA, IEEE4)      'Standard deviation of sonic temperature. 
  Sample (1, sonic_azimuth, IEEE4)      'Sonic_azimuth, (see Section 3.2.1 CSAT3A Azimuth in the OPEC manual).
  Sample (4, WS,            IEEE4)      'WS, WS_RSLT, WD_SONIC, and WD_SIGMA.
  Sample (1, WD,            IEEE4)      'WD.
  Sample (1, WS_MAX,        IEEE4)      'WS_MAX. 
  '*** Gas data 
  Sample (2, CO2_density_Avg, IEEE4)    'CO2_density_Avg and CO2_density_SIGMA
  FieldNames("CO2_density,CO2_density_SIGMA")
    
  Sample (2, H2O_density_Avg, IEEE4)    'H2O_density_Avg, and H2O_density_SIGMA
  FieldNames("H2O_density,H2O_density_SIGMA")
 
  Minimum (1, CO2_sig_strgth, IEEE4, irga_disable_f, FALSE)
  FieldNames ("CO2_sig_strgth_Min")
  Minimum (1, H2O_sig_strgth, IEEE4, irga_disable_f, FALSE)
  FieldNames ("H2O_sig_strgth_Min")

  #If (SENSOR_FW) Then
  '*** Fine wire thermocouple data
  Sample (1, FW_Avg,     IEEE4)
  FieldNames ("FW")
  Sample (1, FW_SIGMA,   IEEE4)
  #EndIf
   
  #If (SENSOR_TE525) Then
  '*** Rain gauge data
  Totalize (1, P, IEEE4, 0)                 'Precipitation
  FieldNames("P")
  #EndIf
  
  #If (SENSOR_Rn OR SENSOR_CS301 OR SENSOR_CS310 OR SENSOR_CS320) Then 
  '*** Radiometer data 
  #EndIf 
  #If (SENSOR_NRLIT) Then
  Average (1, NETRAD_meas, IEEE4, slowsequence_disable_f)
  FieldNames ("NETRAD_meas")
  #EndIf

  #If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
  Sample  (1, ALB, IEEE4)                                                  'Albedo
  #EndIf

  #If (SENSOR_CS301 OR SENSOR_CS320 OR SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
  Average  (1, SW_IN, IEEE4, slowsequence_disable_f)                      'For use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
  FieldNames("SW_IN")
  #EndIf
  
  #If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
  Sample  (3, SW_OUT, IEEE4)                                              'SW_OUT, LW_IN, and LW_OUT
  #If (SENSOR_NR01 OR SENSOR_CNR4) Then
  Sample  (1, T_nr_Avg,       IEEE4)                                      'Average body temperature of net radiation sensor (T_nr_Avg)
  FieldNames ("T_nr")
  #EndIf
  #If (SENSOR_SN500) Then
  Sample  (2, T_nr_Avg,       IEEE4)                                      'Average body temperature of net radiation sensor SN500
  FieldNames ("T_nr_in,T_nr_out")                                         'T_nr_in and T_nr_out for incoming and outgoing long-wave components, repectively
  #EndIf
  #EndIf   

  #If (SENSOR_NR01 OR SENSOR_CNR4) Then
  Average (2, R_LW_in_meas,   IEEE4, slowsequence_disable_f)              'Average raw long-wave incoming radiation (R_LW_in_meas) and outgoing radiation (R_LW_out_meas) w/o temperature correction
  FieldNames ("R_LW_in_meas,R_LW_out_meas")
  #EndIf
  
  #If (SENSOR_CS310) Then
  Average  (1, PPFD_IN, IEEE4, slowsequence_disable_f)
  FieldNames("PPFD_IN")
  #EndIf
    
  Average  (5, sun_azimuth, IEEE4, slowsequence_disable_f)
  FieldNames("sun_azimuth,sun_elevation,hour_angle,sun_declination,air_mass_coeff")
  Totalize (1, daytime_frac_scan_intv, IEEE4, slowsequence_disable_f)
  FieldNames("daytime")
   
  #If (DVC_CDM_A116) Then 
  #If (SENSOR_SI111) Then
  '*** Surface temperature (i.e. canopy temperature) 
  Average  (1, T_CANOPY,     IEEE4, slowsequence_disable_f)
  FieldNames ("T_CANOPY")
  Average  (1, T_SI111_body, IEEE4, slowsequence_disable_f)
  FieldNames ("T_SI111_body")
  #EndIf
  #EndIf

  #If(SENSOR_TCAV OR SENSOR_CS65X)  Then
  '*** Soil temperature
  #EndIf      
  #If (SENSOR_TCAV) Then
  Average (1, TS_1_1_1, IEEE4, slowsequence_disable_f)       'Soil temperature from TCAV
  FieldNames ("TS_1_1_1")
  #If (NMBR_TCAV > 1) Then
  Average (1, TS_2_1_1, IEEE4, slowsequence_disable_f)
  FieldNames ("TS_2_1_1")
  #EndIf
  #If (NMBR_TCAV > 2) Then
  Average (1, TS_3_1_1, IEEE4, slowsequence_disable_f)
  FieldNames ("TS_3_1_1")
  #EndIf
  #EndIf
  
  #If ((NOT SENSOR_TCAV) AND SENSOR_CS65X)  Then
  Average (1, TS_1_1_1, IEEE4, slowsequence_disable_f)       'Soil temperature from CS65x
  FieldNames ("TS_1_1_1")
  #If (NMBR_CS6xx > 1) Then
  Average (1, TS_2_1_1, IEEE4, slowsequence_disable_f)
  FieldNames ("TS_2_1_1")
  #EndIf
  #If (NMBR_CS6xx > 2) Then
  Average (1, TS_3_1_1, IEEE4, slowsequence_disable_f)
  FieldNames ("TS_3_1_1")
  #EndIf
  #EndIf

  #If (SENSOR_CS6XX) Then
  'Soil moisture 
  #EndIf      

  #If (SENSOR_CS616 AND SENSOR_TCAV) Then
  Average (1, SWC_1_1_1, IEEE4, slowsequence_disable_f)     'CS616 volumetric soil water w/ temperature correction
  #EndIf
  #If (SENSOR_CS616 AND (NOT SENSOR_TCAV)) Then
  Average (1, SWC_1_1_1, IEEE4, slowsequence_disable_f)     'CS616 volumetric soil water w/o temperature correction
  #EndIf
  #If (SENSOR_CS65X) Then
  Average (1, SWC_1_1_1, IEEE4, slowsequence_disable_f)     'CS65x volumetric soil water content.  
  #EndIf 

  #If (SENSOR_CS6XX) Then 
  FieldNames ("SWC_1_1_1")
  #If (NMBR_CS6xx > 1) Then
  Average (1, SWC_2_1_1, IEEE4, slowsequence_disable_f)
  FieldNames ("SWC_2_1_1")
  #EndIf  
  #If (NMBR_CS6xx > 2) Then
  Average (1, SWC_3_1_1, IEEE4, slowsequence_disable_f)
  FieldNames ("SWC_3_1_1")
  #EndIf  
  #EndIf
  
  #If (SENSOR_CS616) Then
  Average (1, cs616_wcr(1), IEEE4, slowsequence_disable_f)   'CS616 period.
  FieldNames ("cs616_wcr_1_1_1")
  #If (NMBR_CS6xx > 1) Then
  Average (1, cs616_wcr(2), IEEE4, slowsequence_disable_f)
  FieldNames ("cs616_wcr_2_1_1")
  #EndIf
  #If (NMBR_CS6xx > 2) Then
  Average (1, cs616_wcr(3), IEEE4, slowsequence_disable_f)
  FieldNames ("cs616_wcr_3_1_1")
  #EndIf
  #EndIf
    
  #If (SENSOR_TCAV AND SENSOR_CS65X)  Then
  Average (1, cs65x_tmpr(1), IEEE4, slowsequence_disable_f)  'Soil temperature from CS65x
  FieldNames ("TS_CS65X_1_1_1")
  #If (NMBR_CS6xx > 1) Then
  Average (1, cs65x_tmpr(2), IEEE4, slowsequence_disable_f)
  FieldNames ("TS_CS65X_2_1_1")
  #EndIf
  #If (NMBR_CS6xx > 2) Then
  Average (1, cs65x_tmpr(3), IEEE4, slowsequence_disable_f)
  FieldNames ("TS_CS65X_3_1_1")
  #EndIf
  #EndIf
  
  #If (SENSOR_CS65X) Then
  Average (1, cs65x_ec(1), IEEE4, slowsequence_disable_f)     'Electrical conductivity.
  FieldNames ("cs65x_ec_1_1_1")
  #If (NMBR_CS6xx > 1) Then
  Average (1, cs65x_ec(2), IEEE4, slowsequence_disable_f)
  FieldNames ("cs65x_ec_2_1_1")
  #EndIf
  #If (NMBR_CS6xx > 2) Then
  Average (1, cs65x_ec(3), IEEE4, slowsequence_disable_f)
  FieldNames ("cs65x_ec_3_1_1")
  #EndIf
  #EndIf

  #If (SENSOR_HFP) Then
  '*** soil heat flux plat data 
  Sample (NMBR_HFP, G_plate_1_1_1, IEEE4)                     'Heat flux through a soil heat flux plate
  #EndIf

  #If ((SENSOR_HFP AND SENSOR_CS6XX) AND (SENSOR_TCAV OR SENSOR_CS65X)) Then
  Sample (NMBR_HFP, G_1_1_1,  IEEE4)       'Soil heat flux at the ground surface
  Sample (NMBR_HFP, SG_1_1_1, IEEE4)       'The soil heat flux into soil as heat storage above soil heat flux plates over an averaging interval
  #EndIf

  '*** Footprint characteristics 
  Sample (1, FETCH_MAX,         IEEE4)  'Upwind location of source/sink that contributes most to the measured flux
  Sample (1, FETCH_90,          IEEE4)  'Upwind range within which sources/sinks contributes 90% the measured flux
  Sample (1, FETCH_55,          IEEE4)  'Upwind range within which sources/sinks contributes 55% the measured flux
  Sample (1, FETCH_40,          IEEE4)  'Upwind range within which sources/sinks contributes 40% the measured flux
  Sample (1, UPWND_DIST_INTRST, IEEE4)  'User-entered upwind distance of interest for the average upwind direction in this averaging interval
  Sample (1, FP_DIST_INTRST,    IEEE4)  'Percentage of measured scalar flux from upwind range of interest

  Sample (1, FP_EQUATION,      String)  'Type of footprint equation: Kljun et al or KormannMeixner

  #If (NOT (ONE_FL_TABLE)) Then
EndTable
'*** End of Flux_CSFormat Table ****

'*** BEGINNING OF FLUX_NOTES TABLE *****
DataTable (Flux_Notes, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTV, Min, 0)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&"_Flux_Notes_", 64, -1, 0,DAY_FLUX_CRD, day, 0, 0)
  #EndIf

  '*** Beginning of CSAT sonic head data ***  
  '*** Before coordinate rotation
  Sample (2, UxUy_Cov,  IEEE4)    'UxUy_Cov and UxUz_Cov.
  Sample (1, UyUz_Cov,  IEEE4)
  Sample (3, TsUx_Cov,  IEEE4)    'TsUx_Cov, TsUy_Cov, and TsUz_Cov

  '** After coordinate rotations
  '   Ux is represented by U, Uy by V, Uz by W, and Ts by T_SONIC, if this rule is not applicable, _R is added for the indication of coordinate-rotated variable. 
  Sample (1, USTAR_R,  IEEE4)    'Friction velocity after coordinate rotations.
  Sample (1, U,        IEEE4)  
  Sample (1, U_SIGMA,  IEEE4)
  Sample (1, V,        IEEE4)
  Sample (1, V_SIGMA,  IEEE4)
  Sample (1, W,        IEEE4)
  Sample (1, W_SIGMA,  IEEE4)
  Sample (1, UV_Cov,   IEEE4)
  Sample (1, UW_Cov,   IEEE4)
  Sample (1, VW_Cov,   IEEE4)
  Sample (1, UT_SONIC_Cov, IEEE4)
  Sample (1, VT_SONIC_Cov, IEEE4)
  Sample (1, WT_SONIC_Cov, IEEE4)

  '*** _fc indicates after frequency corrections
  Sample (1, UW_Cov_fc,       IEEE4)
  Sample (1, VW_Cov_fc,       IEEE4)
  Sample (1, WT_SONIC_Cov_fc, IEEE4)

  '** After coordinate rotations, freq corrections, and SND correction as indicated by WT_SONIC, fc, and SND.
  Sample (1, WT_SONIC_Cov_fc_SND,  IEEE4)
  
  '** Summary of diagnosis flags of CSAT
  Totalize (1, n, Long, sonic_disable_f)  'Totalize the number of sonic samples without diagnostic flags
  FieldNames ("sonic_samples") 
  Sample (1, diag_sonic_aggregate, Long)  
  Totalize (1, n, Long, diag_sonic <> -1)
  FieldNames ("no_sonic_head_Tot")
  Totalize (1, n, Long, diag_sonic <> NAN)
  FieldNames ("no_new_sonic_data_Tot")
  Totalize (1, n, Long, sonic_amp_l_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_l_f_Tot")
  Totalize (1, n, Long, sonic_amp_h_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_h_f_Tot")
  Totalize (1, n, Long, sonic_sig_lck_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_sig_lck_f_Tot")
  Totalize (1, n, Long, sonic_del_T_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_del_T_f_Tot")
  Totalize (1, n, Long, sonic_aq_sig_f  IMP (diag_sonic = NAN))
  FieldNames ("sonic_aq_sig_f_Tot")
  Totalize (1, n, Long, sonic_cal_err_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_cal_err_f_Tot")
  '*** End of CSAT3A sonic data ***

  '*** Beginning of IRGA output data ***
  '** Before coordinate rotation
  Sample  (3, UxCO2_Cov, IEEE4)    'UxCO2_Cov, UyCO2_Cov, UzCO2_Cov
  Sample  (3, UxH2O_Cov, IEEE4)    'UxH2O_Cov, UyH2O_Cov, UzH2O_Cov

  '** After coordinate rotations 
  '   Ux is represented by U, Uy by V, and Uz by W.
  Sample (1, UCO2_Cov,   IEEE4)
  Sample (1, VCO2_Cov,   IEEE4)
  Sample (1, WCO2_Cov,   IEEE4)

  Sample (1, UH2O_Cov,   IEEE4)
  Sample (1, VH2O_Cov,   IEEE4)
  Sample (1, WH2O_Cov,   IEEE4)

  '*** _fc indicates after frequency corrections based on coordinate rotated variables   
  Sample (1, WCO2_Cov_fc,  IEEE4)
  Sample (1, WH2O_Cov_fc,  IEEE4)
  Sample (1, CO2_E_WPL_fc, IEEE4)    'CO2 flux, WPL term due to water vapor flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)
  Sample (1, CO2_T_WPL_fc, IEEE4)    'CO2 flux, WPL term due to temperature flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)
  Sample (1, H2O_E_WPL_fc, IEEE4)    'H2O flux, WPL term due to water vapor flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)
  Sample (1, H2O_T_WPL_fc, IEEE4)    'H2O flux, WPL term due to temperature flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)

  '** Summary of diagnosis flags of IRGA
  Totalize (1, n, Long, (irga_disable_f OR CO2_bad_rng_sig_array(MAX_LAG +1)))
  FieldNames ("CO2_samples")
  Totalize (1, n, Long, (irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  FieldNames ("H2O_samples")
  Sample (1, diag_irga_aggregate, Long)

  Totalize (1, n, Long, diag_irga <> -1)
  FieldNames ("no_irga_head_Tot")
  Totalize (1, n, Long, diag_irga <> NAN)
  FieldNames ("no_new_irga_data_Tot")
  Totalize (1, n, Long, irga_bad_data_f       IMP (diag_irga = NAN))
  FieldNames ("irga_bad_data_f_Tot")
  Totalize (1, n, Long, irga_gen_fault_f      IMP (diag_irga = NAN))
  FieldNames ("irga_gen_fault_f_Tot")
  Totalize (1, n, Long, irga_startup_f        IMP (diag_irga = NAN))
  FieldNames ("irga_startup_f_Tot")
  Totalize (1, n, Long, irga_motor_spd_f      IMP (diag_irga = NAN))
  FieldNames ("irga_motor_spd_f_Tot")
  Totalize (1, n, Long, irga_tec_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_tec_tmpr_f_Tot")
  Totalize (1, n, Long, irga_src_pwr_f        IMP (diag_irga = NAN))
  FieldNames ("irga_src_pwr_f_Tot")
  Totalize (1, n, Long, irga_src_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_src_tmpr_f_Tot")
  Totalize (1, n, Long, irga_src_curr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_src_curr_f_Tot")
  Totalize (1, n, Long, irga_off_f            IMP (diag_irga = NAN))
  FieldNames ("irga_off_f_Tot")
  Totalize (1, n, Long, irga_sync_f           IMP (diag_irga = NAN))
  FieldNames ("irga_sync_f_Tot")
  Totalize (1, n, Long, irga_amb_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_amb_tmpr_f_Tot")
  Totalize (1, n, Long, irga_amb_press_f      IMP (diag_irga = NAN))
  FieldNames ("irga_amb_press_f_Tot")
  Totalize (1, n, Long, irga_CO2_I_f          IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_I_f_Tot")
  Totalize (1, n, Long, irga_CO2_Io_f         IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_Io_f_Tot")
  Totalize (1, n, Long, irga_H2O_I_f          IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_I_f_Tot")
  Totalize (1, n, Long, irga_H2O_Io_f         IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_Io_f_Tot")
  Totalize (1, n, Long, irga_CO2_Io_var_f     IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_Io_var_f_Tot")
  Totalize (1, n, Long, irga_H2O_Io_var_f     IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_Io_var_f_Tot")
  Totalize (1, n, Long, irga_CO2_sig_strgth_f IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_sig_strgth_f_Tot")
  Totalize (1, n, Long, irga_H2O_sig_strgth_f IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_sig_strgth_f_Tot")
  Totalize (1, n, Long, irga_cal_err_f        IMP (diag_irga = NAN))
  FieldNames ("irga_cal_err_f_Tot")
  Totalize (1, n, Long, irga_htr_ctrl_off_f   IMP (diag_irga = NAN))
  FieldNames ("irga_htr_ctrl_off_f_Tot")
  '*** End of IRGA output data ***

  #If (SENSOR_FW) Then
  '*** Beginning of FW output data ***
  '** Before coordinate rotation
  Sample (1, UxFW_Cov, IEEE4)
  Sample (1, UyFW_Cov, IEEE4)
  Sample (1, UzFW_Cov, IEEE4)

   '** After coordinate rotations, Ux is represented by U, Uy by V, and Uz by W.
  Sample (1, UFW_Cov, IEEE4)
  Sample (1, VFW_Cov, IEEE4)
  Sample (1, WFW_Cov, IEEE4)

  ' ** _fc indicates after and freq corrections based on coordinate-rotated data  
  Sample (1, WFW_Cov_fc, IEEE4)
  Totalize   (1, n, Long, FW_bad_data_flg)
  FieldNames ("FW_samples")
  '*** End of FW output data ***
  #EndIf
 
  ' *** Variables used for correction ***
  '** Rotation-related variables
  Sample (1, alpha, IEEE4)                   'Pitch angle
  Sample (1, beta,  IEEE4)                   'Roll angle
  Sample (1, gamma, IEEE4)                   'Yaw angle

  '** Stability-related variables
  Sample (1, height_measurement,    IEEE4)   'Measurement height (m)
  Sample (1, height_canopy,         IEEE4)   'Canopy height (m).
  Sample (1, surface_type_text,    String)   'Crop, Grass, Forest, Shrub, Bare Land, Water, or Ice
  Sample (1, displacement_user,     IEEE4)   'Displacement height input by a user as priority for use in this program (0 is fefault and d is auto calculated and is used)
  Sample (1, d,                     IEEE4)   'Displacement height used by program (d = displacement_user if displacement_user <> 0; otherwise, it is auto calculated)
  Sample (1, roughness_user,        IEEE4)   'Roughness length input by a user as priority for use in this program (0 is fefault and z0 is auto calculated and is used)
  Sample (1, z0,                    IEEE4)   'Roughness length used by program z0 = displacement_user if roughness_user <> 0; otherwise, it is auto calculated
  Sample (1, z,                     IEEE4)   'Aerodynamic height
  Sample (1, MO_LENGTH,             IEEE4)   'Monin-Obukhov length
  Sample (1, ZL,                    IEEE4)   'Atmospheric boundary-layer stability.
  Sample (1, iteration_FreqFactor,  IEEE4)   'Iteration number in calculation of freq correction factor for U'W', V'W', and Ts'W'
  Sample (1, latitude,              IEEE4)
  Sample (1, longitude,             IEEE4)
  Sample (1, altitude,              IEEE4)
  Sample (1, UTC_OFST,              Long)
  FieldNames ("UTC_OFFSET")
  
  '** Freq correction related variables
  ' IRGA separation variables
  Sample (2, separation_x_irga,        IEEE4)  'The 12st to 13nd elements of stn_conf_array: separation_x_irga, separation_y_irga
  Sample (1, separation_lat_dist_irga, IEEE4)  'Separation distance in direction normal to wind direction. Used for separation correction
  Sample (1, separation_lag_dist_irga, IEEE4)  'Separation distance along wind direction. Used for lag maximization
  Sample (1, separation_lag_scan_irga, IEEE4)  'Lag in scan number as the wind passes IRGA after passing CSAT. not neccessarily to use integer

  #If (SENSOR_FW) Then
  Sample (3, separation_x_FW,          IEEE4)  'The 17th, 18th, and 19th elements of stn_conf_array: separation_x_FW, separation_y_FW, and FW_diameter
  Sample (1, separation_lat_dist_FW,   IEEE4)  'Separation distance in direction normal to wind direction. Used for separation correction
  Sample (1, separation_lag_dist_FW,   IEEE4)  'Separation distance along wind direction. Used for lag maximization
  Sample (1, separation_lag_scan_FW,   IEEE4)  'Lag in scan number the wind passes FW after pass CSAT. not neccessary to use integer
  Sample (1, time_const_FW,            IEEE4)
  #EndIf
  
  Sample (1, MAX_LAG,  Long)
  FieldNames ("MAX_LAG")
  Sample (1, lag_irga, IEEE4)

  #If (SENSOR_FW) Then
  Sample (1, lag_FW,   IEEE4)
  #EndIf
 
  Sample (1, FreqFactor_UW_VW,     IEEE4)  'Frequency correction factor for WU and WV
  Sample (1, FreqFactor_WT_SONIC,  IEEE4)  'Frequency correction factor for WT_SONIC
  Sample (1, FreqFactor_WCO2_WH2O, IEEE4)  'Frequency correction factor for covariance of CSI open-path vertical wind with h2o and co2

  #If (SENSOR_FW) Then
  Sample (1, FreqFactor_WFW,       IEEE4)  'Frequency correction factor for covariance of CSAT vertical wind with fine thermocouple (FW) Temperature
  #EndIf
  ' *** End of correction related variables ***

  ' *** Output air properties calculated using measurements ***
  Sample (2, amb_rho_d_Avg,        IEEE4)  'Density of dry air (g/m^3) and density of moist air (kg/m^3). Calculated from 107 temperature, H2O, and pressure 
  FieldNames ("amb_rho_d,amb_rho_a")  
  Sample (2, rho_d_Avg,            IEEE4)  'Density of dry air (g/m^3) and density of moist air (kg/m^3). Calculated from sonic temperature, H2O, and pressure  
  FieldNames ("rho_d,rho_a")
  
  #If (SENSOR_T_RH) Then
  '*** Temperature and humidity probe data   
  Sample  (2, rho_d_probe_Avg,     IEEE4)  'Density of dry air (g/m^3) and density of moist air (kg/m^3). Measured from temperature and humidity probe
  FieldNames ("rho_d_probe,rho_a_probe")
  #EndIf

  Sample (1, Cp,             IEEE4)        'Specific heat of moist air at constant pressure, calculated using measurements from IRGA and sonic [J/(kg K)]
  Sample (1, Lv,             IEEE4)        'Latent heat of vaporization [J/g].
  ' *** End of output atmospheric constants ***

  '*** Beginning of other output data ***
  Average(1, panel_tmpr,     IEEE4, FALSE)
  FieldNames ("T_panel")
  Average  (1, batt_volt,    IEEE4, slowsequence_disable_f)
  FieldNames ("batt_volt")
  Totalize (1, n,            Long, slowsequence_disable_f)
  FieldNames ("slowsequence_Tot")
  
  #If (SENSOR_NR01) Then 
  '*** Begining of recording NR01 heater action ***
   Totalize (1, NR01_heater_secs,   IEEE4, (NOT NR01_heater_on_f))
   FieldNames("nr01_heater_secs")
  #EndIf

  #If (SENSOR_CNR4 AND SENSOR_CNF4) Then 
   'Recording CNR4 fan and heater actions ***
  Totalize (1, cnr4_fan_secs,      IEEE4, ((NOT cnr4_fan_on_f) OR (cnr4_fan_freq = 0)))
  FieldNames("cnr4_fan_secs")
  Totalize (1, cnr4_heater_1_secs, IEEE4, (NOT cnr4_heater_1_on_f))
  FieldNames("cnr4_heater_1_secs")
  Totalize (1, cnr4_heater_1_secs, IEEE4, (NOT cnr4_heater_2_on_f))
  FieldNames("cnr4_heater_2_secs")
  #EndIf
  
  #If (SENSOR_SN500) Then 
  '*** Begining of recording SN500 heater actions ***
  Totalize (1, sn500_heater_secs,  IEEE4, (NOT sn500_heater_on_f))
  FieldNames("sn500_heater_secs")
  '*** End of recording SN500 heater actions ***
  #EndIf

  '*** End of other output data ***
  
  #If (SENSOR_CS320) Then
  'Recording CS320 voltage, temperature, and inclination in three axises 
  Average  (5, V_CS320, IEEE4, slowsequence_disable_f)                    'Averages of voltag, temperature, and three directions for CS320. 
  FieldNames ("V_CS320,T_CS320,x_incline,y_incline,z_incline")
  #EndIf 

  ' Recording the calibrations of self-calibrated soil heat flux plate
  #If (SENSOR_HFP01SC) Then
  Sample (1, shf_plate_cal(1), IEEE4)                                     'Calibrations of self-calibrated soil heat flux plate
  FieldNames ("shfp_cal_1_1_1")
  #If (NMBR_HFP > 1) Then
  Sample (1, shf_plate_cal(2), IEEE4)
  FieldNames ("shfp_cal_2_1_1")
  #EndIf
  #If (NMBR_HFP > 2) Then
  Sample (1, shf_plate_cal(3), IEEE4)
  FieldNames ("shfp_cal_3_1_1")
  #EndIf
  #EndIf  

  ' *** Beginning of variables to monitor datalogger performance ***
  Average  (1, process_time, IEEE4, slowsequence_disable_f)
  FieldNames ("process_time")
  Maximum  (1, process_time, IEEE4, slowsequence_disable_f, FALSE)
  FieldNames ("process_time_Max")
  Maximum  (1, buff_depth,   IEEE4, slowsequence_disable_f, FALSE)
  FieldNames ("buff_depth_Max")
  ' *** End of variables to monitor datalogger performance ***

EndTable

'******************************
'*** TIME SERIES DATA TABLE ***
'******************************
DataTable (Time_Series, TRUE, -1)
  DataInterval (0, SCN_INTV, mSec, 0)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&"_Time_Series_", 64, -1, 0, DAY_TSRS_CRD, day, 0, LastFileName_Time_Series)

  '*** Beginning of CSAT time series output ***
  Sample (3, Ux, IEEE4)
  FieldNames ("Ux,Uy,Uz")
  Sample (1, Ts, IEEE4)
  FieldNames ("T_SONIC")
  Sample (1, diag_sonic, Long)
  FieldNames ("diag_sonic")
  '*** End of CSAT time series output ***

  '*** Beginning of IRGA time series output ***
  Sample (1, CO2_density_slow_tmpr, IEEE4)                'Coventional CO2 density 
  FieldNames ("CO2_density")
  Sample (1, CO2_density_fast_tmpr, IEEE4)                'Helbig el al (2016) CO2 density   
  FieldNames ("CO2_density_fast_tmpr")
  Sample (1, H2O_density,           IEEE4)
  FieldNames ("H2O_density")
  Sample (1, diag_irga,             Long)
  FieldNames ("diag_irga")
 
  #If (IRGASON) Then
  Sample (1, Tc,                   IEEE4)
  FieldNames ("T_SONIC_corr")
  #EndIf

  Sample (4, amb_tmpr,IEEE4)
  FieldNames ("TA_1_1_1,PA,CO2_sig_strgth,H2O_sig_strgth")
  '*** End of IRGA time series output ***

  #If (SENSOR_FW) Then
  '*** Beginning of FW time series output ***
  Sample (1, FW, IEEE4)
  FieldNames ("FW")
  '*** End of FW time series output ***
  #EndIf
EndTable

'***********************
'*** DIAGNOSTIC DATA ***
'***********************
DataTable (diagnostic, TRUE, 1)
  Sample (6, sonic_amp_l_f,    Boolean)
  Sample (22, irga_bad_data_f, Boolean)
EndTable
'*** End of output data tables ***


'*******************'
'*** SUBROUTINES ***'
'*******************'

'*** Subroutines for coordinate rotation corrections  ***
' 1. Two Subroutines for Double Rotations
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum with scalar variables

' Definition of double rotation: the 1st AND 2nd rotations in Tanner & Thurtell (1969)
'      a. Counterclockwise about the instrument z-axis for Gamma degrees
'      b. Counterclockwise about the intermediate y-axis for Alpha degrees
'         [Originally clockwise, but in these subroutines following Wilczak et al. (2001) convention of counterclockwise rotation]

'  SUBROUTINE                     MAIN PROGRAM
'  alph                           alpha 
'  bet                            beta
'  gamm                           gamma
'  U_mean, V_mean, W_mean         Ux_Avg, Uy_Avg, Uz_Avg
'  UU_cov, VV_cov, WW_cov         Ux_SIGMA, Uy_SIGMA, Uz_SIGMA
'  UVcov,  UWcov,  VWcov          UxUy_cov, UxUz_cov, UyUz_cov         
'  Umean_R, Vmean_R, Wmean_R      U, V, W
'  UUcov_R, VVcov_R, WWcov_R      U_SIGMA, V_SIGMA, W_SIGMA
'  UVcov_R, UWcov_R, VWcov_R      UV_Cov, UW_Cov, VW_Cov  

'  SU_cov,  SV_cov, SW_cov        SUx_cov,  SUy_cov, SUz_cov   where S is a scalar variable (e.g. CO2, H2O, or T_SONIC)   
'  SUcov_R, SVcov_R, SWcov_R      SU_cov, SV_cov, SW_cov       where S is a scalar variable (e.g. CO2, H2O, or T_SONIC) 
     
' Sub: Rotation12_Momentum (where "12" indicates the 1st and 2nd rotations)
'      Transform the expression of momentum variables in the instrument coordinate system to the natural wind coordinate system.
Sub Rotation12_Momentum(alph, gamm, _
  U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UVcov,   UWcov,   VWcov, _
  Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For efficient calculations, efficient use of memory, and shorter expressions in the following equations, the variables of "UWcov_R" and
  ' "VWcov_R" are used first as intermediate variables before both variables are needed for their own roles.
  UWcov_R =  UU_cov*COS(gamm)*COS(gamm) + VV_cov*SIN(gamm)*SIN(gamm)
  VWcov_R =  UWcov*COS(gamm) + VWcov*SIN(gamm)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = COS(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) - W_mean*SIN(alph)
  Vmean_R = 0
  Wmean_R = SIN(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) + W_mean*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = COS(alph)*COS(alph)*UWcov_R + _
  WW_cov*SIN(alph)*SIN(alph) + UVcov*COS(alph)*COS(alph)*SIN(2*gamm) - _
  SIN(2*alph)*VWcov_R

  VVcov_R = UU_cov*SIN(gamm)*SIN(gamm) + VV_cov*COS(gamm)*COS(gamm) - UVcov*SIN(2*gamm)

  WWcov_R = SIN(alph)*SIN(alph)*UWcov_R  + _
  WW_cov*COS(alph)*COS(alph) + UVcov*SIN(alph)*SIN(alph)*SIN(2*gamm) + _
  SIN(2*alph)*VWcov_R

  ' c. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = -0.5*(UU_cov - VV_cov)*COS(alph)*SIN(2*gamm) + _
  UVcov*COS(alph)*COS(2*gamm) + _
  SIN(alph)*(UWcov*SIN(gamm) - VWcov*COS(gamm))

  UWcov_R =  0.5*SIN(2*alph)*(UWcov_R - WW_cov + UVcov*SIN(2*gamm)) + COS(2*alph)*VWcov_R

  VWcov_R = -SIN(alph)*(0.5*(UU_cov - VV_cov)*SIN(2*gamm)-UVcov*COS(2*gamm))- _
  COS(alph)*(UWcov*SIN(gamm) - VWcov*COS(gamm))

EndSub

' Sub: Rotation12_Scalar_Covariance [where "12" indicates the 1st and 2nd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of variance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in x and y.

Sub Rotation12_Scalar_Covariance(alph, gamm, SU_cov,  SV_cov, SW_cov, SUcov_R, SVcov_R, SWcov_R)

  SUcov_R =  COS(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) - SW_cov*SIN(alph)

  SVcov_R = -SU_cov*SIN(gamm) + SV_cov*COS(gamm)

  SWcov_R =  SIN(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) + SW_cov*COS(alph)

EndSub

' 2. Sub-programs for Planar Fit Rotations [Wilczak et al. (2001)]
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum variable with scalar variables

'    Planar Fit Rotations
'      a. Counterclockwise rotation about the instrument y-axis for Alph degrees  [2nd rotation in Tanner and Thurtell (1969), clockwise]
'      b. Counterclockwise rotation about the intermediate x-axis for Beta degrees [3rd rotation in Tanner and Thurtell (1969)]

' Sub: Rotation23_Momentum [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
Sub Rotation23_Momentum(alph, bet, _
  U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UVcov,   UWcov,   VWcov, _
  Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For efficient calculations, efficient use of memory, and shorter expressions in the following equations, the four variables of Wmean_R, UVcov_R,
  ' UWcov_R, and VWcov_R are used first as intermediate variables for repeated terms before the four variables are needed for their own roles.
  Wmean_R =  V_mean*SIN(bet) - W_mean*COS(bet)
  UVcov_R =  VV_cov*SIN(bet)*SIN(bet) - VWcov*SIN(2*bet) + WW_cov*COS(bet)*COS(bet)
  UWcov_R =  UVcov*SIN(bet) - UWcov*COS(bet)
  VWcov_R =  UVcov*COS(bet) + UWcov*SIN(bet)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = U_mean*COS(alph) +  Wmean_R*SIN(alph)
  Vmean_R = V_mean*COS(bet)  +  W_mean *SIN(bet)
  Wmean_R = U_mean*SIN(alph) -  Wmean_R*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = UU_cov*COS(alph)*COS(alph) + UVcov_R*SIN(alph)*SIN(alph) + UWcov_R*SIN(2*alph)

  VVcov_R = VV_cov*COS(bet)*COS(bet)   + VWcov*SIN(2*bet)            + WW_cov*SIN(bet)*SIN(bet)

  WWcov_R = UU_cov*SIN(alph)*SIN(alph) + UVcov_R*COS(alph)*COS(alph) - UWcov_R*SIN(2*alph)

  ' c. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = SIN(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet)- VWcov*COS(2*bet)) + COS(alph)*VWcov_R

  UWcov_R = 0.5*SIN(2*alph)*(UU_cov - VV_cov*SIN(bet)*SIN(bet) - WW_cov*COS(bet)*COS(bet) + VWcov*SIN(2*bet)) - COS(2*alph)*UWcov_R

  VWcov_R = -COS(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet) - VWcov*COS(2*bet))+SIN(alph)*VWcov_R

EndSub

' Sub: Rotation23_Scalar_Covariance [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of covariance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in z.

Sub Rotation23_Scalar_Covariance(alph, bet, _
  SU_cov,   SV_cov,   SW_cov, _
  SU_cov_R, SV_cov_R, SW_cov_R)

  SU_cov_R =  SU_cov*COS(alph) + SIN(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

  SV_cov_R =  SV_cov*COS(bet)  + SW_cov*SIN(bet)

  SW_cov_R =  SU_cov*SIN(alph) - COS(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

EndSub
'*** End of subroutnes for coordinate rotation corrections  ***


'*** Subroutine to calculate displacement height, roughness length, and aerodynamic height ***

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' S_type                 Surface_type
' d_user                 displacement_user
' z0_user                Roughness_user
' h_canopy               height_canopy
' h_measurement          height_measurement
' displacement           d
' Roughness              z0
' h_aerodynamic          z (sensing height above the ground - d)

Sub  Displacement_roughness_heights (S_type, d_user, z0_user, h_canopy, h_measurement, displacement, roughness, h_aerodynamic)
  ' Calculate displacement height, roughness length, and aerodynamic height
  If ((S_type = CROP) OR (S_type = GRASS)) Then              'Crop and grass

    Select Case h_canopy
    Case Is = 0.0
      displacement = 0.0                                     'Default w/o canopy
      roughness    = 0.01                                    'Default w/o canopy
    Case Is > 0.0
      displacement = 10.0^(0.979*LOG10(h_canopy)-0.154)      'Crop or grass canopy, Eq. 4.5, page 138 in Rosenberg et al. (1983)
      roughness    = 10.0^(0.977*LOG10(h_canopy)-0.883)      'Crop or grass canopy, Eq. 4.4, page 137 in Rosenberg et al. (1983)
    EndSelect

  EndIf

  If ((S_type = FOREST) OR (S_type = SHRUB)) Then            'Forest and Shrub
    displacement = 2.0*h_canopy/3.0                          'Forest canopy, 2/3 rule, page 116, Oke, 1987
    roughness    = 0.06*h_canopy                             'Forest canopy, Jarvis et al. (1976) ans Raupach et al. (1991)
  EndIf

  If ((S_type = BARELAND) OR (S_type = WATER) OR (S_type = ICE)) Then   'Bare land, water, or ice
    displacement = 0.0                                                  'Default w/o canopy
    roughness    = 0.01                                                 'Default w/o canopy
  EndIf

  If (d_user <> 0.0)  Then displacement = d_user             'User preferred has a priority
  If (z0_user <> 0.0) Then roughness    = z0_user            'User preferred has a priority

  h_aerodynamic = h_measurement - displacement
EndSub
'*** End of subroutine to calculate displacement height, roughness length, and aerodynamic height ***


'*** Subroutines for freq correction factors ***

'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' freq_factor            FreqFactor_uw_vw

' *** Freq factor for UW and VW
Sub FreqFactorCSAT_UW_VW_BA_LA (height_aerodynamic, stability, U_total, freq_factor)
  'Variables used inside subrotine
  Dim cosp_uw                       'Cospectrum of U or V with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_LA_uu               'Transfer function of line averaging for UU or VV

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of U or V with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of U or V with W
  Dim weight                        'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J As Long                     'Iteration index. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Define intermediate variables to reduce the repeat computation inside iteration loops
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                       'PATH_LENGTH_CSAT/U_total
  Dim PI2_pu_freq_csat              'Intermediate variable 2*PI*pu_csat*freq
  Dim A_uw, B_uw                    'Parameters in the cospectrum of U with W for stable condition

  If ((stability <> NaN) AND (U_total <> NaN)) Then
    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0

    'Prepare calculations
    zu      = height_aerodynamic/U_total
    pu_csat = PATH_LENGTH_CSAT/U_total

    'Calculate parameters in the cospectrum of U with W for stable condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_uw =  0.124*((1.0 + 7.9*stability)^0.75)       'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1.0 + 7.9*stability)^(-0.825))   'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4   'Similarity functions are defined in a range of stability from -2 to 2 (pgs 17, 28, 41~43, Kaimal & Finnigan 1994). Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_uw =  0.124*((1.0 + 7.9*4.0)^0.75)             'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1.0 + 7.9*4.0)^(-0.825))         'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    ' Calculate correction factor
    For J = 0 To FREQ_BIN
      freq  = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2.0*PI*pu_csat*freq

      '** Cospectrum
      If stability > 0.0 Then
        cosp_uw = freq*zu/(A_uw + B_uw*(freq*zu)^2.1)             'Eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                     'Eq. 26 in Moore (1986), eqs. 17 & 18 in Moncrieff et al (1997), eq. 2.85 in Dijk (2002)
        Case Is < 0.24
          cosp_uw = 20.78*freq*zu/((1.0 + 31.0*freq*zu)^1.575)
        Case Is >= 0.24
          cosp_uw = 12.66*freq*zu/((1.0 + 9.6*freq*zu)^2.4)
        EndSelect
      EndIf

      '** Transfer function
      tran_func_BA    = 1.0 - (SIN (10800*OUTPUT_INTV*freq)/(PI*60*OUTPUT_INTV*freq))^2   'Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Inside SIN(), angle degrees must be used.
      tran_func_LA_uu = (SIN (180.0*pu_csat*freq)/(PI*pu_csat*freq))^2.0                  'Eq. 2.70 in Dijk (2002)

      If PI2_pu_freq_csat >= 0.01 Then
        tran_func_LA_ww = (4.0/PI2_pu_freq_csat)*(1.0 + (PI2_pu_freq_csat + 3.0)/(2.0*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) - 3.0/(2.0*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), pg. 610 in Moncrieff et al. (1997)
      Else
        tran_func_LA_ww = 1.0 'Due to single precision in CR6, this term cannot be calculated when the 2*Pi*dimensionless_freq < 0.01. This is an approximation. The error in the approximation is < 0.001
      EndIf

      ' Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator   += weight*cosp_uw

      freq_factor_denominator += weight*cosp_uw*tran_func_BA*SQR(tran_func_LA_uu*tran_func_LA_ww)

    Next J

    '** correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1.0
  EndIf
EndSub

' *** Frequency factor for wTs

'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
' height_aerodynamic     z
' Stability              ZL
' U_total                WS_rslt
' tran_func_LA_Dijk()    tran_func_LA_data_Dijk()
' freq_factor            FreqFactor_WT_SONIC

Sub FreqFactorCSAT_wTs_BA_LA (height_aerodynamic, stability, U_total, tran_func_LA_Dijk(2,35), freq_factor)
  'Variables used inside subrotine
  Dim cosp_wTs                 'Copectrum of Ts (T_SONIC) with W
  Dim tran_func_BA             'Transfer function of block averaging for covariance
  Dim Tran_func_LA_wTs         'Transfer function of line averaging for WT_SONIC

  Dim freq                     'Cyclic frequency
  Dim freq_factor_numerator    'Numerator to calculate the freq correction factor for covariance of T_SONIC with W
  Dim freq_factor_denominator  'Denominator to calculate the freq correction factor for covariance of T_SONIC with W
  Dim weight                   'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J  As Long               'Index for the outmost iteration. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  Dim jj As Long               'Index for the iteration inside the outmost iteration
  Dim Prev_jj As Long

  'Define following variables for saving computation time by calculating these once outside iteration loops or reduce the repeat computations
  Dim zu                       'z/U_total, ratio of aerodynamic height to total horizontal velocity 
  Dim pu_csat                  'PATH_LENGTH_CSAT/U_total
  Dim PI2_pu_freq_csat         'Intermediate variable 2*PI*pu_csat*freq
  Dim A_wTs, B_wTs             'Parameters in the cospectrum of T_SONIC with W in stable condition

  If ((stability <> NaN) AND (U_total <> NaN)) Then

    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0
    Prev_jj                 = 1

    'Prepare calculations
    zu      = height_aerodynamic/U_total
    pu_csat = PATH_LENGTH_CSAT/U_total

    'Calculate parameters in the cospectrum of W with T_SONIC for stable condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_wTs = 0.2840*((1.0 + 6.4*stability)^0.75)               'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1.0 + 6.4*stability)^(-0.825))           'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4.0  'Similarity functions are defined in a range of stability (ZL) from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994).  Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_wTs = 0.2840*((1.0 + 6.4*4.0)^0.75)                     'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1.0 + 6.4*4.0)^(-0.825))                 'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Start calculations for correction factor
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2.0*PI*pu_csat*freq

      '**Cospectrum
      If (stability > 0.0) Then
        cosp_wTs   = zu*freq/(A_wTs + B_wTs*(zu*freq)^2.1)      'Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                     'Eq.25 in Moore (1986), eqs.15 & 16 in Moncrieff et al. (1997), eq.2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wTs = 12.92*zu*freq/((1 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wTs =  4.378*zu*freq/((1 + 3.8*zu*freq)^2.4)     '4.378 from original source Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '**Transfer function
      tran_func_BA = 1.0 - (SIN (10800*OUTPUT_INTV*freq)/(PI*60*OUTPUT_INTV*freq))^2.0   'Eq.4 in Kaimal et al (1989), Eq.3 in Massman (2000)

      For jj = Prev_jj To 34
        If  (PI2_pu_freq_csat >= tran_func_LA_Dijk(1,jj)) AND  (PI2_pu_freq_csat < tran_func_LA_Dijk(1, jj+1)) Then

          Tran_func_LA_wTs = tran_func_LA_Dijk(2,jj) + (PI2_pu_freq_csat - tran_func_LA_Dijk(1,jj))*(tran_func_LA_Dijk(2,jj+1) _
                             -tran_func_LA_Dijk(2,jj))/(tran_func_LA_Dijk(1,jj+1) - tran_func_LA_Dijk(1,jj))
          Prev_jj = jj

          ExitFor
        EndIf
      Next jj

      If (PI2_pu_freq_csat >= tran_func_LA_Dijk(1, 35)) Then Tran_func_LA_wTs = tran_func_LA_Dijk(2, 35)

      'Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in sequential order.

      freq_factor_numerator   += weight*cosp_wTs
      freq_factor_denominator += weight*cosp_wTs*tran_func_BA*Tran_func_LA_wTs

    Next J

    '**Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1.0
  EndIf
EndSub

' Calculate separation of scalar sensor sensing center to CSAT measurement center
'    1. Separation distance normal to wind direction (effective separation distance)
'    2. Separation distance along with wind direction (effective lag distance)
 
'         Variable Notation  
'  SUBROUTINE             MAIN PROGRAM
'  wnd_dir                WD_SONIC
'  separation_x           separation_x_IRGA or separation_x_FW
'  separation_y           separation_y_IRGA or separation_y_FW
'  separation_lat_dis     separation_lat_dist_IRGA or separation_lat_dist_FW
'  separation_lag_dis     separation_lag_dist_IRGA or separation_lag_dist_FW

Sub Separation_Lag_Lateral_Distances (wnd_dir, separation_x, separation_y, separation_lat_dis, separation_lag_dis)
  separation_lag_dis =  separation_x*COS(wnd_dir) + separation_y*SIN(wnd_dir)
  separation_lat_dis = -separation_x*SIN(wnd_dir) + separation_y*COS(wnd_dir)
EndSub

' *** Freq factor of CSAT + CSI IRGA for WCO2 and WH2O
  
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' separation_lat_dis     separation_lat_dist_IRGA
' Freq_factor            FreqFactor_wco2_wh2o

Sub FreqFactorCSOPEC_wco2_wh2o_BA_LA_SP (height_aerodynamic, stability, U_total, separation_lat_dis, freq_factor)
  'Variables used inside subrotine
  Dim cosp_wco2_wh2o                'Cospectrum of CO2 or H2O with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_LA_co2_h2o          'Transfer function of line averaging for variance of CO2 or H2O
  Dim tran_func_SP_wco2_wh2o        'Transfer function of lateral separation (normal to the wind direction) between CSAT for W and IRGA for CO2 or H2O

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of CO2 or H2O with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of CO2 or H2O with W
  Dim weight                        'Weight factor in the numerical integration of Composite Simpson's Rule
  Dim J As Long                     'Iteration index. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Define following variables for saving computation time by calculating these once outside iteration loops or by reducing repeat computations
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                       'path_length_cast/U_total
  Dim pu_irga                       'path_length_irga/U_total
  Dim du_irga                       'Ratio of effective lateral separation distance (normal to wind) to total wind speed
  Dim PI2_pu_csat                   'Intermediate variable 2*Pi*pu_csat
  Dim PI2_pu_irga                   'Intermediate variable 2*Pi*pu_irga
  Dim PI2_pu_freq_csat              'Intermediate variable 2*Pi*pu_csat*freq
  Dim PI2_pu_freq_irga              'Intermediate variable 2*Pi*pu_irga*freq
  Dim A_wco2_wh2o, B_wco2_wh2o      'Parameters in the cospectrum of scalar (e.g. CO2 or H2O) with W

  If ((stability <> NaN) AND (U_total <> NaN) AND (separation_lat_dis <> NaN)) Then

    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0

    'Prepare calculations
    zu       = height_aerodynamic/U_total
    pu_csat  = PATH_LENGTH_CSAT/U_total
    pu_irga  = PATH_LENGTH_IRGA/U_total
    du_irga  = ABS(separation_lat_dis)/U_total
    PI2_pu_csat  = 2.0*PI*pu_csat
    PI2_pu_irga  = 2.0*PI*pu_irga

    'Calculate parameters in the cospectrum of W with CO2 or H2O for stable condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_wco2_wh2o = 0.2840*((1.0 + 6.4*stability)^0.75)         'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wco2_wh2o = 9.3447*((1.0 + 6.4*stability)^(-0.825))     'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4   'Similarity functions are defined in a range of Stability (ZL) from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994). Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_wco2_wh2o = 0.2840*((1.0 + 6.4*4.0)^0.75)               'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wco2_wh2o = 9.3447*((1.0 + 6.4*4.0)^(-0.825))           'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Start calculations for correction factors
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat  = PI2_pu_csat*freq
      PI2_pu_freq_irga  = PI2_pu_irga*freq

      '**Cospectrum
      If stability > 0.0 Then
        cosp_wco2_wh2o = zu*freq/(A_wco2_wh2o + B_wco2_wh2o*(zu*freq)^2.1)    'Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                                 'Eq. 25 in Moore (1986), eqs. 15 & 16 in Moncrieff et al (1997), eq. 2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wco2_wh2o = 12.92*zu*freq/((1.0 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wco2_wh2o =  4.378*zu*freq/((1.0 + 3.8*zu*freq)^2.4)           '4.378 from original source of Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '** Transfer functions
      tran_func_BA = 1.0 - (SIN (10800.0*OUTPUT_INTV*freq)/(PI*60.0*OUTPUT_INTV*freq))^2.0  'Block averaging: Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Angle degree must be used inside SIN().

      tran_func_SP_wco2_wh2o = EXP(-9.9*(du_irga*freq)^1.5)                                 'Spatial separation: Eq. 4.8 in Foken et al. (2012)

      If PI2_pu_freq_csat >= 0.01 Then                                                      'Line averaging
        tran_func_LA_ww  = (4.0/PI2_pu_freq_csat)*(1.0+ (PI2_pu_freq_csat+3.0)/(2.0*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) -3.0/(2.0*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), page 610 in Moncrieff et al (1997)
      Else
        tran_func_LA_ww  = 1.0       'Due to single precision in CR6, this term cannot be calculated when the 2PI*dimensionless_frequency < 0.01. This is an approximation with an error < 0.001.
      EndIf

      If PI2_pu_freq_irga >= 0.01 Then
        tran_func_LA_co2_h2o = (1.0/PI2_pu_freq_irga)*(3.0 + (PI2_pu_freq_irga + 4.0)/(PI2_pu_freq_irga*EXP(PI2_pu_freq_irga)) -4.0/PI2_pu_freq_irga)      'Eq. 7 in Moore (1986), page 610 in Moncrieff et al (1997)
      Else
        tran_func_LA_co2_h2o  = 1.0   'Due to single precision in CR6, this term cannot be calculated when the normalized frequency < 0.01 Hz. This is an approximation with an error < 0.001
      EndIf

      'Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator    += weight*cosp_wco2_wh2o

      freq_factor_denominator  += weight*cosp_wco2_wh2o*tran_func_BA*SQR(tran_func_LA_ww*tran_func_LA_co2_h2o)*Tran_func_SP_wco2_wh2o

    Next J

    '** Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1.0
  EndIf

EndSub


#If (SENSOR_FW) Then  
'*** Beginning subroutine for time constant of FW sensor ****
 
'         Variable Notation 
'  SUBROUTINE             MAIN PROGRAM
'  FW_D                   FW_diameter
'  FW_temperature         fw_avg
'  U_total                WS_rslt
'  density_moist_air      rho_a_avg

Sub Time_Const_Thermocouple_E(FW_D, FW_temperature, U_total, density_moist_air, time_const)
  Const C_TC_E   =  420.7734       'Specific heat of junction of thermocouple E [J/(kg deg C)]
  Const rho_TC_E =  8825           'Specific gravity (material density) of junction of thermocouple E [kg/m^3]

  Dim K_air                        'Thermal conductivity of air [W/(m deg C)]
  Dim mu_air                       'Viscosity of air [kg/(m s)]
  Dim Re                           'Reynold number (adimensional).
  Dim Nu                           'Nusselt Number (adimensional)
  Dim h_tc                         'Convective heat transfer coefficient [W/(m^2 deg C)]

  K_air  = 2.42508e-2 + 7.038086e-5*FW_temperature     'Table 1 Montgomery (1947)
  mu_air = 1.716800e-5 + 4.982100e-8*FW_temperature    'Table 1 Montgomery (1947)

  Re = (density_moist_air*(0.5*FW_D)*U_total)/mu_air   'Reynold number
  Nu = 2.0 +0.181*Re^0.67                              'Nusselt Number     
  
  h_tc = (K_air*Nu)/(0.5*FW_D)                         'Convective heat transfer coefficient

  time_const = ((0.5*FW_D*rho_TC_E*C_TC_E)/h_tc)       'Time constant
EndSub


' *** Frequency factor of CSAT + FW for WT_FW (T_FW is the temperature measured using fine wire thermocouple of FW05, FW1, FW2, or FW3)  
  
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' separation_lat_dis     separation_lat_dist_FW
' time_const             time_const_FW
' Freq_factor            FreqFactor_wFW

Sub FreqFactorCSATFW_wT_BA_LA_TC_SP (height_aerodynamic, stability, U_total, separation_lat_dis, time_const, freq_factor)
  'Variables used inside subroutine
  Dim cosp_wT                       'Cospectrum of T with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_TC_TT               'Transfer function of time constant for TT
  Dim tran_func_SP_wT               'Transfer function of lateral separation between CSAT3 w and FW T
  Dim A_wT, B_wT                    'Parameters in the cospectrum of air temperature with W in the stable condition

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of T with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of T with W
  Dim weight                        'Weight factor in the numerical integration of Composite Simpson's Rule.
  Dim J As Long                     'Iteration index. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
         
  'Define following variables for saving computation time by calculating these once outside iteration loops or by reducing repeat computation
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim du_FW                         'The ratio of effective lateral separation distance to total wind speed
  Dim PI2_pu_csat                   'Intermediate variable 2*Pi*path_length_csat/U_total
  Dim PI2_pu_freq_csat              'Intermediate variable 2*Pi*(path_length_csat/U_total)*freq

  If ((stability <> NaN) AND (U_total <> NaN) AND (separation_lat_dis <> NaN) AND (time_const <> NaN)) Then
    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0

    'Prepare calculations
    zu          = height_aerodynamic/U_total
    PI2_pu_csat = 2.0*PI*PATH_LENGTH_CSAT/U_total
    du_FW       = ABS(separation_lat_dis)/U_total

    'Calculate the parameters in the cospectrum of air temperature with W for a stable surface-layer condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_wT = 0.2840*((1.0 + 6.4*stability)^0.75)        'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wT = 9.3447*((1.0 + 6.4*stability)^(-0.825))    'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4  'Similarity functions are defined in a range of ZL from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994). Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_wT = 0.2840*((1.0 + 6.4*4.0)^0.75)              'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wT = 9.3447*((1.0 + 6.4*4.0)^(-0.825))          'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Calculate correction factor
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = PI2_pu_csat*freq

      '** Cospectrum
      If (stability > 0.0) Then
        cosp_wT   = zu*freq/(A_wT + B_wT*(zu*freq)^2.1)          'Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                    'Eq. 25 in Moore (1986), eqs. 15 & 16 in Moncrieff et al. (1997), eq. 2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wT = 12.92*zu*freq/((1.0 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wT =  4.378*zu*freq/((1.0 + 3.8*zu*freq)^2.4)       '4.378 from original source of Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '** Transfer function
      tran_func_BA    = 1.0 - (SIN (10800.0*OUTPUT_INTV*freq)/(PI*60.0*OUTPUT_INTV*freq))^2.0     'Block averaging: Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Angle degree must be sued inside SIN().
      tran_func_SP_wT = EXP(-9.9*(du_FW*freq)^1.5)                                                'Spatial separation: Eq. 4.8 in Foken et al. (2012)
      tran_func_TC_TT = 1.0/(1.0 + (2.0*PI*time_const*freq)^2.0)                                  'Time constant: Eq. 5 Horst (1997)

      If (PI2_pu_freq_csat >= 0.01) Then
        tran_func_LA_ww  = (4.0/PI2_pu_freq_csat)*(1.0 + (PI2_pu_freq_csat + 3.0)/(2.0*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) - 3.0/(2.0*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), pg. 610 in Moncrieff et al. (1997)
      Else
        tran_func_LA_ww  = 1.0   'Due to single precision in CR6, this term cannot be calculated when 2PI*dimensionless_frequency < 0.01. This is an approximation with an error < 0.001.
      EndIf

      'Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator   += weight*cosp_wT
      freq_factor_denominator += weight*cosp_wT*tran_func_BA*SQR(tran_func_LA_ww*tran_func_TC_TT) *Tran_func_SP_wT
    Next J
    
    '**Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
    
  Else

    freq_factor = 1.0
  EndIf
EndSub
#EndIf
' *** End of frequency factor of CSAT + FW for WT_FW (T_FW is the temperature measured using fine wire thermocouple of FW05, FW1, FW2, or FW3) 

'*** End of subroutines for freq correction factors ***

'*** Beginning of subroutines for data quality classification ***
'a. Data quality grading for momentum flux using steady state test, integral turbulence characteristics, and horizontal wind orientation relative to the CSAT coordinate system   
'   Foken et al. (2012)
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Planar_fit            Planar_Fit_flg
'  stability             ZL
'  SIGMA_u               U_SIGMA
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  lat                   latitude
'  wnd_dir               WD_SONIC
'  RNS                   RN_UW_VW_cov      RNS: Relative Non-Stationarity
'  QC                    TAU_QC            Quality Classes 1 to 9.

Sub Data_Quality_SSITC_w_WndDir_Momentum (Planar_Fit As Boolean, stability, SIGMA_u, SIGMA_w, U_star, lat, wnd_dir, RNS, QC)
  ' Test on turbulence conditions in development
  Dim    ITC_uw(2)                              'ITC: Integral Turbulence Characteristic. This array is used in instruction MaxSpa to select max
  Alias  ITC_uw(1) = ITCuu                      'ITC for variance of horizontal velocity
  Alias  ITC_uw(2) = ITCww                      'ITC for variance of vertical velocity

  Dim    ITC_uw_max(2)                          'for use of instruction MaxSpa. Hold the max and the index of max location
  Alias  ITC_uw_max(1) = ITC_uu_ww              'ITC for momentum flux
  Alias  ITC_uw_max(2) = ITC_uu_ww_max_seq      'the index of max location

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean                'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean                'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Momentum_1st_Occurrence   'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Momentum_1st_Occurrence   'The lowest possible grade of ITC in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Momentum_1st_Occurrence   'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'for use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature 
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
 
 'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible grade for Relative Non-Stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS < 10.0))

  For J = 1 To 8
    RNS_Momentum_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                    'Omega: earth angular velocity

  Select Case stability
  Case Is <= -0.032
    ITCuu = 4.15*ABS(stability)^0.125                      'Table 4.2 (Foken et al. 2012)
    ITCww = 2.00*ABS(stability)^0.125                      'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0
    ITCuu = 2.7                                            'Table 4.2 (Foken et al. 2012)
    ITCww = 1.3                                            'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0
    ITCuu = 0.44*LN(ABS(Coriolis_parameter)/U_star) + 6.3  'Table 4.3 (Foken et al. 2012)
    ITCww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITCuu = -(SIGMA_u/U_star)/9.1                           'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
    ITCww = -(SIGMA_w/U_star)/9.1                           'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITCuu = ABS((ITCuu - (SIGMA_u/U_star))/ITCuu)              'In fraction
  ITCww = ABS((ITCww - (SIGMA_w/U_star))/ITCww)              'In fraction

  If (NOT Planar_Fit) Then
    'If double rotations, both the max of ITC_uu and ITC_ww is used as ITC_uu_ww.
    MaxSpa(ITC_uu_ww, 2, ITCuu)                               'Max is used for momentum flux related to uw and vw
  Else
    'If planar fit, only ITC_ww is used as ITC_uu_ww.
    ITC_uu_ww = ITCww
  EndIf

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_uu_ww < 0.31)
  ITC_category(2) = (ITC_uu_ww < 0.31)
  ITC_category(3) = ((ITC_uu_ww >= 0.31) AND (ITC_uu_ww < 0.76))
  ITC_category(4) = (ITC_uu_ww < 0.31)
  ITC_category(5) = ((ITC_uu_ww >= 0.31) AND (ITC_uu_ww < 1.01))
  ITC_category(6) = ((ITC_uu_ww >= 0.76) AND (ITC_uu_ww < 1.01))
  ITC_category(7) = ((ITC_uu_ww >= 1.01) AND (ITC_uu_ww < 2.51))
  ITC_category(8) = ((ITC_uu_ww >= 2.51) AND (ITC_uu_ww < 10.00))

  For J = 1 To 8
    ITC_Momentum_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. Wind direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir < 151.0) OR (wnd_dir > 209.0)) Then
    Wnd_Momentum_1st_Occurrence = 1
  ElseIf (((wnd_dir >= 151.0) AND (wnd_dir < 171.0)) OR ((wnd_dir > 189.0) AND (wnd_dir <= 209.0)))
    Wnd_Momentum_1st_Occurrence = 7
  ElseIf ((wnd_dir >= 171.0) AND (wnd_dir <= 189.0))
    Wnd_Momentum_1st_Occurrence = 0
  EndIf

  '1st case
  If ((RNS_Momentum_1st_Occurrence = 0) OR (ITC_Momentum_1st_Occurrence =0) OR (Wnd_Momentum_1st_Occurrence = 0)) Then        'Any in category 9 (0 used for 9 now)
    QC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Momentum_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_uu_ww = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN

EndSub

'b. Data quality grading for momentum flux using steady state test and integral turbulence characteristics.
'   Foken et al. (2004).    
  
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Planar_fit            Planar_Fit_flg
'  stability             ZL
'  SIGMA_u               U_SIGMA
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  lat                   latitude
'  RNS                   RN_UW_VW_cov      RNS: Relative Non-Stationarity
'  TAU_SSITC             TAU_SSITC_TEST    Quality Classes 1 to 9.

Sub Data_Quality_SSITC_wo_WndDir_Momentum (Planar_Fit As Boolean, stability, SIGMA_u, SIGMA_w, U_star, lat, RNS, TAU_SSITC)
  ' Test on turbulence conditions in development
  Dim    ITC_uw(2)                              'ITC: Integral Turbulence Characteristic. This array is used in instruction MaxSpa to select max
  Alias  ITC_uw(1) = ITCu                       'ITC for variance of horizontal velocity
  Alias  ITC_uw(2) = ITCw                       'ITC for variance of vertical velocity

  Dim    ITC_uw_max(2)                          'for use of instruction MaxSpa. Hold the max and the index of max location
  Alias  ITC_uw_max(1) = ITC_u_w                'ITC for momentum flux
  Alias  ITC_uw_max(2) = ITC_u_w_max_seq        'the index of max location

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean                'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean                'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(2)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Momentum_1st_Occur   'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Momentum_1st_Occur   'The lowest possible grade of ITC in the overall grade system
 
  Dim Lowest_Seq_Max(2)                                         'for use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                 'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature 
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
 
 'Reset
  TAU_SSITC = 0

  '1. Relative Non-Stationarity
  'Possible grade for Relative Non-Stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS  < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Momentum_1st_Occur = -J *RNS_category(J)
    If (RNS_Momentum_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                   'Omega: earth angular velocity

  Select Case stability
  Case Is <= -0.032
    ITCu = 4.15*ABS(stability)^0.125                      'Table 9.1 (Foken et al. 2004)
    ITCw = 2.00*ABS(stability)^0.125                      'Table 9.1 (Foken et al. 2004)

  Case Is > -0.032 AND Is <= 0
    ITCu = 2.7                                            'Table 9.1 (Foken et al. 2004)
    ITCw = 1.3                                            'Table 9.1 (Foken et al. 2004)

  Case Is < 0.4 AND Is > 0
    ITCu = 0.44*LN(ABS(Coriolis_parameter)/U_star) + 6.3  'Table 9.2 (Foken et al. 2004)
    ITCw = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 9.2 (Foken et al. 2004)

  Case Is >= 0.4
    ITCu = -(SIGMA_u/U_star)/9.1                          'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
    ITCw = -(SIGMA_w/U_star)/9.1                          'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITCu = ABS((ITCu - (SIGMA_u/U_star))/ITCu)              'In fraction
  ITCw = ABS((ITCw - (SIGMA_w/U_star))/ITCw)              'In fraction

  If (NOT Planar_Fit) Then
    'If double rotations, the max of ITC_u and ITC_w is used as ITC_u_w.
    MaxSpa(ITC_u_w, 2, ITCu)                             'Max is used for momentum flux related to uw and vw
  Else
    'If planar fit, only ITC_w is used as ITC_u_w.
    ITC_u_w = ITCw
  EndIf

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_u_w < 0.31)
  ITC_category(2) = (ITC_u_w < 0.31)
  ITC_category(3) = ((ITC_u_w >= 0.31) AND (ITC_u_w < 0.76))
  ITC_category(4) = (ITC_u_w < 0.31)
  ITC_category(5) = ((ITC_u_w >= 0.31) AND (ITC_u_w < 1.01))
  ITC_category(6) = ((ITC_u_w >= 0.76) AND (ITC_u_w < 1.01))
  ITC_category(7) = ((ITC_u_w >= 1.01) AND (ITC_u_w < 2.51))
  ITC_category(8) = ((ITC_u_w >= 2.51) AND (ITC_u_w < 10.00))

  For J = 1 To 8
    ITC_Momentum_1st_Occur = -J *ITC_category(J)
    If (ITC_Momentum_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '1st case
  If  ((RNS_Momentum_1st_Occur = 0) OR (ITC_Momentum_1st_Occur =0)) Then        'Any in category 9 (0 used for 9 now)
    TAU_SSITC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 2, RNS_Momentum_1st_Occur)
    TAU_SSITC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_u_w = NaN)) AND (TAU_SSITC = 9)) Then  TAU_SSITC = NaN

EndSub

'c. Data quality grading for scalar flux using steady state test, integral turbulence characteristics, and horizontal wind orientation relative to the CSAT coordinate system 
'   Foken et al. (2012) 
   
'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
'  stability             ZL
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  Ts_std                T_SONIC_SIGMA
'  T_star                TSTAR
'  lat                   latitude
'  wnd_dir               WD_SONIC
'  RNS                   RN_WT_SONIC_cov, RN_WCO2_Cov, or RN_WH2O_Cov     Relative Non-Stationarity
'  QC                    Fc_QC, LE_QC, or H_QC                            Quality Classes 1 to 9.

Sub Data_Quality_SSITC_w_WndDir_Scalar (stability, SIGMA_w, U_star, Ts_std, T_star, lat, wnd_dir, RNS, QC)
  ' Test on developed turbulence conditions
  Dim ITC_TsTs                             'ITC (Integral Turbulence Characteristics) for variance of T_SONIC. 
  Dim ITC_wTs                              'ITC for variance of vertical wind speed with T_SONIC. 
  Dim ITC_ww                               'ITC for variance of vertical wind. 

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean           'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean           'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Scalar_1st_Occurrence     'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Scalar_1st_Occurrence     'The lowest possible grade of ITC in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Scalar_1st_Occurrence     'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'For use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
    
  'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS  < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Scalar_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                    'Omega: earth angular velocity

  'Test on developed turbulence conditions for a scalar flux using the integral turbulence characteristic
  Select Case stability
  Case Is <= -0.032
    ITC_ww = 2.00*ABS(stability)^0.125                       'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0.0
    ITC_ww = 1.3                                             'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0.0
    ITC_ww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITC_ww = -(SIGMA_w/U_star)/9.1                          'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect
  
    ITC_ww = ABS((ITC_ww - (SIGMA_w/U_star))/ITC_ww)        'In fraction

  Select Case stability
  Case Is < -1.0
    ITC_TsTs = ABS(stability)^(-1/3)                        'Table 4.2 (Foken et al. 2012)

  Case Is <= -0.062 AND Is >= -1.0
    ITC_TsTs = ABS(stability)^(-0.25)                       'Table 4.2 (Foken et al. 2012)

  Case Is < 0.02 AND Is > -0.062
    ITC_TsTs = 0.5*ABS(stability)^(-0.50)                   'Table 4.2 (Foken et al. 2012)

  Case  Is >= 0.02 AND Is < 1.0
    ITC_TsTs = 1.4*stability^(-0.25)                        'Table 4.2 (Foken et al. 2012)

  Case Is >= 1.0
    ITC_TsTs = -(Ts_std/ABS(T_star))/9.1                    'Classify it into grade 9 when ZL >= 1
  EndSelect

  ITC_TsTs = ABS((ITC_TsTs - Ts_std/ABS(T_star))/ITC_TsTs)  'in fraction

  ITC_wTs = IIF ( (ITC_TsTs > ITC_ww), ITC_TsTs, ITC_ww)

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_wTs < 0.31)
  ITC_category(2) = (ITC_wTs < 0.31)
  ITC_category(3) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 0.76))
  ITC_category(4) = (ITC_wTs < 0.31)
  ITC_category(5) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 1.01))
  ITC_category(6) = ((ITC_wTs >= 0.76) AND (ITC_wTs < 1.01))
  ITC_category(7) = ((ITC_wTs >= 1.01) AND (ITC_wTs < 2.51))
  ITC_category(8) = ((ITC_wTs >= 2.51) AND (ITC_wTs < 10.00))

  For J = 1 To 8
    ITC_Scalar_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. Wind direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir <= 151.0) OR (wnd_dir >= 209.0)) Then
    Wnd_Scalar_1st_Occurrence = 1
  ElseIf (((wnd_dir > 151.0) AND (wnd_dir <= 171.0)) OR ((wnd_dir >= 189.0) AND (wnd_dir < 209.0)))
    Wnd_Scalar_1st_Occurrence = 7
  ElseIf ((wnd_dir > 171.0) AND (wnd_dir < 189.0))
    Wnd_Scalar_1st_Occurrence = 0
  EndIf

  '1st case
  If  ((RNS_Scalar_1st_Occurrence = 0) OR (ITC_Scalar_1st_Occurrence = 0) OR (Wnd_Scalar_1st_Occurrence = 0)) Then        'Any in category 9 (0 used for 9, here)
    QC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Scalar_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_wTs = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN
EndSub


'd. Data quality grading for scalar flux using steady state test and integral turbulence characteristics. 
'   Foken et al. (2004) 
   
'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
'  stability             ZL
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  SIGMA_Ts              T_SONIC_SIGMA
'  T_star                TSTAR
'  lat                   latitude
'  RNS                   RN_WT_SONIC_cov, RN_WCO2_Cov, or RN_WH2O_Cov                Relative Non-Stationarity
'  SSITC                 Fc_SSITC_TEST, LE_SSITC_TEST, ET_SSITC_TEST, or H_SSITC     Quality Classes 1 to 9.

Sub Data_Quality_SSITC_wo_WndDir_Scalar (stability, SIGMA_w, U_star, SIGMA_Ts, T_star, lat, RNS, SSITC)
  ' Test on developed turbulence conditions
  Dim ITC_TsTs                             'ITC (Integral Turbulence Characteristics) for variance of T_SONIC. 
  Dim ITC_wTs                              'ITC for variance of vertical wind speed with T_SONIC. 
  Dim ITC_ww                               'ITC for variance of vertical wind. 

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean           'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean           'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(2)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Scalar_1st_Occur          'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Scalar_1st_Occur          'The lowest possible grade of ITC in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'For use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
    
  'Reset
  SSITC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS  < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Scalar_1st_Occur = -J *RNS_category(J)
    If (RNS_Scalar_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                    'Omega: earth angular velocity

  'Test on developed turbulence conditions for scalar flux using the integral turbulence characteristic
  Select Case stability
  Case Is <= -0.032
    ITC_ww = 2.00*ABS(stability)^0.125                       'Table 9.1 (Foken et al. 2004)

  Case Is > -0.032 AND Is <= 0.0
    ITC_ww = 1.3                                             'Table 9.1 (Foken et al. 2004)

  Case Is < 0.4 AND Is > 0.0
    ITC_ww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1   'Table 9.1 (Foken et al. 2004)

  Case Is >= 0.4
    ITC_ww = -(SIGMA_w/U_star)/9.1                           'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect
  ITC_ww = ABS((ITC_ww - (SIGMA_w/U_star))/ITC_ww)           'In fraction

  Select Case stability
  Case Is < -1.0
    ITC_TsTs = ABS(stability)^(-1.0/3.0)                    'Table 9.1 (Foken et al. 2004)

  Case Is <= -0.062 AND Is >= -1.0
    ITC_TsTs = ABS(stability)^(-0.25)                       'Table 9.1 (Foken et al. 2004)

  Case Is < 0.02 AND Is > -0.062
    ITC_TsTs = 0.5*ABS(stability)^(-0.50)                   'Table 9.1 (Foken et al. 2004)

  Case  Is >= 0.02 AND Is < 1.0
    ITC_TsTs = 1.4*stability^(-0.25)                        'Table 9.1 (Foken et al. 2004)

  Case Is >= 1.0
    ITC_TsTs = -(SIGMA_Ts/ABS(T_star))/9.1                    'Classify it into grade 9 when ZL >= 1
  EndSelect

  ITC_TsTs = ABS((ITC_TsTs - SIGMA_Ts/ABS(T_star))/ITC_TsTs)  'in fraction

  ITC_wTs = IIF ( (ITC_TsTs > ITC_ww), ITC_TsTs, ITC_ww)

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_wTs < 0.31)
  ITC_category(2) = (ITC_wTs < 0.31)
  ITC_category(3) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 0.76))
  ITC_category(4) = (ITC_wTs < 0.31)
  ITC_category(5) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 1.01))
  ITC_category(6) = ((ITC_wTs >= 0.76) AND (ITC_wTs < 1.01))
  ITC_category(7) = ((ITC_wTs >= 1.01) AND (ITC_wTs < 2.51))
  ITC_category(8) = ((ITC_wTs >= 2.51) AND (ITC_wTs < 10.00))

  For J = 1 To 8
    ITC_Scalar_1st_Occur = -J *ITC_category(J)
    If (ITC_Scalar_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '1st case
  If  ((RNS_Scalar_1st_Occur = 0) OR (ITC_Scalar_1st_Occur =0)) Then        'Any in category 9 (0 used for 9, here)
    SSITC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 2, RNS_Scalar_1st_Occur)
    SSITC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_wTs = NaN)) AND (SSITC = 9)) Then  SSITC = NaN
EndSub
'*** End of subroutines for data quality classification ***

'*** Beginning of subroutines for Planetary Boundary-Layer Height ***
' Planetary Boundary-Layer height Kljun et al. (2004 2015)
 
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  h_PBL                  PBLH                          Planetary Boundary-Layer height
'  Obukhov                MO_LENGTH

Sub Planetary_Boundary_Layer_Height(Obukhov, h_PBL)
  
 If (Obukhov <> NaN) Then 
  'Estimate planetary boundary-layer (PBL) height using data in L- and h-columns in Table I in Kljun et al (2004)
  Select Case Obukhov
  Case Is < 0.0
    'h_PBL = 1000 m when Obukhov is -infinity. h_PBL = 1200 m at Obukhov = -650. Assume when Obukhov is <-650, h_PBL will decreases at the same rate
    'as h_PBL decreases when -650 < Obukhov <-30. Thus h_PBL reaches the limit of 1000 m at Obukhov = -1013.3; therefore, h_PBL = 1000 m if Obukhov <= -1013.3.
    If (Obukhov < -1013.3) Then
      h_PBL = 1000.0                                      'Set h_PBL = 1000 m as long as Obukhov < -1013.3 m.
    ElseIf (Obukhov <= -650) Then
      h_PBL = 1200.0 - 200.0*((Obukhov + 650.0)/(-1013.3+650.0))
    ElseIf (Obukhov <= -30.0) Then
      h_PBL = 1500.0 - 300.0*((Obukhov + 30.0)/(-650.0 + 30.0))
    ElseIf (Obukhov <= -5.0) Then
      h_PBL = 2000.0 - 500.0*((Obukhov + 5.0)/(-30.0 + 5.0))
    ElseIf (Obukhov <= 0.0) Then
      h_PBL = 2000.0 + 20.0*(Obukhov + 5.0)                  'Extrapolation to Obukhov --> -0.
    EndIf

  Case Is > 0.0
    'h_PBL = 1000 m when Obukhov is +infinity, and h_PBL = 800 m at Obukhov = 1000. Assume that h_PBL becomes higher with Obukhov at the same rate
    'as in the Obukhov range of 130 to 1000. Thus h_PBL reaches the limit of 1000 m at Obukhov = 1316.4; therefore, h_PBL = 1000 m if Obukhov > 1316.4
    If (Obukhov > 1316.4) Then
      h_PBL = 1000.0                                        'Set h_PBL = 1000 m as long as Obukhov > 1316.4 m.
    ElseIf (Obukhov >= 1000.0) Then
      h_PBL = 800.0 + 200.0*((Obukhov - 1000.0)/(1316.4-1000.0))
    ElseIf (Obukhov >= 130.0) Then
      h_PBL = 250.0 + 550.0*((Obukhov -130.0)/(1000.0 - 130.0))
    ElseIf (Obukhov >= 84.0) Then
      h_PBL = 200.0 + 50.0*((Obukhov - 84.0)/(130.0 -84.0))
    ElseIf (Obukhov > 0.0) Then
      h_PBL = 200.0 - (84.0 - Obukhov)*(50.0/46.0)               'Extrapolation to Obukhov --> +0
    EndIf
  EndSelect

 Else
   
    h_PBL = NaN
    
 EndIf
 
 EndSub
'*** End of subroutines for Planetary Boundary-Layer Height *** 


'*** Beginning of subroutines for footprint characteristics ***
' 1. Footprint of Kljun et al. (2004): Footprint characteristics
 
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  U_star                 USTAR
'  SIGMA_w                  W_SIGMA
'  height_aerodynamic     z
'  Obukhov                MO_LENGTH
'  roughness              z0
'  upwnd_dist             upwnd_dist_intrst             Upwind range of interest (measurement targeted range)
'  FP_win_range           FP_DIST_INTRST                Percentage of measured scalar flux from upwind range of interest
'  x_max                  FETCH_MAX                     Upwind location of source/sink that contributes most to the measured flux
'  FP_90pct_range         FETCH_90                      Upwind range within which the source/sink contributes 90% to the measured flux
'  FP_55pct_range         FETCH_55                      Upwind range within which the source/sink contributes 55% to the measured flux
'  FP_40pct_range         FETCH_40                      Upwind range within which the source/sink contributes 40% to the measured flux

Sub FootprintCharacteristics_Kljun(U_star, SIGMA_w, height_aerodynamic, Obukhov, roughness, upwnd_dist, FP_win_range, x_max, FP_90pct_range, FP_55pct_range,FP_40pct_range)
  '*** Variables used inside subroutine
  'Model parameters
  Dim k1, k2, k3, k4           'Parameters in the model of Kljun et al (2004)
  Dim h_PBL                    'Planetary boundary-layer height

  'Composit variables repeatedly used in iterational computation
  Dim zh_ratio                 'Ratio of aerodynamic height to planetary boundary-layer height (height_aerodynamic/h_PBL)
  Dim suz                      'For repeatedly used variable of ((SIGMA_w/U_star)^0.8)/height_aerodynamic
  Dim k1_suz_zh                'For repeatedly used variable of k1*[((SIGMA_w/U_star)^0.8)*(1-height_aerodynamic/h_PBL)/height_aerodynamic]

  'Working variables
  Dim FP_cumulative            'Cumulative_footprint
  Dim FP_cumulative_prev       'Cumulative_footprint in a previous iteration
  Dim x_inflection_L           'x at the left inflection point of footprint (i.e. x_inflection_L  < x_max) where x is the upwind distance to measurement station
  Dim x_inflection_R           'x at the right inflection point of footprint (i.e. x_inflection_R > x_max) where x is the upwind distance to measurement station
  Dim x_L                      'x at the left boundary of an integration interval where x is the upwind distance to measurement station
  Dim x_R                      'x at the right boundary of an integration interval where x is the upwind distance to measurement station
  Dim integration_interval     'Interval for numerical integration (i.e. x_R - x_L)

  'Variables for use of Boole's Rule for numerical integration
  Dim FP_L                     'footprint at x = x_L
  Dim FP_M1                    'footprint at x = x_L + 0.25*(x_R - x_L)
  Dim FP_M2                    'footprint at x = x_L + 0.50*(x_R - x_L)
  Dim FP_M3                    'footprint at x = x_L + 0.75*(x_R - x_L)
  Dim FP_R                     'footprint at x = x_R

  Dim interval_count           'Used to calculate the number of intervals needed for numerical integration after FP_90pct_range was calculated, but before upwnd_dist is reached
  Dim J As Long                'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Calculate parameters in Kljun et al (2004)].
  k1 = 0.175/(3.418 - LN(roughness))     'pgs. 515 & 516, left top panel in Fig. 7 and eq. (13). Email from Dr. Kljun on Feb 10, 2015
  k2 = 3.68254                           'pgs. 515 & 516, right top panel in Fig. 7 and eq.(14). Calculated from eq.(10) using k1 and k3
  k3 = 4.277*(3.418 - LN(roughness))     'pgs. 515 & 516, left bottom panel in Fig. 7 and eq.(15). Email from Dr. Kljun on Feb 10, 2015
  k4 = 1.685*(3.418 - LN(roughness))     'pgs. 515 & 516, right bottom panel in Fig. 7 and eq.(16). Email from Dr. Kljun on Feb 10, 2015

  If ((U_star <> NaN) AND (SIGMA_w <> NaN) AND (Obukhov <> NaN)) Then 
  'Estimate planetary boundary-layer (PBL) height using data in L- and h-columns in Table I in Kljun et al (2004)
  Select Case Obukhov
  Case Is <= 0.0
    'h_PBL = 1000 m when Obukhov is -infinity. h_PBL = 1200 m at Obukhov = -650. Assume when Obukhov is <-650, h_PBL will decreases at the same rate
    'as h_PBL decreases when -650 < Obukhov <-30. Thus h_PBL reaches the limit of 1000 m at Obukhov = -1013.3; therefore, h_PBL = 1000 m if Obukhov <= -1013.3.
    If (Obukhov < -1013.3) Then
      h_PBL = 1000.0                                        'Set h_PBL = 1000 m as long as Obukhov < -1013.3 m.
    ElseIf (Obukhov <= -650.0) Then
      h_PBL = 1200.0 - 200.0*((Obukhov + 650.0)/(-1013.3 + 650.0))
    ElseIf (Obukhov <= -30.0) Then
      h_PBL = 1500.0 - 300.0*((Obukhov + 30.0)/(-650.0 + 30.0))
    ElseIf (Obukhov <= -5.0) Then
      h_PBL = 2000.0 - 500.0*((Obukhov + 5.0)/(-30.0 + 5.0))
    ElseIf (Obukhov <= 0.0) Then
      h_PBL = 2000.0 + 20.0*(Obukhov + 5.0)                 'Extrapolation to Obukhov --> -0.
    EndIf

  Case Is > 0.0
    'h_PBL = 1000 m when Obukhov is +infinity, and h_PBL = 800 m at Obukhov = 1000. Assume that h_PBL becomes higher with Obukhov at the same rate
    'as in the Obukhov range of 130 to 1000. Thus h_PBL reaches the limit of 1000 m at Obukhov = 1316.4; therefore, h_PBL = 1000 m if Obukhov > 1316.4
    If (Obukhov > 1316.4) Then
      h_PBL = 1000.0                                       'Set h_PBL = 1000 m as long as Obukhov > 1316.4 m.
    ElseIf (Obukhov >= 1000.0) Then
      h_PBL = 800.0 + 200.0*((Obukhov - 1000.0)/(1316.4-1000.0))
    ElseIf (Obukhov >= 130.0) Then
      h_PBL = 250.0 + 550.0*((Obukhov -130.0)/(1000.0 - 130.0))
    ElseIf (Obukhov >= 84.0) Then
      h_PBL = 200.0 + 50.0*((Obukhov - 84.0)/(130.0 -84.0))
    ElseIf (Obukhov > 0.0) Then
      h_PBL = 200.0 - (84.0 - Obukhov)*(50.0/46.0)               'Extrapolation to Obukhov --> +0
    EndIf
  EndSelect

  'Calculate variables repeatedly used inside iteration loops
  zh_ratio  = height_aerodynamic/h_PBL
  suz       = ((SIGMA_w/U_star)^0.8)/height_aerodynamic
  k1_suz_zh = k1*suz*(1-zh_ratio)

  'Upwind location of source/sink that contributes most to the measured flux
  x_max = (k3 - k4)/suz
  x_inflection_L = x_max*(k3*((SQR(k2) - 1)/SQR(k2))-k4)/(k3-k4)     'x at the left inflection point of footprint (i.e. < x_max)
  x_inflection_R = x_max*(k3*((SQR(k2) + 1)/SQR(k2))-k4)/(k3-k4)     'x at the right inflection point of footprint (i.e. > x_max)

  'reset variables
  FP_cumulative  = 0.0
  FP_win_range   = 0.0
  FP_90pct_range = 0.0
  FP_55pct_range = 0.0
  FP_40pct_range = 0.0

  '***Calculate footprint characteristics: FP_win_range, FP_90pct_range, FP_55pct_range, and FP_40pct_range
  ' Use five numerical integration segments to calculate the footprint characteristics
  ' 1st: starting point of footprint defined (-k4/suz) to the left footprint inflection point (x_inflection_L)
  ' 2nd: the left footprint inflection point to the footprint maximum (x_max)
  ' 3rd: the footprint maximum to the right footprint inflection point (x_inflection_R) then further to 
  '      [x_inflection_R + (x_inflection_R - x_max)] or until cumulative footprint reaches 90% whichever is reached first. 
  ' 4th: from x > [x_inflection_R + (x_inflection_R - x_max)] or x at cumulative footprint > 90% and then until the distance of interest is reached
  '      but limited x_max + 200*height_aerodynamic (x_200z).
  ' 5th: If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
  '      or x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic. 

  ' Use a high resolution of integration intervals for the first three segments 
  '     a lower resolution for the 4th and 5th segments, but high precision numerical method of Boole's Rule

    '1st numerical integration segment: Upwind range until x reaches left inflection point

    '*** Starting calculations 
    ' Preparation for use of x_L and x_R inside an iteration
    x_R  = - k4/suz                                                        'Initialization. This value will be used for the starting point of integration
    integration_interval = (x_inflection_L - x_R)/NMBR_INT_INTERV_SEGMENT  'Use x at the left inflection point as a ending boundary of the 1st numerical integration segment
    FP_R = 0                                                               'Pre-calculation

    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = (suz*x_R + k4)/k3                                              'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '2nd numerical integration segment: Upwind range from the left footprint inflection point to the maxmum footprint
    integration_interval = (x_max - x_inflection_L)/NMBR_INT_INTERV_SEGMENT   'For numerical integration, use x at the left inflection point as the starting boundary and x_max as the ending boundary

    'Upwind range within x_max
    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = (suz*x_R + k4)/k3                                             'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '3rd numerical integration segment: Upwind range from the maximum footprint to the right footprint inflection point and then further
    'to [x_inflection_R + (x_inflection_R -x_max)] or until 90% of footprint is found
    integration_interval = (x_inflection_R - x_max)/NMBR_INT_INTERV_SEGMENT  'For numerical integration, use x_max as the starting boundary and x at the right inflection point as the middle boundary

    For J = 1 To 2*NMBR_INT_INTERV_SEGMENT                                    'Using the fine resolution for integration even beyond x_inflection_R to to [x_inflection_R + (x_inflection_R -x_max)]
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of an integration interval
      FP_R = (suz*x_R + k4)/k3                                                'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 90% footprint distance
      If ((FP_cumulative >= 0.9) AND (FP_90pct_range = 0.0)) Then
        FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
        ExitFor
      EndIf
    Next J

    '4th numerical integration segment: x > [x_inflection_R + (x_inflection_R - x_max)] or cumulative footprint > 90%
    'Use lower integration resolution, but more accurate numerical integration method of Boole's Rule
    integration_interval = 4.0*height_aerodynamic

    'If upwind range of 90% footprint is not reached. Continue to calculate
    While ((FP_cumulative < 0.9) AND (x_R - x_max < 200.0*height_aerodynamic))
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      '*** Boole's Rule for numerical integration ***
      'Footprint value at the left boundary of an integration interval
      FP_L = FP_R

      FP_M1 = (suz*(x_L + 0.25*integration_interval) + k4)/k3             'Pre-calculation
      FP_M1 = k1_suz_zh*(FP_M1^k2)*EXP(k2*(1.0 - FP_M1))

      FP_M2 = (suz*(x_L + 0.50*integration_interval) + k4)/k3             'Pre-calculation
      FP_M2 = k1_suz_zh*(FP_M2^k2)*EXP(k2*(1.0 - FP_M2))

      FP_M3 = (suz*(x_L + 0.75*integration_interval) + k4)/k3             'Pre-calculation
      FP_M3 = k1_suz_zh*(FP_M3^k2)*EXP(k2*(1.0 - FP_M3))

      'Footprint value at the right boundary of an integration interval
      FP_R = (suz*x_R + k4)/k3                                            'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

      'Boole's Rule used for an individual interval to cumulate the footprint
      FP_cumulative += integration_interval*(7.0*FP_L + 32.0*FP_M1 + 12.0*FP_M2+ 32.0*FP_M3+ 7.0*FP_R)/90.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

     'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Wend

    'Find the 90% footprint distance
    If ((FP_cumulative >= 0.90) AND (FP_90pct_range = 0.0)) Then
      FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
    EndIf 
    
    'Assign FP_90pct_range as NaN if culmulative footprint can not reach 0.9 within x_max + 200*height_aerodynamic
    If ((FP_cumulative < 0.90) AND (FP_90pct_range = 0.0)) Then
      FP_90pct_range = NaN
    EndIf

    '5th numerical integration segment.
    'If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
    'or x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic. 
    
    If (x_R < upwnd_dist) Then

      ' Control the integration w/in 25 iterations after above integrations
      If ((upwnd_dist - x_R) < (100.0*height_aerodynamic)) Then

        interval_count       = INT((upwnd_dist - x_R)/integration_interval)
        integration_interval = (upwnd_dist - x_R)/interval_count           'Rescale the integration interval

        For J = 1 To interval_count                                        'To Upwnd_dist, the cumulative footprint is enough
          x_L = x_R
          x_R = x_R + integration_interval
          FP_cumulative_prev = FP_cumulative

          '*** Boole's Rule for numerical integration *****
          'Footprint value in the left boundary of integration interval
          FP_L = FP_R

          FP_M1 = (suz*(x_L + 0.25*integration_interval) + k4)/k3          'Pre-calculation
          FP_M1 = k1_suz_zh*(FP_M1^k2)*EXP(k2*(1.0 - FP_M1))

          FP_M2 = (suz*(x_L + 0.50*integration_interval) + k4)/k3          'Pre-calculation
          FP_M2 = k1_suz_zh*(FP_M2^k2)*EXP(k2*(1.0 - FP_M2))

          FP_M3 = (suz*(x_L + 0.75*integration_interval) + k4)/k3          'Pre-calculation
          FP_M3 = k1_suz_zh*(FP_M3^k2)*EXP(k2*(1.0 - FP_M3))

          'Footprint value in the right boundary of integration interval
          FP_R = (suz*x_R + k4)/k3                                         'Pre-calculation
          FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

          'Boole's Rule used for an individual interval to cumulate the footprint
          FP_cumulative += integration_interval*(7.0*FP_L + 32.0*FP_M1 + 12.0*FP_M2+ 32.0*FP_M3+ 7.0*FP_R)/90.0

          'Try to find the 90% footprint distance again
          If ((FP_cumulative >= 0.9) AND (FP_90pct_range = NaN)) Then
            FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
          EndIf
        Next J

        Select Case FP_cumulative
        Case Is < 1.00
          FP_win_range = 100.0*FP_cumulative
        Case Is >= 1.0
          FP_win_range = 99.0
        EndSelect

      Else
        FP_win_range = 99
      EndIf

    EndIf

  Else
    x_max          = NaN
    FP_win_range   = NaN
    FP_90pct_range = NaN
    FP_55pct_range = NaN
    FP_40pct_range = NaN
  EndIf
EndSub

' 2. Footprint of Kormann and Meixner (2001)

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  U_star                 USTAR
'  height_aerodynamic     z
'  Stability              ZL
'  U_total                WS_rslt
'  upwnd_dist             upwnd_dist_intrst            Upwind range of interest (measurement target)
'  FP_win_range           FP_DIST_INTRST               Percentage of measured scalar flux from upwind range of interest
'  x_max                  FETCH_MAX                    Upwind location of source/sink that contributes most to the measured flux
'  FP_90pct_range         FETCH_90                     Upwind range within which the source/sink contributes 90% to the measured flux
'  FP_55pct_range         FETCH_55                     Upwind range within which the source/sink contributes 55% to the measured flux
'  FP_40pct_range         FETCH_40                     Upwind range within which the source/sink contributes 40% to the measured flux

Sub FootprintCharacteristics_KormannMeixner (U_star, height_aerodynamic, stability, U_total, upwnd_dist, FP_win_range, x_max, FP_90pct_range, FP_55pct_range, FP_40pct_range)
  'Parameters in the vertical profiles of horizontal wind and eddy diffusivity
  Dim m_KM                     'Exponent of vertical profile of horizontal wind in footprint of Kormann and Meixner (2001)
  Dim n_KM                     'Exponent of vertical profile of eddy diffusivity in footprint of Kormann and Meixner (2001)
  Dim wnd_const                'Wind constant in the vertical profile of horizontal wind

  'Composite variables
  Dim r_KM                     'Shape factor (r_KM =2 + m_KM - n_KM) in footprint of Kormann and Meixner (2001)
  Dim Phi_c                    'Phi_c is the thermal stratification as a function of stability [see eq 1.32 in Kaimal & Finnigan 1994 and eq. 34 in Kormann and Meixner (2001)].
  Dim kp                       'Constant in power-law profile of the eddy diffusivity [(k*u_star*height_aerodynamic^(1-n_KM))/Phi_c  
  Dim Xi                       'wnd_const/(kp*r_KM^2) 
  Dim Mu                       '(m_KM + 1)/r_KM
  Dim Gamma_Mu                 'Gamma function of Mu
  Dim xgz                      '((Xi^Mu)*(height_aerodynamic^(m_KM +1)))/Gamma_Mu
  Dim xz                       'Xi*height_aerodynamic^r_KM

  'Working variables
  Dim FP_cumulative            'Cumulative_footprint
  Dim FP_cumulative_prev       'Cumulative_footprint in a previous iteration
  Dim x_inflection_L           'x at the left inflection point of footprint (i.e. x_inflection_L < x_max) where x is upwind distance to measurement station
  Dim x_inflection_R           'x at the right inflection point of footprint (i.e. x_inflection_R > x_max) where x is upwind distance to measurement station
  Dim x_L                      'x at the left boundary of integration interval where x is upwind distance to measurement station
  Dim x_R                      'x at the right boundary of integration interval where x is upwind distance to measurement station
  Dim integration_interval     'Interval for numerical integration (i.e. x_R - x_L)

  'Variables for use of Boole's rule
  Dim FP_L                     'footprint at x = x_L
  Dim FP_M1                    'footprint at x = x_L + 0.25*(x_R - x_L)
  Dim FP_M2                    'footprint at x = x_L + 0.50*(x_R - x_L)
  Dim FP_M3                    'footprint at x = x_L + 0.75*(x_R - x_L)
  Dim FP_R                     'footprint at x = x_R

  Dim J As Long                'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'From changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

   If ((U_star <> NaN) AND (stability <> NaN) AND (U_total <> NaN)) Then
     
  'Calculate the exponent of vertical profile of horizontal wind and the exponent of vertical profile of eddy diffusivity
  If (stability > 0) Then
    'Similarity functions are defined in a range of ZL from -2 to 2 (pages 28, 41~43, Kaimal & Finnigan 1994). Extended to +/-4 as shown in Fig 5.23 in Stull (1988)
   Select Case stability 
     Case Is <= 4.0    
       m_KM = (U_star/(k*U_total))*(1.0 + 5.0*stability)         'Exponent of vertical profile of horizontal wind
       n_KM = 1.0/(1.0 + 5.0*stability)                          'Exponent of vertical profile of eddy diffusivity
       Phi_c = 1.0 + 5.0 * stability                             'The thermal stratification as a function of stability
     Case Is > 4.0
       m_KM = (U_star/(k*U_total))*(1.0 + 5.0*4.0)               'Exponent of vertical profile of horizontal wind
       n_KM = 1.0/(1.0 + 5.0*4.0)                                'Exponent of vertical profile of eddy diffusivity
       Phi_c = 1.0 + 5.0 * 4                                     'The thermal stratification as a function of stability
   EndSelect
  Else
    Select Case stability
     Case Is >= -4.0  
       m_KM = (U_star/(k*U_total))/((1.0 - 16.0*stability)^0.25) 'Exponent of vertical profile of horizontal wind
       n_KM = (1.0 - 24.0*stability)/(1.0 - 16.0*stability)      'Exponent of vertical profile of eddy diffusivity
       Phi_c = 1.0 /(SQR(1.0 - 16.0*stability))                  'The thermal stratification as a function of stability
       
     Case Is < -4.0
       m_KM = (U_star/(k*U_total))/((1.0 - 16.0*(-4.0))^0.25)    'Exponent of vertical profile of horizontal wind
       n_KM = (1.0-24.0*(-4.0))/(1.0 - 16.0*(-4.0))              'Exponent of vertical profile of eddy diffusivity
       Phi_c = 1.0 /(SQR(1.0 + 16.0*4))                          'The thermal stratification as a function of stability
    EndSelect
  EndIf

  'Calculate the wind constant in the vertical profile of horizontal wind
  wnd_const = U_total/(height_aerodynamic^m_KM)                 'Wind constant

  'Calculate the composite variables
  r_KM = 2.0 + m_KM - n_KM                                      'Shape factor
  kp = (k * U_star * height_aerodynamic^(1.0 - n_KM))/Phi_c     'From eqs (11) and (32) in Kormann and Meixner (2001)
  Xi = wnd_const/(kp*r_KM*r_KM)
  Mu = (m_KM + 1.0)/r_KM

  Gamma_Mu = SQR(2.0*PI/Mu)*(((Mu + 1.0/(12.0*Mu - 0.1/Mu))/EXP(1.0))^Mu)   'Gamma fuction of Mu [see Nemes (2007)]

  xgz = ((Xi^Mu)*(height_aerodynamic^(m_KM +1.0)))/Gamma_Mu
  xz  = Xi*(height_aerodynamic^r_KM)

  'Turnning and inflection points
  x_max          = xz/(Mu + 1.0)                                            'Upwind location of source/sink that contributes most to the measured flux
  x_inflection_L = x_max*(1.0 - 1.0/SQR(Mu + 2.0))                          'x at the left footprint inflection point
  x_inflection_R = x_max*(1.0 + 1.0/SQR(Mu + 2.0))                          'x at the right footprint inflection point

  'Reset variables
  FP_cumulative  = 0.0
  FP_win_range   = 0.0
  FP_90pct_range = 0.0
  FP_55pct_range = 0.0
  FP_40pct_range = 0.0

  '***Calculate footprint characteristics: FP_win_range, FP_90pct_range, FP_55pct_range, and FP_40pct_range
  ' Use five numerical integration segments to calculate the footprint characteristics
  ' 1st: starting segment from 0 (+ Delt-->0) to the left footprint inflection point (x_inflection_L)
  ' 2nd: the left footprint inflection point to the footprint maximum (x_max)
  ' 3rd: the footprint maximum to the right footprint inflection point (x_inflection_R) then further to 
  '      [x_inflection_R + (x_inflection_R - x_max)] or until cumulative footprint reaches 90% whichever is reached first. 
  ' 4th: from x > [x_inflection_R + (x_inflection_R - x_max)] or x at culumutive footprint > 90% if reached and then until the distance of interest or 
  '      FP_90pct_range is reached if not reached in 3rd segment but limited further x_max + 1000*height_aerodynamic.
  ' 5th: If upwind range of interest or FP_90 has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
  '      or the 4th segment end point to upwind distance of interest, but limited to integration further + 1000*height_aerodynamic.  

  ' Use a high resolution of integration intervals for the first three segments 
  '     a lower resolution for the 4th and 5th segments, but high precision numerical method of Boole's rule

   '1st numerical integration segment: Upwind range within the left inflection point
   'In numerical integration, use x at the left footprint inflection point as the ending boundary of this segment
    integration_interval = x_inflection_L/NMBR_INT_INTERV_SEGMENT  
    x_R  = 0.0                                                        'Reset
    FP_R = 0.0                                                        'Reset
    
    'Upwind range within the left inflection point
    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integral interval
      FP_L = FP_R

      'Footprint value at the right boundary of integral interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1.0))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '2nd numerical integration segment: Upwind range from the left footprint inflection point to the maximum footprint
    'In this segment, use x at the left inflection point as the starting boundary and x_max as the ending boundary
    integration_interval = (x_max - x_inflection_L)/NMBR_INT_INTERV_SEGMENT   

    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integral interval
      FP_L = FP_R

      'Footprint value at the right boundary of integral interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1.0))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '3rd numerical integration segment: Upwind range from the maximum footprint to the right footprint inflection point and further to
    ' [x_inflection_R + (x_inflection_R - x_max)] or to 90% footprint whichever is first reached.
    'In this segment, use x_max as the starting boundary and x at the right inflection point as the boundary of middle interval
    integration_interval = (x_inflection_R - x_max)/NMBR_INT_INTERV_SEGMENT   

    'Upwind range within two times of range from x_max to the right inflection point
    'The fine resolution of integration is used even beyond x_inflection_R to [x_inflection_R + (x_inflection_R - x_max)] or until 90% footprint is reached
    For J = 1 To 2*NMBR_INT_INTERV_SEGMENT   
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 90% footprint distance
      If ((FP_cumulative >= 0.9) AND (FP_90pct_range = 0.0)) Then
        FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
        ExitFor
      EndIf

    Next J

    '4th numerical integration segment: x > [x_inflection_R + (x_inflection_R - x_max)] or cumulative footprint < 90%
    'Use lower integration resolution, but the more accurate numerical integration method of Boole's rule
    integration_interval = 5.0*height_aerodynamic

    'If upwind range of 90% footprint is not reached. Continue, but limited to x_max + 1000*height_aerodynamic
    While ((FP_cumulative < 0.9) AND (x_R - x_max < 1000.0*height_aerodynamic))
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      '*** Boole's rule *****
      'Footprint value at the left boundary of an integration interval
      FP_L = FP_R

      'Footprint value at the 1st, 2nd, and 3rd quarter integration interval
      FP_M1 = xgz*EXP(-xz/(x_L + 0.25*integration_interval))/((x_L + 0.25*integration_interval)^(Mu + 1.0))
      FP_M2 = xgz*EXP(-xz/(x_L + 0.50*integration_interval))/((x_L + 0.50*integration_interval)^(Mu + 1.0))
      FP_M3 = xgz*EXP(-xz/(x_L + 0.75*integration_interval))/((x_L + 0.75*integration_interval)^(Mu + 1.0))

      'Footprint value at the right boundary of an integration interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1.0))

      'The Boole's rule used for an individual interval to cumulate footprint
      FP_cumulative += integration_interval*(7.0*FP_L + 32.0*FP_M1 + 12.0*FP_M2 + 32.0*FP_M3 +7.0*FP_R)/90.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Wend
    
    'Find the 90% footprint distance
    If ((FP_cumulative >= 0.90) AND (FP_90pct_range = 0.0)) Then
        FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
    EndIf


    ' 5th numerical integration segment:
    ' If upwind range of interest or FP_90pct has not been reached, this segment is integrated
    ' from x at FP_90 = 90% (x_90) or the 4th segment end if upwind distance of either interest or FP_90 is not reached.  
    ' but limited to 1000*height_aerodynamic further. 
    
    If ((x_R < upwnd_dist) OR (FP_90pct_range = 0)) Then
       integration_interval = 2*integration_interval

       For J = 1 To  100                               '1000*height_aerodynamic after above integration, the cumulative footprint is enough
          x_L = x_R
          x_R = x_R + integration_interval
          FP_cumulative_prev = FP_cumulative

          '*** Boole's rule *****
          'Footprint value at the left boundary of integration interval
          FP_L = FP_R

          'Footprint value at the right boudary of the 1st, 2nd, and 3rd quarter integration interval
          FP_M1 = xgz*EXP(-xz/(x_L + 0.25*integration_interval))/((x_L + 0.25*integration_interval)^(Mu + 1.0))
          FP_M2 = xgz*EXP(-xz/(x_L + 0.50*integration_interval))/((x_L + 0.50*integration_interval)^(Mu + 1.0))
          FP_M3 = xgz*EXP(-xz/(x_L + 0.75*integration_interval))/((x_L + 0.75*integration_interval)^(Mu + 1.0))

          'Footprint value at the right boundary of integration interval
          FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1.0))

          FP_cumulative += integration_interval*(7.0*FP_L + 32.0*FP_M1 + 12.0*FP_M2 + 32.0*FP_M3 +7.0*FP_R)/90.0
          
         'Find the footprint w/in the range of interest
          If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
             FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
          EndIf
         
          'Try FP_90pct_range again in case that FP_90pct_range is not resolved
          If ((FP_cumulative >= 0.9) AND (FP_90pct_range = 0)) Then
            FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
          EndIf
          
          If ((x_R > upwnd_dist) AND (FP_90pct_range > x_max)) Then
            ExitFor
          EndIf 

        Next J

        If (FP_win_range = 0) Then  
        Select Case FP_cumulative
        Case Is < 1.0
          FP_win_range = 100.0*FP_cumulative
        Case Is >= 1.0
          FP_win_range = 99.0
        EndSelect
        EndIf
        
        'Assign FP_90pct_range as current x_R if culmulative footprint can not reach 0.9 within the integration range above. 
        If ((FP_cumulative < 0.90) AND (FP_90pct_range = 0)) Then
          FP_90pct_range = x_R
        EndIf
    EndIf

  Else
    x_max          = NaN
    FP_win_range   = NaN
    FP_90pct_range = NaN
    FP_55pct_range = NaN
    FP_40pct_range = NaN
  EndIf
EndSub
'*** End of subroutines for footprint characteristics ***
'*** END of SUBROUTINES ***

'********************'
'*** MAIN PROGRAM ***'
'*********************'
BeginProg
 #If (SENSOR_HFP) Then
  'Load calibrations of soil heat flux plate.
  For i = 1 To NMBR_HFP
    Read shf_plate_cal(i)
  Next i
 #EndIf

  ' *** Beginning to store and read station variables in CPU ***
  SemaphoreGet (1)
  stn_conf_array_file = FileOpen ("CPU:stn_conf_array.dat", "rb", 0)        'Open file and check if a file exists.
  stn_conf_array_file_size = FileSize (stn_conf_array_file)
  FileClose (stn_conf_array_file)                                           'Close file after check
  SemaphoreRelease (1)

  If (stn_conf_array_file_size <> 4*NMBR_STN_VAR + 2) Then                  'Station configuration file does not exist.
    ' Set default values of station variables (Default values of 0 are listed for code readability although default value of variable is 0.)
    sonic_azimuth      = 0.0
    latitude           = 41.766           'Latitude of Campbell Scientific Campus, Logan, UT, USA
    hemisphere_NS      = NORTH            '"1" for north and "-1" for south. Campbell Scientific Campus is located in North Hemisphere
    longitude          = -111.855         'Longitude of Campbell Scientific Campus, Logan, UT, USA
    hemisphere_EW      = WEST             '"1" for east and "-1" for west. Campbell Scientific Campus is located in West Hemisphere
    altitude           = 1356.0           'Altitude of Campbell Scientific Campus, Logan, UT, USA
    height_measurement = 2.0
    surface_type       = GRASS
    height_canopy      = 0.5
    displacement_user  = 0.0              '"0" indicates that the user DOES NOT have preferred zero displacement height
    roughness_user     = 0.0              '"0" indicates that the user DOES NOT have preferred roughness length

    Select Case IRGASON
    Case TRUE
      separation_x_irga = 0              'Coordinate x of IRGASON IRGA measurement center in the CSAT coordinate system
      separation_y_irga = 0              'Coordinate y of IRGASON IRGA measurement center in the CSAT coordinate system
    Case FALSE
      separation_x_irga = 0.04066        'Range: 0.04066 to 0.09126 m:  Coordinate x of EC150 IRGA measurement center in the CSAT3A coordinate system
      separation_y_irga = 0.02905        'Range: 0.02905 to 0.03348 m:  Coordinate y of EC150 IRGA measurement center in the CSAT3A coordinate system
    EndSelect

    #If (SENSOR_GPS) Then 
      height_GPS16X = 2.0
    #EndIf 
       
    #If (SENSOR_FW) Then
      
    Select Case IRGASON
    Case TRUE
      separation_x_FW = 0.35787 - 0.3520 'Coordinate x of fine wire thermocouple junction in the CSAT coordinate system (0.35200 is the default length of FW sensor) 
      separation_y_FW = 0.03259          'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
    Case FALSE      
      separation_x_FW = 0.36427 - 0.3520 'Coordinate x of fine wire thermocouple junction in the CSAT coordinate system (0.35200 is the default length of FW sensor) 
      separation_y_FW = -0.02306         'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
    EndSelect
      FW_diameter     = FW3_DIA          'Diameter of fine wire thermocouple
   #EndIf

    #If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
    soil_bulk_density = 1300.0            'Default soil bulk density (kg/m^3)
    Cds               =  870.0            'Default specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
    thick_abv_SHFP    =    0.16           'Default depth of HFP01 or HFP01SC below soil surface (m)
    #EndIf

  Else

    Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:stn_conf_array.dat", 1)         'Read the stored values from the file.

  EndIf
  
  'Error control   
  If ((sonic_azimuth < 0.0) OR (sonic_azimuth > 360.0)) Then 
    sonic_azimuth = 0.0                  'Set back to default value 
  EndIf 
  
  If (ABS(latitude) > 90.0) Then  
     latitude = 41.766                 'Set back to default value 
  EndIf 
  
  If ((hemisphere_NS <> NORTH) AND (hemisphere_NS <> SOUTH)) Then
     hemisphere_NS = NORTH 
  EndIf
  
  If (ABS(longitude) > 180.0) Then  
     longitude = -111.855              'Set back to default value 
  EndIf 
  
  If ((hemisphere_EW <> EAST) AND (hemisphere_EW <> WEST)) Then
     hemisphere_EW = WEST              'Set back to default value 
  EndIf
  
  If ((altitude > 8000.0) OR (altitude < -1000.0)) Then  
     altitude = 1356.0                 'Set back to default value 
  EndIf
  
  If ((height_measurement > 250.0) OR (height_measurement < 0.2)) Then 
     height_measurement = 2.0          'Set back to default value 
  EndIf 
  
  If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND (height_measurement > 100.0)) Then 
    height_measurement = 2.0            'Set back to default value 
  EndIf
  
  If ((surface_type < CROP) OR (surface_type > ICE)) Then 
    surface_type = GRASS                'Set back to default value 
  EndIf 
  
  If ((surface_type = BARELAND) OR (surface_type = WATER) OR (surface_type = ICE)) Then 
    height_canopy = 0.0                 'Set back to default value 
  EndIf 
  
  If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND (height_canopy > 15.0)) Then 
    height_canopy = 0.5                 'Set back to default value 
  EndIf
  
  If ((surface_type = FOREST) OR (height_canopy > 100.0)) Then 
    height_canopy = 0.5                 'Set back to default value 
  EndIf 
    
  If (displacement_user > height_measurement) OR (displacement_user < 0.0) Then  
     displacement_user = 0.0            'Set back to default value 
  EndIf
  
  If (roughness_user > height_measurement) OR (roughness_user < 0.0) Then  
     roughness_user = 0.0               'Set back to default value 
  EndIf
  
  'If IRGASON, but previously CSAT3A+EC150, automatically reset
  If (IRGASON) Then
     separation_x_irga = 0.0                                                     'Coordinate x of IRGASON IRGA measurement center in the CSAT coordinate system
     separation_y_irga = 0.0                                                     'Coordinate y of IRGASON IRGA measurement center in the CSAT coordinate system
   #If (SENSOR_FW) Then
     separation_y_FW = 0.03259                                                   'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
   #EndIf
  EndIf
  
  If (NOT IRGASON) Then
    If ((separation_x_irga < 0.04066) OR (separation_x_irga > 0.09126)) Then 
      separation_x_irga = 0.04066                                              'Range: 0.04066 to 0.09126 m:  Coordinate x of EC150 IRGA measurement center in the CSAT3A coordinate system
    EndIf 
    If ((separation_y_irga < 0.02905) OR (separation_y_irga > 0.03348)) Then 
     separation_y_irga = 0.02905                                               'Range: 0.02905 to 0.03348 m:  Coordinate y of EC150 IRGA measurement center in the CSAT3A coordinate system
    EndIf
    #If (SENSOR_FW) Then
      separation_y_FW = -0.02408                                               'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
    #EndIf
  EndIf
  
  #If (SENSOR_GPS) Then 
  If (height_GPS16X < 0) OR (height_GPS16X > 100.0) Then 
     height_GPS16X = height_measurement
  EndIf
  #EndIf 

  #If (SENSOR_FW) Then
   If (separation_x_FW > 0.1) OR (separation_x_FW < 0.0) Then  
      Select Case IRGASON      
        Case TRUE 
              separation_x_FW = 0.35787 - 0.3520                               'Coordinate x of fine wire thermocouple junction in the CSAT coordinate system (0.35200 is the default length of FW sensor) 
        Case FALSE
              separation_x_FW = 0.36427 - 0.3520
      EndSelect
    EndIf 
  #EndIf

   #If (SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X)) Then
   If  ((soil_bulk_density > 1800.0) OR (soil_bulk_density < 600.0)) Then 
      soil_bulk_density = 1300.0            'Default soil bulk density (kg/m^3)
   EndIf 
   If ((Cds < 500.0) OR (Cds > 1500.0)) Then 
      Cds =  870.0                          'Default specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
   EndIf 
   If ((thick_abv_SHFP > 0.30) OR (thick_abv_SHFP < 0.0)) Then 
      thick_abv_SHFP = 0.16                 'Default depth of HFP01 or HFP01SC below soil surface (m)
   EndIf 
   #EndIf

  '*** Beginning to calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***
  Call Displacement_roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
  '*** End of calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***
      
  For i = 14 To 17
    If  (NOT (stn_conf_array(i) > 0.0)) Then 
      stn_conf_array(i) = 100.0*z                                               'Default value of 100*z for all sectors in different directions
    EndIf 
  Next
  
  z_prev = z
  Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR)   'Keep current values of stn_conf_array() in stn_conf_array_prev() for later reference as previous values
  surface_type_text = surface_type_array(surface_type)
  
  Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:stn_conf_array.dat", 0)         'Store the values to the file. 
  ' *** End to store and read station variables in CPU ***

  ' *** Beginning to store and read Planar Fit angles in CPU ***
  SemaphoreGet (1)  
  planar_fit_angle_conf_array_file      = FileOpen ("CPU:planar_fit_angle_conf_array.dat", "rb", 0)  'Open the file and check if a file exists
  planar_fit_angle_conf_array_file_size = FileSize (planar_fit_angle_conf_array_file)                'Size of the planar fit angle configuration file stored on the CPU.
  FileClose (planar_fit_angle_conf_array_file)                                                       'Close file after check
  SemaphoreRelease (1)

  If (planar_fit_angle_conf_array_file_size <> (4*8 + 2)) Then
    Move (planar_fit_angle_conf_array(1,1), 8 , 0, 1)                                                'Default values of 0 are listed for code reading
    Calfile (planar_fit_angle_conf_array(1, 1), 8, "CPU:planar_fit_angle_conf_array.dat", 0)         'Store the default values to the file
  Else
    Calfile (planar_fit_angle_conf_array(1, 1), 8, "CPU:planar_fit_angle_conf_array.dat", 1)         'Read the values from the file
    For i =1 To 4
      If (planar_fit_angle_conf_array (i, 1) <> 0) OR (planar_fit_angle_conf_array (i, 2) <> 0) Then
        Planar_Fit_flg = TRUE
        ExitFor
      EndIf
    Next i
  EndIf

  Move (planar_fit_angle_conf_array_prev(1,1), 8, planar_fit_angle_conf_array(1,1), 8)                'Keep current values PF planar_fit_angle_conf_array() in planar_fit_angle_prev_array() for later reference as previous values
  ' *** End of storing and reading Planar Fit angles in CPU ***
 
  'Beginning time stamp
  CR6_clock = status.timestamp(4,1)
  TIMESTAMP_START = Left (CR6_clock, 4) & Mid (CR6_clock, 6, 2) & Mid (CR6_clock, 9, 2) & Mid (CR6_clock,12,2)& Mid (CR6_clock,15,2)
  TIMESTAMP_START = Left (TIMESTAMP_START, 12)  
  Erase(TIMESTAMP_END)      

  '*** Check how many days left for data storage in MicroSD ****
  card_bytes_free = Status.CardBytesFree                                   'In bytes.
 
 If  (card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") Then
     card_bytes_free_unassgnd = card_bytes_free   
 
    '*** Campute the DataTable size for time series
    '16 bytes for TimeStamp and record number, 4 bytes for each variable in IEEE4 and Long, and 13 uncoditional variables   
    bytes_rcd_Time_Series = (16 + 4*13 - 4*(IRGASON) - 4*(SENSOR_FW))  
  
    '24 hours/day, 3600 seconds/hour, (1000/SCN_INTV) is scan rate in Hz, "1.1" is factor used in CR6 OS, and "1000" is a unit conversion factor from bytes to KB.         
    bytes_tbl_Time_Series = (DAY_TSRS_CRD*24*3600*(1000/SCN_INTV)*1.1)*bytes_rcd_Time_Series
  
    'Add the bytes in KB for row heading and extra
    If (NOT (IRGASON OR SENSOR_FW)) Then
      bytes_tbl_Time_Series = bytes_tbl_Time_Series + 1024*3.13
  
    ElseIf (IRGASON XOR SENSOR_FW) Then
      bytes_tbl_Time_Series = bytes_tbl_Time_Series + 1024*3.11
    
    ElseIf (IRGASON AND SENSOR_FW) Then   
      bytes_tbl_Time_Series = bytes_tbl_Time_Series + 1024*3.08
    
    EndIf 
    
     day_snc_0101_1990 = SecsSince1990(status.TimeStamp(1,1), 1)/(24*3600)
            
     days_actv_tbl_Time_Series = DAY_TSRS_CRD - (day_snc_0101_1990 MOD DAY_TSRS_CRD) 

     'Pre-set, assume no extra storage in MicroSD
     days_totl_tbl_Time_Series = days_actv_tbl_Time_Series 

    '*** Campute the sizes for records and table in AmeriFluxFormat
    '12 bytes each of two TimeStamp, 9 bytes for each variable in IEEE4 or Long, 41 uncoditial variables
    bytes_rcd_AmeriFluxFormat = 12*2 + 9*41

    #If (SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X))  Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*2              'G and SG
    #EndIf
      
    #If (SENSOR_T_RH) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*3              'TA_3_1_1, RH_3_1_1, and T_DP_3_1_1
    #EndIf
    
    #If (SENSOR_CS616 OR SENSOR_CS65X) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*NMBR_CS6xx     'SWC_1_1_1 and SWC_1_1_2 if NMBR_CS6xx. Measured using CS616 or CS65 
    #EndIf

    #If (SENSOR_TCAV) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*NMBR_TCAV       'TS_1_1_1 and TS_1_1_2 if NMBR_TCAV = 2 
    #EndIf

    #If ((NOT SENSOR_TCAV) AND SENSOR_CS65X)  Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*NMBR_CS6xx     'TS_1_1_1 and TS_1_1_2 if NMBR_CS6xx = 2 
    #EndIf    

    #If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1              'Albedo
    #EndIf
  
    'SENSOR_NR01, _CNR4, _SN500, or _NRLIT
    #If (SENSOR_Rn) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1              'NETRAD
    #EndIf

    #If (SENSOR_CS310) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1              'PPFD_IN
    #EndIf    

    #If (SENSOR_CS301 OR SENSOR_CS320 OR SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1              'SW_IN. for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
    #EndIf

    #If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*3              'SW_OUT, LW_IN, and LW_OUT
    #EndIf
   
    #If (SENSOR_TE525) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1              'Precipitation 
    #EndIf
   
    #If (DVC_CDM_A116) Then 
    #If (SENSOR_SI111) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1              'T_CANOPY  
    #EndIf
    #EndIf

    'Add 5KB row-heading and other extra 
    bytes_tbl_AmeriFluxFormat = DAY_FLUX_CRD*(24*60/OUTPUT_INTV)*1.1*bytes_rcd_AmeriFluxFormat + 1024*5.0 

   '*** Campute the Table size for flux table in CSFormat
   '16 bytes for TimeStamp and record number, 4 bytes for each variable in IEEE4 or Long, 
   '60 uncoditial variables, and 16 bytes for one string variable (i.e. FP_EQUATION)  
    bytes_rcd_flux_CSFormat = 16 + 4*60 + 16*1
  
    #If (SENSOR_FW) Then
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2                  'H_Fw amd H_FW_samples 
    #EndIf
      
    #If (SENSOR_Rn) Then
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1                  'NETRAD,
    #EndIf

    #If (SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X))  Then
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2                  'G and SG
    #EndIf
   
    #If (SENSOR_Rn AND SENSOR_HFP AND SENSOR_CS6XX AND  (SENSOR_TCAV OR SENSOR_CS65X)) Then
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1                  'energy_closure
      #If (SENSOR_TE525) Then  
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1                  'poor_energy_closure_flg
      #EndIf  
    #EndIf

   #If (SENSOR_T_RH) Then
     'Temperature and humidity probe data
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*6                  'TA_3_1_1, RH_3_1_1, T_DP_3_1_1, e_probe_Avg, e_sat_probe_Avg, and H2O_probe_Avg
   #EndIf
   
   #If (SENSOR_FW) Then
   'Fine wire thermocouple data
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2                  'FW and FW_SIGMA
   #EndIf
   
   #If (SENSOR_TE525) Then
  'Rain gauge data
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1                  'P
   #EndIf
  
   #If (SENSOR_NRLIT) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1                  'NETRAD_meas
   #EndIf

   #If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1                  'ALB
   #EndIf

   #If (SENSOR_CS301 OR SENSOR_CS320 OR SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1                  'SW_IN. For use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
   #EndIf
  
   #If (SENSOR_NR01 OR SENSOR_CNR4 OR SENSOR_SN500) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*4                  'SW_OUT, LW_IN, LW_OUT, and T_nr (T_nr_in for SN500)
   #EndIf
   
   #If (SENSOR_SN500) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1                  'T_nr_out
   #EndIf
  
   #If (SENSOR_NR01 OR SENSOR_CNR4) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2                  'R_LW_in_meas and R_LW_out_meas
   #EndIf

   #If (SENSOR_CS310) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1                  'PPFD_IN
   #EndIf
       
   #If (DVC_CDM_A116) Then 
   #If (SENSOR_SI111) Then
   'Surface temperature (i.e. canopy temperature) 
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2                  'T_CANOPY and T_SI111_body  
   #EndIf
   #EndIf

   #If (SENSOR_TCAV) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_TCAV          'TS_1_1_1 and TS_2_1_1 if NMBR_TCAV = 2
   #EndIf

   #If ((NOT SENSOR_TCAV) AND SENSOR_CS65X)  Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_CS6xx         'TS_1_1_1 and TS_2_1_1 if NMBR_CS6xx = 2 
   #EndIf

   #If (SENSOR_CS616) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_CS6xx        'SWC_1_1_1 and SWC_2_1_1 if NMBR_CS6xx = 2 
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_CS6xx        'cs616_wcr_1_1_1 and cs616_wcr_2_1_1 if NMBR_CS6xx = 2 
   #EndIf
    
   #If (SENSOR_CS65X) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_CS6xx         'SWC_1_1_1 and SWC_2_1_1 if NMBR_CS6xx = 2 
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_CS6xx         'cs65x_ec_1_1_1 and cs65x_ec_2_1_1 if NMBR_CS6xx = 2 
   #EndIf

   #If (SENSOR_HFP) Then
   '*** soil heat flux plat data 
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_HFP          'G_plate_1_1_1, G_plate_2_1_1, G_plate_3_1_1, G_plate_4_1_1 depending on NMBR_HFP 
   #EndIf
    
   #If (SENSOR_HFP01SC) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_HFP          'shfp_cal_1_1_1, shfp_cal_2_1_1, shfp_cal_3_1_1, and shfp_cal_1_4_1 depending on NMBR_HFP   
   #EndIf
  
   '*** Campute the Table size for flux note portion 
   '16 bytes for TimeStamp and record number (added according to ONE_FL_TABLE), 4 bytes for each variable in IEEE4 or Long, and 118 uncoditial variables, 
    x_tmp = 4*118

   #If (SENSOR_FW) Then
     x_tmp = x_tmp + 4*8          'UxFW_Cov, UyFW_Cov, UzFW_Cov, UFW_Cov, VFW_Cov, WFW_Cov, WFW_Cov_fc, and FW_samples.
     x_tmp = x_tmp + 4*7          'separation_x_FW, _y_FW, FW_diameter, separation_lat_dist_FW, _lag_dist_FW, _lag_scan_FW, and time_const_FW
     x_tmp = x_tmp + 4*2          'lag_FW and FreqFactor_WFW
   #EndIf
  
   #If (SENSOR_T_RH) Then
     x_tmp = x_tmp + 4*2          'rho_d_probe and rho_a_probe
   #EndIf
   
   #If (SENSOR_NR01) Then                                                'nr01_heater_secs
     x_tmp = x_tmp + 4*1       
   #EndIf 
    
   #If (SENSOR_CNR4 AND SENSOR_CNF4) Then 
     x_tmp = x_tmp + 4*5         'cnr4_fan_secs, cnr4_fan_freq_max, cnr4_fan_freq_min, cnr4_heater_1_secs, and cnr4_heater_2_secs
   #EndIf
   
   #If (SENSOR_SN500) Then 
     x_tmp = x_tmp + 4*1          'sn500_heater_secs
   #EndIf
  
   #If (SENSOR_CS320) Then
     x_tmp = x_tmp + 4*5         'V_CS320, T_CS320, x_incline, y_incline, and z_incline
   #EndIf    

   #If (ONE_FL_TABLE) Then 
    bytes_rcd_flux_CSFormat = (bytes_rcd_flux_CSFormat + x_tmp)
    
    days_actv_tbl_flux_CSFormat = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD) 
    
    'Pre-set, assume no extra storage in MicroSD     
    days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat 
    
    'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat ueses. 
    'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.   
    card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat 
    
  #Else 
 
   '16 bytes added for TimeStemp and record number
    bytes_rcd_flux_notes = 16 + x_tmp
    '24 hours/day, 60 minutes/hour, factor 1.1 used in CR6 OS, and 5 KB for row heading and extra (approximation) 
    bytes_tbl_flux_notes = DAY_FLUX_CRD*(24*60/OUTPUT_INTV)*1.1*bytes_rcd_flux_notes + 1024*5.0 
    
    days_actv_tbl_flux_CSFormat_notes = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD)

    'Pre-set, assume no extra storage in MicroSD
    days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes

   'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat and Flux_notes ues. 
   'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.   
    card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat_notes/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat 

  #EndIf 
   '24 hours/day, 60 minutes/hour, factor 1.1 used in CR6 OS, and 5KB for row heading and extra (approximation) 
    bytes_tbl_flux_CSFormat  = DAY_FLUX_CRD*(24*60/OUTPUT_INTV)*1.1*bytes_rcd_flux_CSFormat + 1025*5.0
    
    card_bytes_free_unassgnd = card_bytes_free - card_bytes_free_assgnd 

  #If (ONE_FL_TABLE) Then 
     While (((days_totl_tbl_flux_CSFormat >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR _
           ((days_totl_tbl_flux_CSFormat < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat))))      

       If (days_totl_tbl_flux_CSFormat >= days_totl_tbl_Time_Series) Then
          card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series 
          days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
          days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series    
       
       Else  
          card_bytes_free_assgnd      = card_bytes_free_assgnd + bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat
          days_more_tbl_flux_CSFormat = days_more_tbl_flux_CSFormat + DAY_FLUX_CRD
          days_totl_tbl_flux_CSFormat = days_more_tbl_flux_CSFormat + days_actv_tbl_flux_CSFormat   
  
      EndIf 
        
        card_bytes_free_unassgnd = card_bytes_free - card_bytes_free_assgnd

    Wend 
    
        If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat) Then 
          card_storage_available_days = days_totl_tbl_flux_CSFormat
        Else
          card_storage_available_days = days_totl_tbl_Time_Series
        EndIf  

  #Else 
    
       While (((days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR _
             ((days_totl_tbl_flux_CSFormat_notes < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat + bytes_tbl_flux_notes))))      

       If (days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) Then
          card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series 
          days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
          days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series   
       
       Else
          card_bytes_free_assgnd            = card_bytes_free_assgnd + bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat + bytes_tbl_flux_notes 
          days_more_tbl_flux_CSFormat_notes = days_more_tbl_flux_CSFormat_notes + DAY_FLUX_CRD
          days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes   

        EndIf 

        card_bytes_free_unassgnd  = card_bytes_free - card_bytes_free_assgnd 

    Wend 

        If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat_notes) Then 
          card_storage_available_days = days_totl_tbl_flux_CSFormat_notes
        Else
          card_storage_available_days = days_totl_tbl_Time_Series
        EndIf  

  #EndIf   

 Else
     days_actv_tbl_Time_Series          = NaN
     days_more_tbl_Time_Series          = NaN
     days_totl_tbl_Time_Series          = NaN
     
   #If (ONE_FL_TABLE) Then 
      days_actv_tbl_flux_CSFormat       = NaN    
      days_more_tbl_flux_CSFormat       = NaN   
      days_totl_tbl_flux_CSFormat       = NaN   
   #Else 
      days_actv_tbl_flux_CSFormat_notes = NaN  
      days_more_tbl_flux_CSFormat_notes = NaN
      days_totl_tbl_flux_CSFormat_notes = NaN
   #EndIf 

      card_storage_available_days       = NaN 
   
 EndIf '(card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.")
        
  '*** End of Checking how many days left for data storage in MicroSD **** 
  
  ' Read date and time from CR6 for soil heat flux and for estimation of days available for data storage in MicroSD 
  RealTime(realtime_array(1))

  #If (SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X)) Then
  ' Variables used to calculate the number of seconds from the beginning of the program to the end of the first averaging interval (time interval offset)
    Offset_intv_delta_ht_storage = ((3600.0*realtime_array(4) + 60*realtime_array(5) + realtime_array(6)) MOD (60.0*OUTPUT_INTV)) 'result in seconds
  #EndIf
    
  'Set the SDM clock speed.
   SDMSpeed (SDM_CLCK_SPD)

  #If (SENSOR_GPS) Then
  'Set 3.3 VDC for pps
   PortPairConfig (GPS16X_PORT, 2)
  #EndIf
  
  #If (SENSOR_TE525 OR (SENSOR_CNR4 AND SENSOR_CNF4)) Then
   'U5 measures CNF4 tachometer and U6 measure rain gauge            
    PortPairConfig (U5, 1, 1) 
  #EndIf
 
  #If (DVC_CDM_A116) Then
    ' Add CDM-A116 as a CPI module 
    CPIAddModule (CDM_MODEL, CDM_SN, CPI_DEVICE, CPI_ADDR_CDM)
  #EndIf   

   
  '*************************** SCAN LOOP  **************************************************
  Scan (SCN_INTV, mSec, SCAN_BUFFER_SIZE, 0)
    
    '*** Beginning of CSI IRGA + CSAT measurements ***
    'GPS16X_COM_PORT
    #If (SENSOR_GPS) Then
      'Get GPS data
      GPS (latitude_GPS_degree, GPS16X_COM_PORT, UTC_OFST*3600, TIME_DIFF_RST_CR6, nmea_sentence(1))
    #EndIf
       
    #If (DVC_CDM_A116) Then
    ' *** Beginning of CDM-A116 panel temperature measurement ***
    CDM_PanelTemp (CDM_MODEL, CPI_ADDR_CDM, panel_tmpr_CDM_A116_1, NMBR_PANEL_TMPR_CDM, CDM_1ST_PANEL_TMPR_CHAN, FIRST_NOTCH_FREQ_MAIN_SCAN)
    '*** End of CDM-A116 panel temperature measurement ***      
    #EndIf  
       
    #If (SENSOR_FW) Then
    '*** Beginning of FW measurements ***
    diag_FW_raw = 0
    CDM_TCDiff (CDM_MODEL, CPI_ADDR_CDM, FW_raw, 1, mV200, FW_ANALOG_INPUT, TypeE, panel_tmpr_CDM_A116_4, TRUE, 500, FIRST_NOTCH_FREQ_MAIN_SCAN, 1, 0)
    If (FW_raw = NaN) OR (FW_raw > 80.0) OR (FW_raw < -50.0) Then diag_FW_raw = -1
    
    CallTable delay_fw                                                    'FW measured temperature and diagnosiscode
    '*** End of FW measurements ***
    #EndIf
    
    '*** Beginning of CSI IRGA + CSAT measurements ***
    If (set_CO2_fast_tmpr_flg AND (CO2_fast_tmpr <> select_CO2_fast_tmpr)) Then 
        CO2_fast_tmpr = select_CO2_fast_tmpr
        CallTable Config_Setting_Notes
        set_CO2_fast_tmpr_flg = FALSE
    EndIf 

    'Get EC100 data
    EC100 (sonic_irga_raw(1), EC100SDM_ADDR, 2)                           '1st to 5th elements: Sonic data and 6th to 13th elements: IRGA, air temperature, and pressure data; 13th element is alternative CO2 output available in EC100 OS 7.01.

    If (CO2_fast_tmpr) Then
      sonic_irga_raw(14) = sonic_irga_raw(6)                               'Backup conventional CO2
      sonic_irga_raw(6)  = sonic_irga_raw(13)                              'If CO2_fast_tmpr = true, calculations using alternative CO2 corrected using air temperature derived from Ts and H2O.
      sonic_irga_raw(13) = sonic_irga_raw(14)                              'Put conventional CO2 to the element that was alternative CO2 
    EndIf

    CallTable delay_3d                                                     'Sonic data: Ux, Uy, Uz, Ts, and diag_sonic 
    CallTable delay_cs                                                     'IRGA data: conventional or alternative CO2, H2O, diag_irga, amb_tmpr, amb_press, CO2_sig_strgth, H2O_sig_strgth, and alternative or conventional CO2
     
    If (sonic_irga_raw(8) = NAN) Then                                      'The EC150 diagnostic word (diag_irga) is sonic_irga_raw(8).
      NaN_cnt += 1
    Else
      If (NaN_cnt > 100*5/SCN_INTV) Then config_ec100_f = TRUE
      NAN_cnt = 0
    EndIf

    If (sonic_irga_raw(8) <> NAN) Then

      If (config_ec100_f AND config_ec100_initial_f) Then
        Call Config (ec100_setting_array(1,1), 10, get_ec100_config_f)     'Get previous configuration of gas analyzer on compile.
        CallTable Config_Setting_Notes                                     'Record previous configuration of gas analyzer on compile. 

        Call Config (config_ec100_array(1, 1),  6, config_ec100_f)         'Configure EC100 with default settings as user preferred.
        Call Config (ec100_setting_array(1,1), 10, get_ec100_config_f)     'Get gas analyzer configuration again.
        CallTable Config_Setting_Notes   
        
        For i = 1 To 10 
             ec100_reset_array(i, 2) = ec100_setting_array(i,2)
        Next i    
             
        press_source   = ec100_setting_array(2, 2)
        heater         = ec100_setting_array(8, 2)
        IRGA_power_off = ec100_setting_array(9, 2)  
        shadow_corr    = ec100_setting_array(10, 2)
        
        config_ec100_initial_f = False     

      ElseIf (config_ec100_f AND (NOT config_ec100_initial_f)) Then 
        Call Config (ec100_reset_array(1, 1),  10, config_ec100_f)         'Configure EC100 with default settings as user preferred.
        Call Config (ec100_setting_array(1,1), 10, get_ec100_config_f)     'Get gas analyzer configuration again.
        CallTable Config_Setting_Notes         
  
      ElseIf (set_press_source_flg) Then
        press_source_array(1, 2) = press_source
        Call Config (press_source_array(1, 1), 1, set_press_source_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_f)     'Get gas analyzer configuration.
        CallTable Config_Setting_Notes                                      'Record EC100 re-configuration 
        press_source            = ec100_setting_array(2, 2)
        ec100_reset_array(2, 2) = ec100_setting_array(2, 2)

      ElseIf (set_zero_flg) Then
        Call Config (zero_array(1,1), 1, set_zero_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_f)     'Get gas analyzer configuration.
        CallTable Config_Setting_Notes                                      'Record EC100 re-configuration 
        
      ElseIf (set_CO2_span_flg) Then
        span_CO2_array(1, 2) = CO2_span_gas
        Call Config (span_CO2_array(1, 1), 2, set_CO2_span_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_f)     'Get gas analyzer configuration.
        CallTable Config_Setting_Notes                                      'Record EC100 re-configuration 
        
        ec100_reset_array (4, 2) = ec100_setting_array(4, 2)                'CO2 zero value 
        ec100_reset_array (5, 2) = ec100_setting_array(5, 2)                'CO2 span value 

      ElseIf (set_H2O_span_flg) Then
        span_H2O_array(1, 2) = T_DP_span_gas
        Call Config (span_H2O_array(1, 1), 2, set_H2O_span_flg)

        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_f)    'Get gas analyzer configuration.
        CallTable Config_Setting_Notes                                     'Record EC100 re-configuration
        
        ec100_reset_array (6, 2) = ec100_setting_array(6, 2)                'H2O zero value 
        ec100_reset_array (7, 2) = ec100_setting_array(7, 2)                'H2O span value  
        
      ElseIf (set_heater_flg) Then
        heater_option_array(1, 2) = heater 
        Call Config (heater_option_array(1, 1), 1, set_heater_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_f)     'Get gas analyzer configuration.
        CallTable Config_Setting_Notes                                      'Record EC100 re-configuration 
        
        heater = ec100_setting_array(8, 2) 
        ec100_reset_array (8, 2) = ec100_setting_array(8, 2)                'Heater setting value        

      ElseIf (set_IRGA_power_flg) Then
        IRGA_power_array(1, 2) = IRGA_power_off
        Call Config (IRGA_power_array(1, 1), 1, set_IRGA_power_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_f)     'Get gas analyzer configuration.
        CallTable Config_Setting_Notes                                      'Record EC100 re-configuration 
        
        IRGA_power_off           = ec100_setting_array(9, 2)
        ec100_reset_array (9, 2) = ec100_setting_array(9, 2)                'Heater setting value  
        
      ElseIf (set_shadow_corr_flg) Then
        shadow_corr_array(1, 2) = shadow_corr
        Call Config (shadow_corr_array(1, 1), 1, set_shadow_corr_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_f)     'Get gas analyzer configuration.
        CallTable Config_Setting_Notes                                      'Record EC100 re-configuration 
        
        shadow_corr               = ec100_setting_array(10, 2) 
        ec100_reset_array (10, 2) = ec100_setting_array(10, 2)              'Heater setting value   
        
      EndIf

    EndIf
    '*** End of CSI IRGA + CSAT measurements ***
      
    'PulsCount Instructions are placed here after all fast sensors finish their measurements because PulseCount() is not allowed in any conditional statements.
    #If (SENSOR_CNR4 AND SENSOR_CNF4) Then   
    '*** Beginning of CNF4 tachometer measurements ***
    PulseCount (cnr4_fan_freq, 1, CNF4_TACHMTR_INPUT, 3, 1, 1, 0)
    '*** End of CNF4 tachometer measurements ***
    #EndIf

    #If (SENSOR_TE525) Then   
    '*** Beginning of precipitation measurements ***
    PulseCount (P, 1, TE525_PULSE_INPUT, 1, 0, TE525_MULT, 0)
    P_cumul_win_interval += P                            'Use to indicate the rain within current interval to judge poor_energy_closure_flg 
    '*** End of precipitation measurements ***
    #EndIf
    
    If (scan_count >= (OFFSET + MAX_LAG)) Then

      '*** Beginning of CSAT sonic head processing ***
      'Load in CSAT sonic head data that has been lagged by EC100_REC_BCK scans
      GetRecord (dly_data_out(1),delay_3d, EC100_REC_BCK)

      Ts = dly_data_out(4)                               'sonic(1): Ts
      Move (Ux, 3, dly_data_out(1), 3)                   'sonic(2), sonic(3), sonic(4) : Ux, Uy, Uz
      diag_sonic = dly_data_out(5)                       'sonic(5): diag_sonic
      
      U_rslt = SQR(Ux*Ux + Uy*Uy + Uz*Uz)

      'Extract the six warning flags from the sonic diagnostic word
      diag_sonic_tmp = IIF ((diag_sonic <> NAN) AND (diag_sonic <> -1), diag_sonic, &h3f)
      diag_sonic_aggregate = diag_sonic_aggregate OR diag_sonic_tmp  
      mask = &h1
      For i = 1 To 6
        diag_bits_sonic(i) = diag_sonic_tmp AND mask
        mask = mask*2
      Next i

      'Turn on the intermediate processing disable flag when any CSAT sonic head warning flag is high.
      sonic_disable_f = (diag_sonic_tmp <> 0)

      Ts_K = Ts + T_0C_K

      'Call Table for 5-minute and 30-minute table
      CallTable comp_cov_3d_5min                                                             'for Steady State Test
      CallTable comp_cov_3d                                                                  'for half-hourly data

      ' The data for Steady State Test (SST)
      If (comp_cov_3d_5min.Output(1, 1)) Then
        GetRecord (Ux_Avg_SST, comp_cov_3d_5min, 1)

        If (NOT Planar_Fit_flg) Then
          'Double coordinate rotations
          gamma_5min = WD_SONIC_SST                                                          'Rotation angle about z-axis
          alpha_5min = -ATN2(Uz_Avg_SST, SQR(Ux_Avg_SST*Ux_Avg_SST + Uy_Avg_SST*Uy_Avg_SST)) 'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

          ' Rotation for momentum variables
          Call Rotation12_Momentum(alpha_5min, gamma_5min, _
          Ux_Avg_SST, Uy_Avg_SST, Uz_Avg_SST, Ux_Var_SST, Uy_Var_SST, Uz_Var_SST, UxUy_Cov_SST, UxUz_Cov_SST, UyUz_Cov_SST, _
          U_SST,      V_SST,      W_SST,      U_Var_SST,  V_Var_SST,  W_Var_SST,  UV_Cov_SST,   UW_Cov_SST,   VW_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W

          'Rotation for the covariance of sonic temperature with velocities
          Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
          TsUx_Cov_SST,     TsUy_Cov_SST,     TsUz_Cov_SST, _
          UT_SONIC_Cov_SST, VT_SONIC_Cov_SST, WT_SONIC_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC 

        Else
          'Planar Fit Rotation
          If (WD_SONIC_SST <= 60)      Then
            alpha_5min = alpha_PF_60_300
            beta_5min  = beta_PF_60_300
          ElseIf (WD_SONIC_SST <= 170) Then
            alpha_5min = alpha_PF_60_170
            beta_5min  = beta_PF_60_170
          ElseIf (WD_SONIC_SST <= 190)  Then
            alpha_5min = alpha_PF_170_190
            beta_5min  = beta_PF_170_190
          ElseIf (WD_SONIC_SST <= 300)  Then
            alpha_5min = alpha_PF_190_300
            beta_5min  = beta_PF_190_300
          Else
            alpha_5min = alpha_PF_60_300
            beta_5min  = beta_PF_60_300
          EndIf

          ' Rotations for momentum variables
          Call Rotation23_Momentum(alpha_5min, beta_5min, _
          Ux_Avg_SST, Uy_Avg_SST, Uz_Avg_SST, Ux_Var_SST, Uy_Var_SST, Uz_Var_SST, UxUy_Cov_SST, UxUz_Cov_SST, UyUz_Cov_SST, _
          U_SST,      V_SST,      W_SST,      U_Var_SST,  V_Var_SST,  W_Var_SST,  UV_Cov_SST,   UW_Cov_SST,   VW_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
                      
          'Rotations for the covariance of sonic temperature with velocities
          Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
          TsUx_Cov_SST,     TsUy_Cov_SST,     TsUz_Cov_SST, _
          UT_SONIC_Cov_SST, VT_SONIC_Cov_SST, WT_SONIC_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC 
        EndIf

          If ((UW_Cov_SST <> NaN) AND (VW_Cov_SST <> NaN) AND (WT_SONIC_Cov_SST <> NaN)) Then
            RN_UW_cov       += UW_Cov_SST
            RN_VW_cov       += VW_Cov_SST
            RN_WT_SONIC_cov += WT_SONIC_Cov_SST

            nmbr_interval_qc_csat += 1
          EndIf

      EndIf

      If (comp_cov_3d.Output(1, 1) AND comp_cov_3d_5min.Output(1, 1))Then
        GetRecord (Ux_Avg, comp_cov_3d, 1)                                'Ux_avg is the 1st element of cov_out_sonic
        T_SONIC       = Ts_Avg                                            'For output in AmeriFlux format 
        Ts_SIGMA      = SQR(Ts_SIGMA)
        T_SONIC_SIGMA = Ts_SIGMA        

        '*** Coordinate rotations ***
        If (NOT Planar_Fit_flg) Then
          'Double coordinate rotations
          gamma = WD_SONIC                                                'Rotation angle about z-axis
          alpha = -ATN2(Uz_Avg, SQR(Ux_Avg*Ux_Avg + Uy_Avg*Uy_Avg))       'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

          ' Rotation for momentum variables
          Call Rotation12_Momentum(alpha, gamma, _
          Ux_Avg, Uy_Avg, Uz_Avg, Ux_SIGMA, Uy_SIGMA, Uz_SIGMA, UxUy_Cov, UxUz_Cov, UyUz_Cov, _
          U,      V,      W,      U_SIGMA,  V_SIGMA,  W_SIGMA,  UV_Cov,   UW_Cov,   VW_Cov)
          'After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W.

          'Rotation for the covariance of sonic temperature with velocities
          Call Rotation12_Scalar_Covariance(alpha, gamma, _
          TsUx_Cov,     TsUy_Cov,     TsUz_Cov, _
          UT_SONIC_Cov, VT_SONIC_Cov, WT_SONIC_Cov)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC
        Else
          'Planar Fit Rotation
          If (WD_SONIC <= 60.0)       Then
            alpha = alpha_PF_60_300
            beta  = beta_PF_60_300
          ElseIf (WD_SONIC <= 170.0)  Then
            alpha = alpha_PF_60_170
            beta  = beta_PF_60_170
          ElseIf (WD_SONIC < 190.0)   Then
            alpha = alpha_PF_170_190
            beta  = beta_PF_170_190
          ElseIf (WD_SONIC < 300.0)   Then
            alpha = alpha_PF_190_300
            beta  = beta_PF_190_300
          Else
            alpha = alpha_PF_60_300
            beta  = beta_PF_60_300
          EndIf

          ' Rotations for momentum variables
          Call Rotation23_Momentum(alpha, beta, _
          Ux_Avg, Uy_Avg, Uz_Avg, Ux_SIGMA, Uy_SIGMA, Uz_SIGMA, UxUy_Cov, UxUz_Cov, UyUz_Cov, _
          U,      V,      W,      U_SIGMA,  V_SIGMA,  W_SIGMA,  UV_Cov,   UW_Cov,   VW_Cov)
          'After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W.
          
         'Rotations for the covariance of sonic temperature with velocities
          Call Rotation23_Scalar_Covariance(alpha, beta, _
          TsUx_Cov,     TsUy_Cov,     TsUz_Cov, _
          UT_SONIC_Cov, VT_SONIC_Cov, WT_SONIC_Cov)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC
        EndIf
        
        'After coordinate rotation, variables ending with _SIGMA are actually variances but later the square root will be taken to give standard deviation.
         Ux_SIGMA = SQR(Ux_SIGMA)
         Uy_SIGMA = SQR(Uy_SIGMA)
         Uz_SIGMA = SQR(Uz_SIGMA)
        
        '*** End of coordinate rotations ***

        'Rotate the CSAT sonic head RHC system so the negative x-axis points north
        WD = (360.0 + sonic_azimuth - WD_SONIC) MOD 360

        'Compute specific turbulence kinetic energy
        TKE = 0.5*(U_SIGMA + V_SIGMA + W_SIGMA)

        'Compute the standard deviation from the variance after rotation
        U_SIGMA = SQR (U_SIGMA)
        V_SIGMA = SQR (V_SIGMA)
        W_SIGMA = SQR (W_SIGMA)

        '*** Freq corrections for UW_Cov, VW_Cov, and WT_SONIC_Cov ***
        'Compute online fluxes after rotations (preliminary).
        USTAR_R =  SQR(SQR((UW_Cov*UW_Cov) + (VW_Cov*VW_Cov)))

        ' Preparation for freq correction to UW_Cov, VW_Cov, and WT_SONIC_cov
        ' Monin-Obukhov length (preliminary)
        MO_LENGTH = -USTAR_R*USTAR_R*USTAR_R*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov)

        ' Atmospheric boundary-layer stability (preliminary)
        ZL = z/MO_LENGTH

        FreqFactor_UW_VW_Prev = 1 - 2*ACCURACY_FREQ_FACTOR
        Call  FreqFactorCSAT_uw_vw_BA_LA(z, ZL, WS_RSLT, FreqFactor_UW_VW)

        UW_Cov_fc = FreqFactor_UW_VW * UW_Cov
        VW_Cov_fc = FreqFactor_UW_VW * VW_Cov
        USTAR = SQR(SQR ((UW_Cov_fc*UW_Cov_fc) + (VW_Cov_fc*VW_Cov_fc)))
        
        FreqFactor_WT_SONIC_Prev = 1 - 2*ACCURACY_FREQ_FACTOR
        Call  FreqFactorCSAT_wTs_BA_LA (z, ZL, WS_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactor_WT_SONIC)

        WT_SONIC_Cov_fc = FreqFactor_WT_SONIC * WT_SONIC_Cov

        ' Recalculate Monin-Obukhov length
        MO_LENGTH = -USTAR*USTAR*USTAR*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov_fc)

        ' Recalculate atmospheric boundary-layer stability
        ZL_prev = ZL
        ZL      = z/MO_LENGTH

        iteration_FreqFactor = 1
        While (((ABS (FreqFactor_UW_VW_Prev -FreqFactor_UW_VW) >= ACCURACY_FREQ_FACTOR) OR _
          (ABS (FreqFactor_WT_SONIC_Prev - FreqFactor_WT_SONIC) >= ACCURACY_FREQ_FACTOR)) AND ((ZL > 0.0) AND (iteration_FreqFactor <= 10)))

          ZL_prev                  = ZL
          FreqFactor_UW_VW_Prev    = FreqFactor_UW_VW
          FreqFactor_WT_SONIC_Prev = FreqFactor_WT_SONIC

          Call  FreqFactorCSAT_uw_vw_BA_LA (z, ZL, WS_RSLT, FreqFactor_UW_VW)
          UW_Cov_fc = FreqFactor_UW_VW * UW_Cov
          VW_Cov_fc = FreqFactor_UW_VW * VW_Cov
          USTAR = SQR(SQR (UW_Cov_fc*UW_Cov_fc + VW_Cov_fc*VW_Cov_fc))

          Call  FreqFactorCSAT_wTs_BA_LA (z, ZL, WS_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactor_WT_SONIC)
          WT_SONIC_Cov_fc = FreqFactor_WT_SONIC * WT_SONIC_Cov

          ' Monin-Obukhov length
          MO_LENGTH = -USTAR*USTAR*USTAR*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov_fc)

          ' Atmospheric boundary-layer stability
          ZL = z/MO_LENGTH

          iteration_FreqFactor += 1
        Wend
        '*** End of freq corrections for UW_Cov, VW_Cov, and wT_SONIC_cov ***

        '*** Beginning of data quality classification for momentum flux ***
        'Calculate the measures of relative non-stationarity (Steady State Test)
        RN_UW_VW_cov = ABS(((RN_UW_cov + RN_VW_cov)/nmbr_interval_qc_csat - UW_Cov - VW_Cov)/(UW_Cov + VW_Cov))  'in fraction
        RN_UW_cov = 0
        RN_VW_cov = 0
        
        Call Data_Quality_SSITC_w_WndDir_Momentum  (Planar_Fit_flg, ZL, U_SIGMA, W_SIGMA, USTAR, latitude, WD_SONIC, RN_UW_VW_cov, TAU_QC)
        Call Data_Quality_SSITC_wo_WndDir_Momentum (Planar_Fit_flg, ZL, U_SIGMA, W_SIGMA, USTAR, latitude,           RN_UW_VW_cov, TAU_SSITC_TEST)
        '*** End of data quality classification for momentum flux ***

        '*** Footprint characteristics of measured fluxes ***
        'Update roughness length when a user does not specify z0 and wind is sufficiently strong during a neutral condition
        If ((ABS(ZL) < 0.02) AND (roughness_user = 0) AND (WS_RSLT > 3.0) AND (TAU_QC <= 6.0)) Then z0 = z*EXP(-k*WS_RSLT/USTAR)

        'Determining upwind distance of interest
        If (WD_SONIC <= 60.0) Then
          UPWND_DIST_INTRST = dist_intrst_60_300
        ElseIf (WD_SONIC <= 170.0) Then
          UPWND_DIST_INTRST = dist_intrst_60_170
        ElseIf (WD_SONIC < 190.0)  Then
          UPWND_DIST_INTRST = dist_intrst_170_190
        ElseIf (WD_SONIC < 300.0)  Then
          UPWND_DIST_INTRST = dist_intrst_190_300
        Else
          UPWND_DIST_INTRST = dist_intrst_60_300
        EndIf
        
        'Calculate planetary boundary layer height
         Call Planetary_Boundary_Layer_Height(MO_LENGTH, PBLH)

        'Footprint selection
        If ((ZL >= -200.0) AND (ZL <= 1.0) AND (USTAR >= 0.2) AND (z >= 1.0)) Then                'See section 6 on page 518 (Kljun et al. 2004) 
          'Kljun et al (2004)
          FP_EQUATION = "Kljun et al"
          'Calculate footprint characteristics
          Call FootprintCharacteristics_Kljun(USTAR, W_SIGMA, z, MO_LENGTH, z0, UPWND_DIST_INTRST, FP_DIST_INTRST, FETCH_MAX, FETCH_90, FETCH_55, FETCH_40)
        Else
          'Kormann and Meixner (2001)
          FP_EQUATION = "KormannMeixner"
          'Calculate footprint characteristics
          Call FootprintCharacteristics_KormannMeixner(USTAR, z, ZL, WS_RSLT, UPWND_DIST_INTRST, FP_DIST_INTRST, FETCH_MAX, FETCH_90, FETCH_55, FETCH_40)
        EndIf
        '*** End of footprint characteristics of measured fluxes ***
      EndIf
      '*** End of CSAT sonic head processing ***

      '*** Beginning of IRGA processing ***
      'Load in the IRGA data that has been lagged by EC100_REC_BCK scans.
      mask = &h1
      For i = MAX_LAG To - MAX_LAG Step -1
        array_index = MAX_LAG + 1 - i                              'Convert i = MAX_LAG, ..., 1, 0, -1, ..., MAX_LAG to array_index = 1, 2, 3,..., 2*MAX_LAG +1

        GetRecord (dly_data_out(1), delay_cs, (EC100_REC_BCK + i))
        If (i = 0) Then 
            Move (CO2_density, 7, dly_data_out(1), 7)              'CO2_density, H2O_density, diag_irga, amb_tmpr, amb_press, CO2_sig_strgth, and H2O_sig_strgth
     
           Select Case CO2_fast_tmpr 
             Case True 
               CO2_density_fast_tmpr = CO2_density
               CO2_density_slow_tmpr = dly_data_out(8)
               
             Case False  
               CO2_density_fast_tmpr = dly_data_out(8)
               CO2_density_slow_tmpr = CO2_density
            EndSelect 
        EndIf
        

        'Extract the diagnostic word from each record of lagged data, used to exclude data from covariance calculation in Tables: comp_cov_CO2, comp_cov_H2O, and comp_cov_cs_5min.
        diag_irga_tmp = IIF ((dly_data_out(3) <> NAN) AND (dly_data_out(3) <> -1),dly_data_out(3), &h3fffff)
        irga_bad_data_flg_array(array_index) = mask AND diag_irga_tmp
        
        If (NOT sonic_disable_f) AND (NOT irga_bad_data_flg_array(array_index)) Then
          T_tmp= (2*Ts_K*dly_data_out(5))/(dly_data_out(5) + SQR(dly_data_out(5)*(dly_data_out(5) +1.28*Rv*dly_data_out(2)*Ts_K))) 'See "An approach of total differental to derivation for the correction equation of air temperature flux from sonic temperature flux", equation 28, v2 (Aug 3, 2015) by Zhou et al.(unpublished)
        
        ElseIf (irga_bad_data_flg_array(array_index) AND (NOT (diag_irga_tmp AND &H400)))    '&H400 for amb_temp flag 
          T_tmp = dly_data_out(4) + T_0C_K
               
        ElseIf (irga_bad_data_flg_array(array_index) AND (diag_irga_tmp AND &H400))          '&H400 for amb_temp flag 
          T_tmp = NaN
        ElseIf (sonic_disable_f) AND (NOT irga_bad_data_flg_array(array_index))
          T_tmp = dly_data_out(4) + T_0C_K
        
        EndIf          
         
       'Compute the molar number of dry air in m^3 
        divisor = (dly_data_out(5)/(R*T_tmp))-(dly_data_out(2)/18.01528)

        'Load the arrays that hold the input data for the covariance instructions.
        Move (cov_array_CO2(array_index, 1), 1, dly_data_out(1),1)                           'CO2_density in mg m-3
        Move (cov_array_CO2(array_index, 2), 3, Ux, 3)
        CO2_bad_rng_sig_array (array_index) = ((dly_data_out(6) < CO2_SIG_STRGTH_THRESHOLD) OR (dly_data_out(1) <0) OR (dly_data_out(1) > CO2_RNG_TOP_LIMIT))
        cov_array_CO2(array_index, 5)       = dly_data_out(1)/(0.04401*divisor)              'CO2 in umol mol-1 (See http://www.carbontracker.eu/glossary.html) 

        Move (cov_array_H2O(array_index, 1), 1, dly_data_out(2),1)                           'H2O_density in g m-3  
        Move (cov_array_H2O(array_index, 2), 3, Ux, 3)
        H2O_bad_rng_sig_array (array_index) = ((dly_data_out(7) < H2O_SIG_STRGTH_THRESHOLD) OR (dly_data_out(2) <0) OR (dly_data_out(2) > H2O_RNG_TOP_LIMIT))
        cov_array_H2O(array_index, 5)       = dly_data_out(2)/(0.01801582*divisor)              'H2O in mmol mol-1 (See http://www.carbontracker.eu/glossary.html) 
       
      Next i

      'Call tables for lag maximization
      CallTable comp_cov_CO2
      CallTable comp_cov_H2O

      'Extract the twenty two flags from the IRGA diagnostic word
      diag_irga_tmp = IIF ((diag_irga <> NAN) AND (diag_irga <> -1),diag_irga, &h3fffff)
      diag_irga_aggregate = diag_irga_aggregate OR diag_irga_tmp
      
      For i = 1 To 22
        diag_bits_irga(i) = diag_irga_tmp AND mask
        mask = mask*2
      Next i

      'Filter data in the covariance instruction if the IRGA reports bad data.
      irga_disable_f = irga_bad_data_f

      'Call table for data used for data quality grading
      CallTable comp_cov_cs_5min
      
      '***Compute water vapor pressure, dry air density, moist air density, saturate water pressure, RH and dew point temperature  

      'Using 107 temperature, H2O, and pressure 
      'water vapor pressure, dry air density, and moist air density 
      amb_e     = H2O_density*Rv*(amb_tmpr + T_0C_K )                                                 'Ideal gas equation (kPa)
      amb_rho_d = (amb_press - amb_e)/((amb_tmpr + T_0C_K)*Rd)                                        'g/m^3
      amb_rho_a = (amb_rho_d + H2O_density)/1000.0                                                    'kg/m^3

      'Saturation water pressure at current temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(amb_tmpr + 30.6 - 0.38*amb_press)^2.0) 'Eq. 6 from Appendix A of flux program manual

      Select Case amb_tmpr                                                                            'Eq. 5 from Appendix A of flux program manual
      Case Is >= 0.0
        amb_e_sat = 0.61121*Enhance_Factor1*EXP((17.368*amb_tmpr)/(amb_tmpr + 238.88))
      Case Is < 0.0
        amb_e_sat = 0.61121*Enhance_Factor1*EXP((17.966*amb_tmpr)/(amb_tmpr + 247.15))
      EndSelect

      'Relative humidity
      amb_RH = 100.0 * amb_e/amb_e_sat
      
      'Dew point temperature for general use for accurately computing the final dew point temperature
      Enhance_Factor2 = 1.00072 + 3.46e-5*amb_press                                                  'Eq. 9 from Appendix A of flux program manual

      x_tmp           = LN(amb_e/(0.61121*Enhance_Factor2))                                          'For dew point temperature, assume that e is saturation water vapor pressure
      Td_gp           = 240.97*x_tmp/(17.502-x_tmp)

      'Accurate dew point temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Td_gp + 30.6 - 0.38*amb_press)^2.0)    'Eq. 6 from Appendix A of flux program manual
      x_tmp           = LN(amb_e/(0.61121*Enhance_Factor1))                                           'For dew point temperature, assume that e is saturation water vapor pressure

      Select Case Td_gp                                                                               'Eq. 11 from Appendix A of flux program manual
      Case Is >= 0.0
        amb_T_DP = 238.88*x_tmp/(17.368 - x_tmp)
      Case Is < 0.0
        amb_T_DP = 247.15*x_tmp/(17.966 - x_tmp)
      EndSelect

     'Using sonic temperature, H2O, and pressure 

      If (Ts_K <> NaN) Then
        'Compute fast response air temperature from sonic temperature and IRGASON vapor density.
        x_tmp = SQR(((1-epsilon)*Rd*H2O_density*Ts_K + epsilon*amb_press)^2.0 - 4*epsilon*(1-1.511494*epsilon)*Rd*H2O_density*amb_press*Ts_K)  
        Tc_K  = ((1.0 - epsilon)*Rd*H2O_density*Ts_K + epsilon*amb_press - x_tmp)/(2.0*(1.0 - 1.511494*epsilon)*Rd*H2O_density)   'Eq 21 from "Derivation and application of air temperature equation from collocated and synchronously measured sonic temperature and water vapor density", Zhou and Campbell, 2014 (unpublished)
      Else
        Tc_K = NaN                                                               'Tc_K in K
      EndIf
       
      'Calculate water vapor pressure using sonic and IRGA measurements
      e     = H2O_density*Rv*Tc_K                                                'Ideal gas equation (kPa)
      rho_d = (amb_press - e)/(Tc_K*Rd)                                          'g/m^3
      rho_a = (rho_d + H2O_density)/1000                                         'kg/m^3
    
      'Convert Tc in K to Tc in C
      Tc = Tc_K - T_0C_K                                                         'Tc in C

      'Saturation water pressure at current temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Tc + 30.6 - 0.38*amb_press)^2.0) 'Eq. 6 from Appendix A of flux program manual

      Select Case Tc                                                                            'Eq. 5 from Appendix A of flux program manual
      Case Is >= 0
        e_sat = 0.61121*Enhance_Factor1*EXP((17.368*Tc)/(Tc + 238.88))
      Case Is < 0
        e_sat = 0.61121*Enhance_Factor1*EXP((17.966*Tc)/(Tc + 247.15))
      EndSelect

      'Relative humidity
      RH = 100.0 * e/e_sat
      
      'Dew point temperature for general use for accurately computing the final dew point temperature
      Enhance_Factor2 = 1.00072 + 3.46e-5*amb_press                                              'Eq. 9 from Appendix A of flux program manual

      x_tmp           = LN(e/(0.61121*Enhance_Factor2))                                          'For dew point temperature, assume that e is saturation water vapor pressure
      Td_gp           = 240.97*x_tmp/(17.502-x_tmp)

      'Accurate dew point temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Td_gp + 30.6 - 0.38*amb_press)^2.0) 'Eq. 6 from Appendix A of flux program manual
      x_tmp           = LN(e/(0.61121*Enhance_Factor1))                                            'For dew point temperature, assume that e is saturation water vapor pressure

      Select Case Td_gp                                                                            'Eq. 11 from Appendix A of flux program manual
      Case Is >= 0
        T_DP = 238.88*x_tmp/(17.368 - x_tmp)
      Case Is < 0
        T_DP = 247.15*x_tmp/(17.966 - x_tmp)
      EndSelect

      'Compute the molar mixing ratio of CO2 and H2O.
      divisor = (amb_press/(R*Tc_K))-(H2O_density/18.01528)
      CO2_mixratio = CO2_density/(0.04401*divisor)
      H2O_mixratio = H2O_density/(0.01802*divisor)

      CallTable comp_mean                                                                        'Calculate the means of air temperature, relative humidity, dew point temperature, and pressure              

      If (comp_cov_cs_5min.Output(1, 1)) Then
        GetRecord (CO2_density_var_SST, comp_cov_cs_5min, 1)

        If (NOT Planar_Fit_flg) Then
          'Rotation for the covariance of CO2 with velocities
          Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
          UxCO2_Cov_SST, UyCO2_Cov_SST, UzCO2_Cov_SST, _
          UCO2_Cov_SST,  VCO2_Cov_SST,  WCO2_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
          
          'Rotation for the covariance of H2O with velocities
          Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
          UxH2O_Cov_SST, UyH2O_Cov_SST, UzH2O_Cov_SST, _
          UH2O_Cov_SST,  VH2O_Cov_SST,  WH2O_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
        Else
          'Rotations for the covariance of CO2 with velocities
          Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
          UxCO2_Cov_SST, UyCO2_Cov_SST, UzCO2_Cov_SST, _
          UCO2_Cov_SST,  VCO2_Cov_SST,  WCO2_Cov_SST)
         'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
          
          'Rotations for the covariance of H2O with velocities
          Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
          UxH2O_Cov_SST, UyH2O_Cov_SST, UzH2O_Cov_SST, _
          UH2O_Cov_SST,  VH2O_Cov_SST,  WH2O_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W 
        EndIf

        If ((WCO2_Cov_SST <> NaN) AND (WH2O_Cov_SST <> NaN)) Then
          RN_WCO2_Cov += WCO2_Cov_SST
          RN_WH2O_Cov += WH2O_Cov_SST
          nmbr_interval_qc_irga += 1
        EndIf

      EndIf

      If (comp_cov_CO2.Output(1,1) AND comp_cov_H2O.Output(1,1) AND comp_mean.Output(1,1) AND comp_cov_cs_5min.Output(1, 1))  Then
        GetRecord (CO2_Avg_lag_b5, comp_cov_CO2, 1)
        GetRecord (H2O_Avg_lag_b5, comp_cov_H2O, 1)
        GetRecord (TA_1_1_1,       comp_mean,    1)

        VPD = 10.0*(e_sat_Avg - e_Avg)                'Water vapor pressure deficit in hPa. "10" is used to convert unit of kPa to hPa

        'Rotate CO2-related covariance
        WCO2_Cov_major_sign = 0.0                     'Variable indicating the major direction (sign) of CO2 flux

        For i = 1 To (2* MAX_LAG + 1)
          array_index = 7*(i-1) + 5
          If (NOT (Planar_Fit_flg)) Then
            'Double rotations
            'Rotation for the covariance of CO2 with velocities
            Call Rotation12_Scalar_Covariance(alpha, gamma, _
            Cov_out_CO2(array_index), Cov_out_CO2(array_index + 1), Cov_out_CO2(array_index + 2), _
            UCO2_VCO2_Cov_lag(i, 1),  UCO2_VCO2_Cov_lag(i, 2),      WCO2_Cov_lag (i))
            'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
          Else
            'Planar Fit rotations
            'Rotation for the covariance of CO2 with velocities
            Call Rotation23_Scalar_Covariance(alpha, beta, _
            Cov_out_CO2(array_index), Cov_out_CO2(array_index + 1), Cov_out_CO2(array_index + 2), _
            UCO2_VCO2_Cov_lag(i, 1),  UCO2_VCO2_Cov_lag(i, 2),      WCO2_Cov_lag (i))
           'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
          EndIf

          WCO2_Cov_major_sign += WCO2_Cov_lag (i)

        Next i

        ' Calculate the separation distance normal (lateral) to wind and separation distance along wind
        Call Separation_Lag_Lateral_Distances (WD_SONIC, separation_x_irga, separation_y_irga, separation_lat_dist_irga, separation_lag_dist_irga)
        separation_lag_scan_irga = 1000*(separation_lag_dist_irga/WS_RSLT)/SCN_INTV   'in scan

        WCO2_Cov = NaN
        Select Case WCO2_Cov_major_sign
        Case Is >= 0.0
          
          If separation_lag_scan_irga <= - MAX_LAG           Then  'Find max of wCO2_cov_R
            MaxSpa (WCO2_Cov, 2, WCO2_Cov_lag (1))                 'Map 2 elements

          ElseIf separation_lag_scan_irga < - (MAX_LAG - 1) Then   'Search 3 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 3, WCO2_Cov_lag (1))                 'Map 3 elements

          ElseIf separation_lag_scan_irga < - (MAX_LAG - 2) Then   'Search 4 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (1))                 'Map 4 elements
         
          ElseIf separation_lag_scan_irga < - (MAX_LAG - 3) Then   'Search 4 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (2))                 'Map 4 elements
            lag_irga = lag_irga + 1

          ElseIf separation_lag_scan_irga < - (MAX_LAG - 4) Then   'Search 4 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (3))                 'Map 4 elements
            lag_irga = lag_irga + 2
            
          ElseIf separation_lag_scan_irga < (MAX_LAG - 5)   Then   'Search 4 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (4))                 'Map 4 elements
            lag_irga = lag_irga + 3
 
          ElseIf separation_lag_scan_irga = 0               Then   'Do not have to search if IRGASON Search 3 elements if CSAT3A + EC150
          #If (IRGASON) Then 
            WCO2_Cov = WCO2_Cov_lag (MAX_LAG + 1)                  'Do not have to search
            lag_irga = MAX_LAG + 1
          #Else
            MaxSpa (WCO2_Cov, 3, WCO2_Cov_lag (5))                 'Map 3 elements
            lag_irga = lag_irga + (MAX_LAG -1) 
          #EndIf 

          ElseIf separation_lag_scan_irga < 1               Then   'Search 4 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG))           'Map 4 elements
            lag_irga = lag_irga + (MAX_LAG - 1)  

          ElseIf separation_lag_scan_irga < 2               Then   'Search 4 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 1))       'Map 4 elements
            lag_irga = lag_irga + MAX_LAG 
          
          ElseIf separation_lag_scan_irga < 3               Then   'Search 4 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 2))       'Map 4 elements
            lag_irga = lag_irga + (MAX_LAG  + 1) 

          ElseIf separation_lag_scan_irga < 4               Then   'Search 4 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 3))       'Map 4 elements
            lag_irga = lag_irga + (MAX_LAG  + 2) 

         ElseIf separation_lag_scan_irga < 5                Then   'Search 3 elements in the array to ensure maximization of wCO2_cov_R
            MaxSpa (WCO2_Cov, 3, WCO2_Cov_lag (MAX_LAG + 4))       'Map 3 elements
            lag_irga = lag_irga + (MAX_LAG  + 3) 

          Else
            MaxSpa (WCO2_Cov, 2, WCO2_Cov_lag (2*MAX_LAG)          'Map 3 elements
            lag_irga = lag_irga + (2*MAX_LAG -1)  
          EndIf

        Case Is < 0.0

         If separation_lag_scan_irga <= - MAX_LAG          Then   'Find min of wCO2_cov_R
            MinSpa (WCO2_Cov, 2, WCO2_Cov_lag (1))                'Map 2 elements

         ElseIf separation_lag_scan_irga < - (MAX_LAG - 1) Then   'Search 3 elements in the array to ensure maximization in terms of absolute value.
            MinSpa (WCO2_Cov, 3, WCO2_Cov_lag (1))                 'Map 3 elements
           
         ElseIf separation_lag_scan_irga < - (MAX_LAG - 2) Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
            MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (1))                 'Map 4 elements
           
         ElseIf separation_lag_scan_irga < - (MAX_LAG - 3) Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (2))                 'Map 4 elements
           lag_irga = lag_irga + 1
           
         ElseIf separation_lag_scan_irga < - (MAX_LAG - 4) Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (3))                 'Map 4 elements
           lag_irga = lag_irga + 2

         ElseIf separation_lag_scan_irga < (MAX_LAG - 5)   Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (4))                 'Map 4 elements
           lag_irga = lag_irga + 3           

         ElseIf separation_lag_scan_irga = 0               Then   'Do not have to search if IRGASON Search 3 elements if CSAT3A + EC150
         #If (IRGASON) Then
            WCO2_Cov = WCO2_Cov_lag (MAX_LAG + 1)                 'Do not have to search
            lag_irga = MAX_LAG + 1
         #Else
            MinSpa (WCO2_Cov, 3, WCO2_Cov_lag (5))                'Search 3 elements
            lag_irga = lag_irga + (MAX_LAG -1)
         #EndIf
        
         ElseIf separation_lag_scan_irga < 1                Then  'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG))           'Map 4 elements
           lag_irga = lag_irga + (MAX_LAG - 1)           

         ElseIf separation_lag_scan_irga < 2                Then  'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 1))       'Map 4 elements
           lag_irga = lag_irga + MAX_LAG       

         ElseIf separation_lag_scan_irga < 3                Then  'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 2))       'Map 4 elements
           lag_irga = lag_irga + MAX_LAG + 1   
           
         ElseIf separation_lag_scan_irga < 4                Then  'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 3))       'Map 4 elements
           lag_irga = lag_irga + MAX_LAG + 2         

         ElseIf separation_lag_scan_irga < 5                Then  'Search 3 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WCO2_Cov, 3, WCO2_Cov_lag (MAX_LAG + 4))       'Map 3 elements
           lag_irga = lag_irga + MAX_LAG + 3        
         
         Else  
           MinSpa (WCO2_Cov, 2, WCO2_Cov_lag (2*MAX_LAG))        'Map 2 elements
           lag_irga = lag_irga + (2*MAX_LAG -1)        
         EndIf  

        EndSelect

        If (WCO2_Cov = NaN) Then lag_irga = MAX_LAG + 1          'Lag_irga is not evaluated inside SELECT CASE if WCO2_Cov = NaN. In this case, data w/o lag delay in cov_out_CO2 are kept.

        'For final storage in flux file
        'Covariance values related to CO2 before coordinate rotation can be found using lag-IRGA
        array_index =  7*(lag_irga - 1) + 1
        Move (CO2, 7, Cov_out_CO2(array_index), 7)
        CO2_SIGMA         = SQR (CO2_SIGMA)
        CO2_density_SIGMA = SQR (CO2_density_SIGMA)
         
        'Covariance of horizontal wind (after coordinate rotations) and CO2 using lag-IRGA
        UCO2_Cov = UCO2_VCO2_Cov_lag(lag_irga, 1)
        VCO2_Cov = UCO2_VCO2_Cov_lag(lag_irga, 2)
        
        'Covariance values related to H2O before coordinate rotation can be found using lag-IRGA
        Move (H2O, 7, Cov_out_H2O(array_index), 7)
        H2O_SIGMA         = SQR (H2O_SIGMA)
        H2O_density_SIGMA = SQR (H2O_density_SIGMA)

        'Rotate covariance related to H2O
        If (NOT Planar_Fit_flg) Then
          'Double rotations
          ' Rotation for the covariance of H2O with velocities
          Call Rotation12_Scalar_Covariance(alpha, gamma, _
          UxH2O_Cov, UyH2O_Cov, UzH2O_Cov, _
          UH2O_Cov,  VH2O_Cov,  WH2O_Cov)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
            
        ElseIf (Planar_Fit_flg) Then
          ' Planar Fit rotations
          ' Rotation for the covariance of H2O with velocities
          Call Rotation23_Scalar_Covariance(alpha, beta, _
          UxH2O_Cov, UyH2O_Cov, UzH2O_Cov, _
          UH2O_Cov,  VH2O_Cov,  WH2O_Cov)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
            
        EndIf

        'Convert lag_IRGA as an array index in sequential number as a lag number in scan (compare to CSAT data, negative: backward and positive: forward)
        lag_irga  = lag_irga  - (MAX_LAG + 1)

        ' Calculate the frequency correction factor for WCO2_cov_R and WH2O_Cov
        Call FreqFactorCSOPEC_wco2_wh2o_BA_LA_SP (z, ZL, WS_RSLT, separation_lat_dist_irga, FreqFactor_WCO2_WH2O)
        WCO2_Cov_fc = FreqFactor_WCO2_WH2O*WCO2_Cov
        WH2O_Cov_fc = FreqFactor_WCO2_WH2O*WH2O_Cov

        'Momentum flux after coordinate rotation and frequency corrections
        TAU = rho_a_Avg*USTAR*USTAR                                                    'eq. (9.14), page 384 (Wallace and Hobbs (2006)
        
        'Correct sonic temperature flux for humidity and calculate sensible heat flux
        WT_SONIC_Cov_fc_SND = WT_SONIC_Cov_fc*(1- 0.51*(H2O_density_Avg/(1e3*rho_a_Avg)))-0.51*(T_SONIC + T_0C_K)*WH2O_Cov_fc/(1e3*rho_a_Avg)     'eq. 2.53 in van Dijk (2002)
      
        Cp = (Cpd*rho_d_Avg + Cpw*H2O_density_Avg)/(rho_d_Avg + H2O_density_Avg)   'Specific heat of moist air
        H  = Cp*rho_a_Avg*WT_SONIC_Cov_fc_SND

         TSTAR = - WT_SONIC_Cov_fc_SND/USTAR                                       'Surface layer scaling temperature, eq.(1.25b) page 16, Kaimal and Finnigan (1994). 

        'Apply WPL correction after coordinate rotation and freq corrections
        'IRGA Webb et al. (1980) term for carbon dioxide Eq. (24).
        sigma_wpl    = H2O_density_Avg/rho_d_Avg
        CO2_E_WPL_fc = MU_WPL*CO2_density_Avg*WH2O_Cov_fc/rho_d_Avg
        CO2_T_WPL_fc = (1 + (MU_WPL*sigma_wpl))*CO2_density_Avg*WT_SONIC_Cov_fc_SND/(TA_2_1_1+T_0C_K)

        FC_mass  = WCO2_Cov_fc + CO2_E_WPL_fc + CO2_T_WPL_fc                     'in mg/(m^2 s)
        FC = 22.72237*FC_mass                                                    '"22.72237" converts mg/(m^2 s) to umol/(m^2 s)

        'IRGA Webb et al. (1980) term for water vapor Eq. (25).
        H2O_E_WPL_fc  = MU_WPL*sigma_wpl*WH2O_Cov_fc
        H2O_T_WPL_fc  = (1 + (MU_WPL*sigma_wpl))*H2O_density_Avg*WT_SONIC_Cov_fc_SND/(TA_2_1_1 + T_0C_K)

        Lv  = 2501 - 2.365*TA_2_1_1                                             'Stull (1989)
        LE  = Lv* (WH2O_Cov_fc + H2O_E_WPL_fc + H2O_T_WPL_fc)                   'W/m^2
        ET  = 3.6*(WH2O_Cov_fc + H2O_E_WPL_fc + H2O_T_WPL_fc)                   'mm/hr

        Bowen_ratio = H/LE

        '*** Data quality classification for scalar fluxes ***
        'Sensible heat flux
        'Calculate the measures of relative non-stationarity (Steady State Test)
        RN_WT_SONIC_cov  = ABS((RN_WT_SONIC_cov/nmbr_interval_qc_csat - WT_SONIC_Cov)/WT_SONIC_Cov)                                              'in fraction
        Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WT_SONIC_cov, H_QC)           'Quality classification for sensible heat flux w/ considering wind direction  
        Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WT_SONIC_cov, H_SSITC_TEST)   'Quality classification for sensible heat flux w/o considering wind direction  
        RN_WT_SONIC_cov = 0.0
        nmbr_interval_qc_csat = 0.0

        'CO2 flux
        'Calculate measures of relative non-stationarity (Steady State Test)
        RN_WCO2_Cov = ABS((RN_WCO2_Cov/nmbr_interval_qc_irga - WCO2_Cov)/WCO2_Cov)                                                                'in fraction
        Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WCO2_Cov, FC_QC)               'Quality classification for CO2 flux w/ considering wind direction  
        Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WCO2_Cov, FC_SSITC_TEST)       'Quality classification for CO2 flux w/o considering wind direction 
        RN_WCO2_Cov   = 0.0

        'H2O flux
        'Calculate measures of relative non-stationarity (Steady State Test)
        RN_WH2O_Cov = ABS((RN_WH2O_Cov/nmbr_interval_qc_irga - WH2O_Cov)/WH2O_Cov)  'in fraction
        Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WH2O_Cov, LE_QC)               'Quality classification for latent heat flux w/ considering wind direction  
        Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WH2O_Cov, LE_SSITC_TEST)       'Quality classification for latent heat flux w/o considering wind direction 
        RN_WH2O_Cov   = 0.0
        nmbr_interval_qc_irga = 0.0
        '*** End of data quality classification for scalar fluxes ***
          
        '*** Construct ending time stamp ****
        CR6_clock = status.timestamp(4,1)
        TIMESTAMP_END = Left (CR6_clock, 4) & Mid (CR6_clock, 6, 2) & Mid (CR6_clock, 9, 2) & Mid (CR6_clock,12,2)& Mid (CR6_clock,15,2)   
        '*** End of constructing ending time stamp ****
   
      EndIf
      '*** End of IRGA processing ***
        
      #If (SENSOR_T_RH) Then
      '*** Beginning of temperature and humidity processing ***
      CallTable stats_tmpr_rh
            
      If (stats_tmpr_rh.Output(1,1)) Then
        GetRecord (TA_3_1_1, stats_tmpr_rh, 1)
        rho_a_probe_Avg = (rho_d_probe_Avg + H2O_probe_Avg)/1000.0                 'kg/m^3
      EndIf
      '*** End of temperature and humidity probe processing ***
     #EndIf 
     
     #If (SENSOR_NRLIT OR (SENSOR_CNR4 AND SENSOR_CNF4)) Then
      '*** Beginning of 3-second running mean of horizontal wind for NR Lite and/or CNF4 ***
      hor_wind_raw = SQR (sonic_irga_raw(1)*sonic_irga_raw(1) + sonic_irga_raw(2)*sonic_irga_raw(2))
      AvgRun (hor_wind, 1 , hor_wind_raw, NMBR_WND_SAMPLES)                        'Maintain a three second running mean of horizontal wind.
      AvgRun (hor_wind_diag, 1, sonic_irga_raw(5), NMBR_WND_SAMPLES)               'Only correct for wind when hor_wind_diag has been non-zero for past 3 seconds.
      '*** End of 3-second running mean of horizontal wind for NR Lite and/or CNF4 ***
      #EndIf

      #If (SENSOR_Rn) Then
      CallTable stats_net_radiation

      'Get Rn for the current averaging interval ***
      If (stats_net_radiation.Output(1,1)) Then

        GetRecord (NETRAD, stats_net_radiation, 1)

      EndIf
      #EndIf

      #If (SENSOR_HFP) Then

      '*** Beginning of table for soil heat flux plate ***
      CallTable stats_SHF
      '*** End of table for soil heat flux plate ***

      '*** Beginning of calculating the change in heat storage of soil above soil heat flux plate ***
      If (stats_SHF.Output(1,1)) Then

        GetRecord (G_plate_1_1_1, stats_SHF, 1)

        #If ((SENSOR_TCAV OR SENSOR_CS65X) AND SENSOR_CS6XX) Then
          
        For i = 1 To NMBR_HFP
           SG_rep (i)  = ((Tsoil_current (i) - Tsoil_prev (i))*Cds*soil_bulk_density + _
                          (Tsoil_current(i)*soil_wtr_current (i) - Tsoil_prev(i)*soil_wtr_prev(i))*1000*Cw)*thick_abv_SHFP/(60*OUTPUT_INTV - Offset_intv_delta_ht_storage)
                   
           G_surface_rep(i) = shf_plate_avg(i) + SG_rep (i)  
        Next i
 
        AvgSpa(G_surface, NMBR_HFP, shf_plate_avg(1))                        'G_surface is used as a temporary variable
        AvgSpa(SG,        NMBR_HFP, SG_rep (1))
        
        G_surface = G_surface + SG
        
        Offset_intv_delta_ht_storage = 0                                         'Reset time interval offset
        
       #If (SENSOR_TCAV) Then
          Move (Tsoil_prev (1), NMBR_TCAV, Tsoil_current(1), NMBR_TCAV)
       #EndIf
       #If ((NOT SENSOR_TCAV) AND (SENSOR_CS65X)) Then
          Move (Tsoil_prev (1), NMBR_CS6xx, Tsoil_current(1), NMBR_CS6xx)
       #EndIf

       Move (soil_wtr_prev(1), NMBR_CS6xx, soil_wtr_current (1), NMBR_CS6xx)

      #If (SENSOR_Rn) Then
        'NR01 and CNR4: smallest sensitivity is 10 uV/(W/m^2), CR6 resolution at the measurement range (+/-200 mV) is 0.1 uV.
        'Radiation < 0.01 W/m^2 can not be resolved by CR6. The value of 0.1 is used for this threshold although this is approximation.
        If  (ABS(NETRAD - G_surface) > 0.1) Then
          energy_closure = (LE + H)/(NETRAD - G_surface)          
        Else
          energy_closure = 1
        EndIf
        
        #If (SENSOR_TE525) Then  
        If (((energy_closure > 1.25) OR (energy_closure < 0.75) OR (energy_closure = NaN)) AND (USTAR > 0.2)  AND (RH_2_1_1 < 85) AND (P_cumul_win_interval = 0) AND (sun_elevation > 15)) Then 
           poor_energy_closure_flg = TRUE 
        Else 
           poor_energy_closure_flg = (energy_closure = NaN)
        EndIf 

           P_cumul_win_interval = 0     'Use to indicate the rain within a current interval to judge poor_energy_closure_flg 
        #EndIf        
       
        #EndIf '(SENSOR_Rn)
        #EndIf '((SENSOR_TCAV OR SENSOR_CS65X) AND SENSOR_CS6XX)

      EndIf
      #EndIf '(SENSOR_HFP)
      #If (SENSOR_FW) Then

      '*** Beginning of FW processing ***
      'Load in the FW data that has been lagged by OFFSET scans.
      For i = MAX_LAG To - MAX_LAG Step -1
        array_index = MAX_LAG + 1 - i                                           'Convert i = MAX_LAG, ..., 1, 0 -1, ..., MAX_LAG to array_index = 1, 2, ..., 2*MAX_LAG +1

        GetRecord (dly_data_FW_out(1), delay_fw, (OFFSET + i))

        'Load the arrays that hold the input data for the covariance instructions.
        Cov_array_FW(array_index, 1) = dly_data_FW_out(1)                       'fw
        Move (Cov_array_FW(array_index, 2), 3, Ux, 3)
        
        FW_bad_data_flg(array_index) = (dly_data_FW_out(2) = -1)
                             
      Next i

      FW = Cov_array_FW(MAX_LAG + 1, 1)                                          'FW with no lag will be stored to Time_Series table

      CallTable comp_cov_fw

      If (comp_cov_fw.Output(1,1)) Then
        GetRecord (FW_Avg_lag_b5, comp_cov_fw, 1)

        WFW_cov_major_sign =0

        For i = 1 To (2* MAX_LAG + 1)
          array_index = 6*(i -1) + 3
          If (NOT (Planar_Fit_flg)) Then
            ' Double rotations
            ' Rotation for the covariance of FW temperature with wind velocities
            Call Rotation12_Scalar_Covariance(alpha, gamma, _
            Cov_out_FW(array_index), Cov_out_FW(array_index + 1), Cov_out_FW(array_index + 2), _
            UFW_VFW_Cov_lag(i, 1),   UFW_VFW_Cov_lag(i, 2),       WFW_Cov_lag (i))
            
          Else
            ' Planar fit rotations
            ' Rotation for the covariance of FW temperature with velocities
            Call Rotation23_Scalar_Covariance(alpha, beta, _
            Cov_out_FW(array_index), Cov_out_FW(array_index + 1), Cov_out_FW(array_index + 2), _
            UFW_VFW_Cov_lag(i, 1),   UFW_VFW_Cov_lag(i, 2),       WFW_Cov_lag (i))
          EndIf

            WFW_cov_major_sign += WFW_Cov_lag(i)
        Next i

        'Calculate the separation distances normal (lateral) to wind and separation distances along wind
        Call Separation_Lag_Lateral_Distances (WD_SONIC, separation_x_FW, separation_y_FW, separation_lat_dist_FW, separation_lag_dist_FW)
        separation_lag_scan_FW = 1000.0*(separation_lag_dist_FW/WS_RSLT)/SCN_INTV         ' in scan

        WFW_Cov = NaN
        Select Case WFW_cov_major_sign
        Case Is >= 0.0
          
          If separation_lag_scan_FW <= - MAX_LAG           Then  'Find max of wFW_cov_R
            MaxSpa (WFW_Cov, 2, WFW_Cov_lag (1))                 'Map 2 elements

          ElseIf separation_lag_scan_FW < - (MAX_LAG - 1) Then   'Search 3 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 3, WFW_Cov_lag (1))                 'Map 3 elements

          ElseIf separation_lag_scan_FW < - (MAX_LAG - 2) Then   'Search 4 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 4, WFW_Cov_lag (1))                 'Map 4 elements
         
          ElseIf separation_lag_scan_FW < - (MAX_LAG - 3) Then   'Search 4 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 4, WFW_Cov_lag (2))                 'Map 4 elements
            lag_FW = lag_FW + 1

          ElseIf separation_lag_scan_FW < - (MAX_LAG - 4) Then   'Search 4 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 4, WFW_Cov_lag (3))                 'Map 4 elements
            lag_FW = lag_FW + 2
            
          ElseIf separation_lag_scan_FW < (MAX_LAG - 5)   Then   'Search 4 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 4, WFW_Cov_lag (4))                 'Map 4 elements
            lag_FW = lag_FW + 3
          
          ElseIf separation_lag_scan_FW = 0               Then   'Search 3 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 3, WFW_Cov_lag (MAX_LAG))            'Map 3 elements
            lag_FW = lag_FW + (MAX_LAG -1)
  
          ElseIf separation_lag_scan_FW < 1               Then   'Search 4 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG))           'Map 4 elements
            lag_FW = lag_FW + (MAX_LAG - 1)  

          ElseIf separation_lag_scan_FW < 2               Then   'Search 4 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 1))       'Map 4 elements
            lag_FW = lag_FW + (MAX_LAG) 
          
          ElseIf separation_lag_scan_FW < 3               Then   'Search 4 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 2))       'Map 4 elements
            lag_FW = lag_FW + (MAX_LAG  + 1) 

          ElseIf separation_lag_scan_FW < 4               Then   'Search 4 elements in the array to ensure maximization of WFW_cov
            MaxSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 3))       'Map 4 elements
            lag_FW = lag_FW + (MAX_LAG  + 2) 

         ElseIf separation_lag_scan_FW < 5                Then   'Search 3 elements in the array to ensure maximization of WFW_cov_R
            MaxSpa (WFW_Cov, 3, WFW_Cov_lag (MAX_LAG + 4))       'Map 3 elements
            lag_FW = lag_FW + (MAX_LAG  + 3) 

          Else
            MaxSpa (WFW_Cov, 2, WFW_Cov_lag (2*MAX_LAG)          'Map 2 elements
            lag_FW = lag_FW + (2*MAX_LAG -1)  
          EndIf

        Case Is < 0.0

          If separation_lag_scan_FW <= - MAX_LAG          Then   'Find min of WFW_cov
            MinSpa (WFW_Cov, 2, WFW_Cov_lag (1))                 'Map 2 elements

          ElseIf separation_lag_scan_FW < - (MAX_LAG - 1) Then   'Search 3 elements in the array to ensure maximization in terms of absolute value.
            MinSpa (WFW_Cov, 3, WFW_Cov_lag (1))                 'Map 3 elements
           
          ElseIf separation_lag_scan_FW < - (MAX_LAG - 2) Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
            MinSpa (WFW_Cov, 4, WFW_Cov_lag (1))                 'Map 4 elements
           
         ElseIf separation_lag_scan_FW < - (MAX_LAG - 3) Then    'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WFW_Cov, 4, WFW_Cov_lag (2))                  'Map 4 elements
           lag_FW = lag_FW + 1
           
         ElseIf separation_lag_scan_FW < - (MAX_LAG - 4) Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WFW_Cov, 4, WFW_Cov_lag (3))                 'Map 4 elements
           lag_FW = lag_FW + 2

         ElseIf separation_lag_scan_FW < (MAX_LAG - 5)   Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WFW_Cov, 4, WFW_Cov_lag (4))                 'Map 4 elements
           lag_FW = lag_FW + 3
           
         ElseIf separation_lag_scan_FW = 0               Then   'Search 3 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WFW_Cov, 3, WFW_Cov_lag (MAX_LAG))            'Map 3 elements
           lag_FW = lag_FW + (MAX_LAG -1)           

         ElseIf separation_lag_scan_FW < 1               Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG))           'Map 4 elements
           lag_FW = lag_FW + (MAX_LAG - 1)           

         ElseIf separation_lag_scan_FW < 2               Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 1))       'Map 4 elements
           lag_FW = lag_FW + MAX_LAG       

         ElseIf separation_lag_scan_FW < 3               Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 2))       'Map 4 elements
           lag_FW = lag_FW + MAX_LAG + 1   
           
         ElseIf separation_lag_scan_FW < 4               Then   'Search 4 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 3))       'Map 4 elements
           lag_FW = lag_FW + MAX_LAG + 2         

         ElseIf separation_lag_scan_FW < 5               Then   'Search 3 elements in the array to ensure maximization in terms of absolute value.
           MinSpa (WFW_Cov, 3, WFW_Cov_lag (MAX_LAG + 4))       'Map 3 elements
           lag_FW = lag_FW + MAX_LAG + 3        
         
         Else  
           MinSpa (WFW_Cov, 2, WFW_Cov_lag (2*MAX_LAG))         'Map 2 elements
           lag_FW = lag_FW + (2*MAX_LAG -1)        
         EndIf  

        EndSelect
                   
        If (WFW_Cov = NaN) Then lag_FW = MAX_LAG + 1            'Lag_FW is not evaluated inside SELECT CASE if WFW_Cov = NaN. In this case, data w/o lag delay in cov_out_fw are kept.

        ' For final storage in flux table
        ' FW Covariance before coordinate rotation can be found using lag-variable
        array_index = 6*(lag_FW - 1)
        FW_Avg      = Cov_out_FW(array_index + 1)
        FW_SIGMA    = SQR(Cov_out_FW(array_index + 2))
        UxFW_Cov    = Cov_out_FW(array_index + 3)
        UyFW_Cov    = Cov_out_FW(array_index + 4)
        UzFW_Cov    = Cov_out_FW(array_index + 5)
                                
        nmbr_smpl_FW = Cov_out_FW(array_index + 6)
        
        ' FW Covariance after coordinate rotation also can be found using lag-variable
        UFW_Cov = UFW_VFW_Cov_lag(lag_FW, 1)
        VFW_Cov = UFW_VFW_Cov_lag(lag_FW, 2)

        'Convert lag_FW in sequential number for array index to that in scan number. Compare to CSAT data, negative: backward and positive: forward.
        lag_FW  = lag_FW  - (MAX_LAG + 1)

        'Calculate FW time constant
        Call Time_Const_Thermocouple_E(FW_diameter, FW_Avg, WS_RSLT, rho_a_Avg, time_const_FW)
      
        Call FreqFactorCSATFW_wT_BA_LA_TC_SP (z, ZL, WS_RSLT, separation_lat_dist_FW, time_const_FW, FreqFactor_WFW)
        WFW_Cov_fc = FreqFactor_WFW*WFW_Cov
         
        H_FW = Cp*rho_a_Avg*WFW_Cov_fc
             
      EndIf
      '*** End of FW processing ***
      #EndIf
      
      'Save time series data.
      CallTable Time_Series

      'Save averaged and calculated data.
      CallTable Flux_AmeriFluxFormat
         
      CallTable Flux_CSFormat
     
      #If (NOT ONE_FL_TABLE) Then
      CallTable Flux_Notes
      #EndIf
      
      If (Flux_AmeriFluxFormat.Output(1,1)) Then
         diag_sonic_aggregate = &H0
         diag_irga_aggregate  = &H0

      'The ending time stamp in current interval is the starting time stamp for next interval 
        TIMESTAMP_START = TIMESTAMP_END
        Erase(TIMESTAMP_END)
        
     '*** End of Checking how many days left for data storage in MicroSD ****         
      EndIf
          
      slowsequence_disable_f = TRUE
      If (slowsequence_finished_f) Then
        slowsequence_finished_f = FALSE
        slowsequence_disable_f  = FALSE
      EndIf

    Else
      scan_count += 1
    EndIf

  NextScan

  SlowSequence

  Scan (SLW_SCN_INTV, mSec, 3, 0)

    'Measure battery voltage.
    Battery (batt_volt)
    
    'Measure CR6 panel temperature
    PanelTemp (panel_tmpr, NTCH_FRQ_SLW)
    
    process_time = (Status.ProcessTime(1,1))/1000.0                              'in ms 
    buff_depth   = Status.BuffDepth(1,1)
    
    CallTable diagnostic
             
    #If (SENSOR_Rn) Then
    '*** Beginning of net radiation measurements ***

    #If (SENSOR_NRLIT) Then

    '*** Beginning of NR Lite measurements ***
    VoltDiff(NETRAD_meas, 1, mV200, NRLITE_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, NRLITE_CAL, 0)

    'Apply calibration and wind correction to net radiometer measurement.
    If ((hor_wind_diag = 0) AND (hor_wind > 5.0)) Then
      NETRAD_raw = NETRAD_meas*(1.0 + (0.021286*(hor_wind - 5.0)))
    Else
      NETRAD_raw = NETRAD_meas
    EndIf
    '*** End of NR Lite measurements ***
    #EndIf '(SENSOR_NRLIT) 
    
    #If (SENSOR_NR01 OR SENSOR_CNR4) Then
    '*** Beginning of a 4-way radiometer measurements *** 
    CDM_VoltDiff(CDM_MODEL, CPI_ADDR_CDM, R_SW_in, 4, mV200, NR_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    'Compute net radiation, albedo, downwelling and upwelling long-wave radiation.
    R_SW_in       = R_SW_in*SW_IN_CAL
    SW_IN         = R_SW_in                                               'for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
    R_SW_out      = R_SW_out*SW_OUT_CAL
    R_LW_in_meas  = R_LW_in*LW_IN_CAL
    R_LW_out_meas = R_LW_out*LW_OUT_CAL

    NETRAD_raw = R_SW_in - R_SW_out + R_LW_in_meas - R_LW_out_meas

    'NR01 or CNR4: Smallest sensitivity is 10 uV/(W/m^2), CR6 resolution at the measurement range (+/-200 mV) is 0.1 uV.
    'Radiation < 0.01 W/m^2 can not be resolved by CR6. The value of 0.1 is used for this threshold although this is approximation.
    If (R_SW_in > 0.1) AND (R_SW_in >= R_SW_out) Then
      albedo = 100.0*(R_SW_out/R_SW_in)                                     'in %
    Else
      albedo = 0.0
    EndIf 
    #EndIf '(SENSOR_NR01 OR SENSOR_CNR4)

    #If (SENSOR_NR01) Then
     'Measure the resistance to calculate the body temperature.
    CDM_Resistance(CDM_MODEL, CPI_ADDR_CDM, T_nr, 1, mV200, T_NR_ANALOG_INPUT, T_NR_CURRENT_EXCITATION, 1, 1675, TRUE, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    T_nr = T_nr/100.0
    PRT (T_nr, 1, T_nr, 1, T_0C_K)

   'Correct long-wave radiation.
    R_LW_in  = R_LW_in_meas  + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
    R_LW_out = R_LW_out_meas + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
    
    If ((Tc - T_DP > CNR4NR01_HEATER_T_TD_THRSHLD) AND (NR01_heater_on_f)) Then       'Turn off heater when the difference between T and TD is greater than setting threshold 
       #If (NOT SENSOR_HFP01SC) Then 
       CDM_SW12 (CDM_MODEL, CPI_ADDR_CDM, 1, FALSE, 1)
       #Else
       SW12 (1, FALSE, 1)
       #EndIf
       NR01_heater_on_f = FALSE
     EndIf 
                             
     If ((Tc - T_DP <= CNR4NR01_HEATER_T_TD_THRSHLD) AND (NOT NR01_heater_on_f)) Then  'Turn on heater when the difference between T and TD is smaller than setting threshold   
       #If (NOT SENSOR_HFP01SC) Then 
       CDM_SW12 (CDM_MODEL, CPI_ADDR_CDM, 1, TRUE, 1)
       #Else
       SW12 (1, TRUE, 1)
       #EndIf
       NR01_heater_on_f = TRUE 
     EndIf                  

    '*** End of a 4-way radiometer measurements ***
    #EndIf '(SENSOR_NR01)

    #If (SENSOR_CNR4) Then
    'Correct longwave radiation.
    CDM_BrHalf (CDM_MODEL, CPI_ADDR_CDM, X_cnr4, 1, mV1000, 2*T_NR_ANALOG_INPUT - 1, T_NR_VOLTAGE_EXCITATION, 1, 1000, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    ln_R = LOG (1000.0*X_cnr4/(1-X_cnr4))
    T_nr = (1/(A_SHH+B_SHH*ln_R+C_SHH*ln_R*ln_R*ln_R))

    R_LW_in  = R_LW_in_meas  + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
    R_LW_out = R_LW_out_meas + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
    
    #If (SENSOR_CNF4) Then 
      If (hor_wind > CNR4_FAN_WND_THRSHLD) Then 
          cnr4_fan_on_f = FALSE                            'Turn off fan due to strong wind if heater is not on 
      Else 
          cnr4_fan_on_f = TRUE                             'Turn on fan due to low wind
      EndIf 
                    
      If (Tc - T_DP > CNR4NR01_HEATER_T_TD_THRSHLD) Then   'Turn off heater when the difference between T and TD is greater than setting threshold 
          cnr4_heater_1_on_f = FALSE
          cnr4_heater_2_on_f = FALSE
          
      ElseIf (Tc - T_DP > 0)                               'Turn on one heater line and fan           
          cnr4_heater_1_on_f = TRUE 
          cnr4_heater_2_on_f = FALSE
          cnr4_fan_on_f      = TRUE
          
      Else                                                 'Turn on two heater lines and fan 
          cnr4_heater_1_on_f = TRUE 
          cnr4_heater_2_on_f = TRUE
          cnr4_fan_on_f      = TRUE

      EndIf
     
     CDM_SW5 (CDM_MODEL, CPI_ADDR_CDM, CNF4_FAN_SW5_PORT,     cnr4_fan_on_f,      0)
     CDM_SW5 (CDM_MODEL, CPI_ADDR_CDM, CNF4_HEATER1_SW5_PORT, cnr4_heater_1_on_f, 0)                              
     CDM_SW5 (CDM_MODEL, CPI_ADDR_CDM, CNF4_HEATER2_SW5_PORT, cnr4_heater_2_on_f, 0)
     
     #EndIf '(SENSOR_CNF4)                 
    '*** End of a 4-way radiometer measurements ***
    #EndIf '(SENSOR_CNR4)
    
    #If (SENSOR_SN500) Then
      '*** Beginning of a 4-way radiometer measurements *** 
       SDI12Recorder(R_SW_in, SN500_SDI12_PORT, SN500SDI_ADR, "MC!",  1, 0, -1)
 
      'Compute net radiation, albedo, downwelling and upwelling long-wave radiation.
      SW_IN      = R_SW_in                                       'for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
      NETRAD_raw = R_SW_in - R_SW_out + R_LW_in - R_LW_out

      'The value of 10 for zero offset is used here for this threshold although this is approximation.
       If ((R_SW_in > 10) AND (R_SW_in >= R_SW_out)) Then
           albedo = 100.0*(R_SW_out/R_SW_in)                       'in %
       Else
       albedo = 0.0
       EndIf 
                
       SDI12Recorder(LW_in_sgnl_mV, SN500_SDI12_PORT, SN500SDI_ADR, "MC3!",  1, 0, -1)
       T_nr     = LW_in_tmpr  + T_0C_K
       T_nr_out = LW_out_tmpr + T_0C_K
                
       If (Tc - T_DP > SN500_HEATER_T_TD_THRSHLD) Then             'Turn off heater when the difference between T and TD is greater than setting threshold 
          SDI12Recorder(sn500_heater_set_dummy, SN500_SDI12_PORT, SN500SDI_ADR, "OXOFF!",  1, 0, -1)
          sn500_heater_on_f = FALSE
                  
       Else                                                       'Turn on heater when the difference between T and TD is smaller than setting threshold 
          SDI12Recorder(sn500_heater_set_dummy, SN500_SDI12_PORT, SN500SDI_ADR, "OXON!",  1, 0, -1)
          sn500_heater_on_f = TRUE
        EndIf 
        '*** End of a 4-way radiometer measurements ***
     #EndIf '(SENSOR_SN500)
  
   #EndIf '(SENSOR_Rn)

    #If (SENSOR_HFP01) Then
    '*** Beginning of HFP01 measurements ***
    CDM_VoltDiff (CDM_MODEL, CPI_ADDR_CDM, shf_plate(1), NMBR_HFP, mV200C, SHF_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, shf_plate_cal(),0)
    '*** End of HFP01 measurements ***

    #EndIf
    #If (SENSOR_HFP01SC) Then

    '*** Beginning of HFP01SC measurements ***
    CDM_VoltDiff (CDM_MODEL, CPI_ADDR_CDM, shf_mV(1), NMBR_HFP, mV200C, SHF_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    
    'Apply HFP01SC soil heat flux plate calibration.
    For i_slow = 1 To NMBR_HFP
      shf_plate(i_slow) = shf_mV(i_slow)*shf_plate_cal(i_slow)
    Next i_slow
     
    'Measure voltage across the heater (V_Rf).
    CDM_VoltDiff  (CDM_MODEL, CPI_ADDR_CDM, V_Rf(1), 1, mV5000, SHF_HEATER_ANALOG_INPUT,     TRUE, 500, NTCH_FRQ_SLW, 0.001, 0)
    #If  (NMBR_HFP > 1) 
    CDM_VoltDiff  (CDM_MODEL, CPI_ADDR_CDM, V_Rf(2), 1, mV5000, SHF_HEATER_ANALOG_INPUT + 1, TRUE, 500, NTCH_FRQ_SLW, 0.001, 0)
    #EndIf 
    #If  (NMBR_HFP > 2) 
    CDM_VoltDiff  (CDM_MODEL, CPI_ADDR_CDM, V_Rf(3), 1, mV5000, SHF_HEATER_ANALOG_INPUT + 3, TRUE, 500, NTCH_FRQ_SLW, 0.001, 0)
    #EndIf 

    'Maintain filtered values for calibration.
    AvgRun (shf_mV_run(1), NMBR_HFP, shf_mV(1), 10)
    AvgRun (V_Rf_run(1),   NMBR_HFP, V_Rf(1),   10)

    'Begin HFP01SC calibration one minute into very CAL_INTERVAL minutes.
    If (IfTime (1, CAL_INTERVAL, Min)) Then
      shf_cal_on_f = TRUE
      Move (shf_mV_0(1), NMBR_HFP, shf_mV_run(1), NMBR_HFP)
      
    'Power the HFP01SC heaters.
     CDM_SW12 (CDM_MODEL, CPI_ADDR_CDM, 1, TRUE, 1)
     #If (NMBR_HFP > 1)
     CDM_SW12 (CDM_MODEL, CPI_ADDR_CDM, 2, TRUE, 1)
    #EndIf 
    
    EndIf

    If (IfTime (4, CAL_INTERVAL, Min)) Then
      Move (shf_mV_180(1), NMBR_HFP, shf_mV_run(1), NMBR_HFP)
      Move (V_Rf_180(1),   NMBR_HFP, V_Rf_run(1),   NMBR_HFP)
    
     'Power off the HFP01SC heaters.
      CDM_SW12 (CDM_MODEL, CPI_ADDR_CDM, 1, FALSE, 1)
      #If (NMBR_HFP > 1)
      CDM_SW12 (CDM_MODEL, CPI_ADDR_CDM, 2, FALSE, 1)
      #EndIf 

    EndIf

    'End HFP01SC calibration sequence.
    If (IfTime(END_CAL, CAL_INTERVAL, Min)) Then
      Move (shf_mV_end(1), NMBR_HFP, shf_mV_run(1), NMBR_HFP)
      'Compute new HFP01SC calibration factors.
      For i_slow = 1 To NMBR_HFP
        If (V_Rf_180(i_slow) <> NaN) AND (shf_mV_0(i_slow) <> NaN) AND (shf_mV_180(i_slow) <> NaN) Then
        shf_plate_cal(i_slow) = V_Rf_180(i_slow)*V_Rf_180(i_slow)*128.7/ABS (((shf_mV_0(i_slow)+shf_mV_end(i_slow))/2)-shf_mV_180(i_slow))
        EndIf
      Next i_slow
        shf_cal_on_f = FALSE
    EndIf
    '*** End of HFP01SC measurements ***
   #EndIf '(SENSOR_HFP01SC)
    
    #If (SENSOR_TCAV) Then
    '*** Beginning of TCAV measurements ***
       CDM_TCDiff (CDM_MODEL, CPI_ADDR_CDM, Tsoil(1), NMBR_TCAV, mV200, TCAV_ANALOG_INPUT, TypeE, panel_tmpr_CDM_A116_1, TRUE, 500, NTCH_FRQ_SLW, 1, 0)

       Move(TS_1_1_1, NMBR_TCAV, Tsoil(1), NMBR_TCAV)                     'To store the data in AmeriFlux standard  
    
     #If ((SENSOR_HFP) AND (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
       AvgRun (Tsoil_current(1), NMBR_TCAV, Tsoil(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

     For i_slow = 1 To NMBR_TCAV
       If (Tsoil_prev(i_slow) = NaN) Then                                        'As soon as program starts
         Tsoil_prev(i_slow) = Tsoil(i_slow)
       EndIf
     Next
    
    #EndIf
   '*** End of TCAV measurements ***
  #EndIf '(SENSOR_TCAV) 

  #If (SENSOR_CS616) Then

    '*** Beginning of CS616 measurements ***
    CS616 (cs616_wcr(1), 1, CS616_ANALOG_INPUT, CS616_POWER_CTRL, NMBR_CS6xx, 1, 0)
    #If (NMBR_CS6xx > 1) Then 
    CS616 (cs616_wcr(2), 1, U4,                 CS616_POWER_CTRL, NMBR_CS6xx, 1, 0)
    #EndIf 
    #If (NMBR_CS6xx > 2) Then 
    CS616 (cs616_wcr(3), 1, U10,                CS616_POWER_CTRL, NMBR_CS6xx, 1, 0)
    #EndIf 

    #If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
    If (NMBR_CS6xx >= NMBR_TCAV) Then
      Move(Tsoil_for_CS616_correct(1), NMBR_CS6xx, Tsoil(1), NMBR_TCAV)
    Else
      Move(Tsoil_for_CS616_correct(1), NMBR_CS6xx, Tsoil(1), 1)
    EndIf
    #EndIf

    'Apply temperature correction to CS616 period and find volumetric water content.
    For i_slow = 1 To NMBR_CS6xx

      #If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
      If ( (10 <= Tsoil_for_CS616_correct(i_slow)) AND (Tsoil_for_CS616_correct(i_slow) <= 40) ) Then
        cs616_wcr_T(i_slow) = cs616_wcr(i_slow)+(20-Tsoil_for_CS616_correct(i_slow))*(0.526+cs616_wcr(i_slow)*(-0.052+cs616_wcr(i_slow)*0.00136))
      Else
        cs616_wcr_T(i_slow) = cs616_wcr(i_slow)
      EndIf
      soil_wtr_T(i_slow) = -0.0663+cs616_wcr_T(i_slow)*(-0.0063+cs616_wcr_T(i_slow)*0.0007)
      SWC_array(i_slow)  = 100*soil_wtr_T(i_slow)             
      #EndIf

      #If ((SENSOR_CS616) AND (NOT SENSOR_TCAV)) Then
      soil_wtr(i_slow) = -0.0663+cs616_wcr(i_slow)*(-0.0063+cs616_wcr(i_slow)*0.0007)
      SWC_array(i_slow)  = 100*soil_wtr(i_slow) 
      #EndIf

    Next i_slow

    #If ((SENSOR_HFP) AND (SENSOR_TCAV)) Then
      AvgRun (soil_wtr_current(1), NMBR_CS6xx, soil_wtr_T(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

      For i_slow = 1 To NMBR_CS6xx
       If (soil_wtr_prev(i_slow) = NaN) Then                              'As soon as program started
          soil_wtr_prev (i_slow) = soil_wtr_T(i_slow)
       EndIf
      Next 
    #EndIf
    '*** End of CS616 measurements ***
 #EndIf '(SENSOR_CS616)
 
 #If (SENSOR_CS65X) Then

    '*** Beginning of CS65X measurements ***
    SDI12Recorder (cs65x_raw(1), CS65X_SDI12_PORT, CSSDI12_ADR1, "M!", 1, 0, -1)
    cs65x_wc(1)   = cs65x_raw(1)                                      
    cs65x_ec(1)   = cs65x_raw(2)
    cs65x_tmpr(1) = cs65x_raw(3)
    #If (NMBR_CS6xx > 1) Then
    SDI12Recorder (cs65x_raw(1), CS65X_SDI12_PORT, CSSDI12_ADR2, "M!", 1, 0, -1)
    cs65x_wc(2)   = cs65x_raw(1)                                   
    cs65x_ec(2)   = cs65x_raw(2)
    cs65x_tmpr(2) = cs65x_raw(3)
    #EndIf
    #If (NMBR_CS6xx > 2) Then
    SDI12Recorder (cs65x_raw(1), CS65X_SDI12_PORT, CSSDI12_ADR3, "M!", 1, 0, -1)
    cs65x_wc(3)   = cs65x_raw(1)                                   
    cs65x_ec(3)   = cs65x_raw(2)
    cs65x_tmpr(3) = cs65x_raw(3)
    #EndIf
      
    'Soil temperature values measured from CS65X are used to report soil temperature if a TCAV sensor is not used  
    #If (SENSOR_CS65X AND (NOT SENSOR_TCAV)) Then
    Move (TS_1_1_1, NMBR_CS6xx, cs65x_tmpr(1), NMBR_CS6xx)
    #EndIf 
  
    'Correct volumetric soil moisture content using CS65x soil temperature  
    For i_slow = 1 To NMBR_CS6xx
      'SWC_1_1_1 if NMBR_CS6xx =1 and  SWC_1_1_1  and SWC_2_1_1 if NMBR_CS6xx = 2  
      If ((cs65x_wc(i_slow) > 0.05) AND  (cs65x_wc(i_slow) <> NaN)) Then    
      SWC_array(i_slow) = cs65x_wc(i_slow)*(1.32 - 1.6*cs65x_wc(i_slow) + 2.4* cs65x_wc(i_slow)*cs65x_wc(i_slow)) _
                          + cs65x_tmpr(i_slow)*cs65x_wc(i_slow)*(0.0029 + 0.0014*cs65x_wc(i_slow) - 0.0044*cs65x_wc(i_slow)*cs65x_wc(i_slow)) _
                          - 0.0002*cs65x_tmpr(i_slow) - 0.046    'Page 22 in the manual for CS650 & CS655 Water Content Reflectometer (Revision 4/18)
      Else 
      SWC_array(i_slow) = cs65x_wc(i_slow)
      
      EndIf  

    Next i_slow 
      
    #If (SENSOR_HFP) Then    

     AvgRun (soil_wtr_current(1), NMBR_CS6xx, SWC_array(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)
    
     For i_slow = 1 To NMBR_CS6xx
       If (soil_wtr_prev (i_slow) = NaN) Then
         soil_wtr_prev (i_slow) = SWC_array(i_slow)
       EndIf
     Next 

     #If (SENSOR_CS65X AND (NOT SENSOR_TCAV)) Then
       AvgRun (Tsoil_current(1), NMBR_CS6xx, cs65x_tmpr(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

       For i_slow = 1 To NMBR_CS6xx
         If (Tsoil_prev (i_slow) = NaN) Then                          'As soon as program starts
           Tsoil_prev(i_slow) = cs65x_tmpr(i_slow)
         EndIf
       Next 
     #EndIf
    #EndIf
      
     'Convert volumetric fraction to percent 
     For i_slow = 1 To NMBR_CS6xx
       SWC_array(i_slow) = 100*SWC_array(i_slow)                   'Conversion into percent for output 
     Next 

  '*** End of CS65X measurements ***
  #EndIf '(SENSOR_CS65X)
    
    #If (SENSOR_CS320) Then
    '*** Beginning of pyranometer measurements ***
       SDI12Recorder (SW_IN_CS320, CS320_SDI12_PORT, CS320SDI_ADR, "M4!", 1, 0, -1)

       If (SW_IN_CS320 < 0) Then 
           SW_IN_CS320 = 0
       EndIf 
                
           SW_IN =SW_IN_CS320                   
     '*** End of pyranometer measurements ***
    #EndIf '(SENSOR_CS320)


    #If (SENSOR_CS301) Then
    '*** Beginning of pyranometer measurements ***
    CDM_VoltDiff (CDM_MODEL, CPI_ADDR_CDM, SW_IN_pyran, 1, AutoRange, PYRAN_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    If SW_IN_pyran <=0 Then
      SW_IN = 0                                                       
    Else
      SW_IN =PYRAN_MULT*SW_IN_pyran                        
    EndIf
    '*** End of pyranometer measurements ***
    #EndIf
    
    #If (SENSOR_CS310) Then
    '*** Beginning of CS310 measurements ***
    CDM_VoltDiff (CDM_MODEL, CPI_ADDR_CDM, PPFD_IN, 1, AutoRange, QUANTUM_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    If (PPFD_IN <= 0) Then
      PPFD_IN = 0
    Else
      PPFD_IN = QUNTM_MULT*PPFD_IN 
    EndIf
    '*** End of CS310 measurements ***
    #EndIf
      
     #If (SENSOR_T_RH) Then
    '*** Beginning of temperature and humidity probe measurements ***
    VoltSe (T_probe, 2, mV1000, TMPR_RH_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    T_probe  = T_probe*TMPR_MULT + TMPR_OFST
    RH_probe = RH_probe*RH_MULT + RH_OFST
    '*** End of temperature and humidity probe measurements ***
      
    '*** Beginning of temperature and humidity probe processing ***
      'Saturation water pressure at current temperature
       Enhance_factor1_probe = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(T_probe + 30.6 - 0.38*amb_press)^2.0)     'Eq. 6 from Appendix A of flux program manual
 
       Select Case T_probe                                                                                       'Eq. 5 from Appendix A of flux program manual
         Case Is >= 0
           e_sat_probe = 0.61121*Enhance_factor1_probe*EXP((17.368*T_probe)/(T_probe + 238.88))
         Case Is < 0
           e_sat_probe = 0.61121*Enhance_factor1_probe*EXP((17.966*T_probe)/(T_probe + 247.15))
        EndSelect
    
       e_probe = (RH_probe*e_sat_probe)/100
    
       H2O_probe   = e_probe/((T_probe + T_0C_K)*Rv)                        'g/m^3
       rho_d_probe = (amb_press - e_probe)/((T_probe + T_0C_K)*Rd)          'g/m^3
     
       'Dew point temperature for general use for accurately computing the final dew point temperature
        Enhance_factor2_probe = 1.00072 + (3.46e-5)*amb_press                                                       'Eq. 9 from Appendix A of flux program manual

        x_tmp_probe           = LN(e_probe/(0.61121*Enhance_factor2_probe))                                         'For dew point temperature, assume that e is saturation water vapor pressure
        Td_gp_probe           = 240.97*x_tmp_probe/(17.502-x_tmp_probe)

        'Accurate dew point temperature
         Enhance_factor1_probe  = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Td_gp_probe + 30.6 - 0.38*amb_press)^2.0)  'Eq. 6 from Appendix A of flux program manual

         x_tmp_probe            = LN(e_probe/(0.61121*Enhance_factor1_probe))                                       'For dew point temperature, assume that e is saturation water vapor pressure

         Select Case Td_gp_probe                                                                                    'Eq. 11 from Appendix A of flux program manual
           Case Is >= 0
             T_DP_Probe = (238.88*x_tmp_probe)/(17.368 - x_tmp_probe)
           Case Is < 0
             T_DP_Probe = (247.15*x_tmp_probe)/(17.966 - x_tmp_probe)
          EndSelect      

    #EndIf

    #If (DVC_CDM_A116) Then 
    #If (SENSOR_SI111) Then

    '*** Beginning of SI111 measurements ***
    CDM_Therm109 (CDM_MODEL, CPI_ADDR_CDM, T_SI111_body, 1, 2*SI111_ANALOG_INPUT + 1, SI111_EXCITATION, 500, NTCH_FRQ_SLW, 1.0, 0)  'T_SI111_body in C
    m_SI111 = m0_SI111 + m1_SI111*T_SI111_body + m2_SI111*T_SI111_body*T_SI111_body                                   'parameter in target temp equation  
    b_SI111 = b0_SI111 + b1_SI111*T_SI111_body + b2_SI111*T_SI111_body*T_SI111_body                                   'parameter in target temp equation  

    CDM_VoltDiff (CDM_MODEL, CPI_ADDR_CDM, T_CANOPY, 1, mV200, SI111_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    T_CANOPY = ((T_SI111_body + T_0C_K)^4 + m_SI111*T_CANOPY + b_SI111)^0.25 - T_0C_K                                  'T_CANOPY in C
    '*** End of SI111 measurements ***
    #EndIf
    #EndIf
      
    #If (SENSOR_GPS) Then 
     'Correct input values of latitude and longitude using GPS data 
     If (gps_ready > gps_ready_best) Then 
        latitude = latitude_GPS_degree + latitude_GPS_minute/60
        hemisphere_NS = SGN (latitude_GPS_degree)     
        longitude = longitude_GPS_degree + longitude_GPS_minute/60 
        hemisphere_EW = SGN (longitude_GPS_degree)
        
        altitude = altitude_GPS - height_GPS16X
        
        gps_ready_best = gps_ready
     EndIf
    #EndIf 
    
    'Calculate solar position 
    RealTime(realtime_array(1))
    SolarPosition(solar_position_array(1), realtime_array(1), UTC_OFST*3600, latitude, longitude, altitude, 10*amb_press, amb_tmpr)
    hour_angle      = 180.0*hour_angle/PI                                                      'Radians to degrees 
    sun_declination = 180.0*sun_declination/PI                                                 'Radians to degrees
    
    If (sun_elevation > 0) Then 
       daytime = 1
       daytime_frac_scan_intv = SCAN_INTERVAL_WEIGHT
    Else
       daytime = 0
       daytime_frac_scan_intv = 0
    EndIf      
  
    '*** Updating files of station variables and planar fit angles ***
    'Determing whether or not the planar fit is used. It is used as long as one planar fit angle is not zero.
    For i_slow = 1 To NMBR_STN_VAR
      
    If  (stn_conf_array_prev(i_slow) <> stn_conf_array(i_slow)) Then
           
      Select Case i_slow
      'Update the pointing direction of CSAT
      Case 1
        If ((sonic_azimuth < 0.0) OR (sonic_azimuth > 360.0)) Then 
             sonic_azimuth = stn_conf_array_prev(1)             'Set back to previous value 
        EndIf           
   
     'Update geo-coordinates
      Case 2        
        If (ABS(latitude) > 90.0) Then  
            latitude = stn_conf_array_prev(2)                   'Set back to previous value 
        EndIf 
        
      Case 3
        If (hemisphere_NS = NORTH) Then
          latitude = ABS(latitude)
        Else
          latitude = - ABS(latitude)
        EndIf
        
      Case 4
        If (ABS(longitude) > 180.0) Then  
           longitude = stn_conf_array_prev(4)                   'Set back to previous value 
        EndIf
         
      Case 5
        If (hemisphere_EW = EAST) Then
          longitude = ABS(longitude)
        Else
          longitude = -ABS(longitude)
        EndIf
        
        Case 6         
        If ((altitude > 8000.0) OR (altitude < -1000.0))  Then  
           altitude = stn_conf_array_prev(6)                   'Set back to previous value 
        EndIf
         
       ' Update Aerodynamic height (z)
       Case 7, 8, 9, 10, 11
        If ((height_measurement > 250.0) OR (height_measurement < 0.2)) Then 
           height_measurement = stn_conf_array_prev(7)         'Set back to  previous value
        EndIf 
        
        If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND ((height_measurement > 100 OR height_measurement < 0.2))) Then 
          height_measurement = stn_conf_array_prev(7)          'Set back to previous value
        EndIf 
        
        If ((surface_type = FOREST) AND ((height_measurement > 250.0) OR (height_measurement < 0.2))) Then 
          height_measurement = stn_conf_array_prev(7)          'Set back to previous value
        EndIf  
        
        If ((surface_type < CROP) OR (surface_type > ICE)) Then   
          surface_type = stn_conf_array_prev(8) 
        EndIf   

        If ((surface_type = BARELAND) OR (surface_type = WATER) OR (surface_type = ICE)) Then 
           height_canopy = 0                                   'Set back to default value
        EndIf
 
        If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND (height_canopy > 15)) Then 
          height_canopy = stn_conf_array_prev(9)               'Set back to previous value
        EndIf  

        If ((surface_type = FOREST ) AND (height_canopy > 100.0)) Then 
          height_canopy = stn_conf_array_prev(9)               'Set back to previous value
        EndIf  
  
        If (displacement_user > height_measurement) OR (displacement_user < 0.0) Then  
           displacement_user = stn_conf_array_prev(10) 
        EndIf
  
        If (roughness_user > height_measurement) OR (roughness_user < 0.0) Then  
           roughness_user = stn_conf_array_prev(11) 
        EndIf

       Call Displacement_roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
        surface_type_text = surface_type_array(surface_type)
     
        For i_slow = 14 To 17
          If (stn_conf_array(i_slow) = 100.0*z_prev) Then           
              stn_conf_array(i_slow) = 100.0*z                 'Default value of 100*z for all sectors in different directions
          EndIf 
        Next 
        
        z_prev = z
                     
       Case 12, 13
       
         If (IRGASON) Then
            separation_x_irga = 0.0                                                          'Coordinate x of IRGASON IRGA measurement center in the CSAT coordinate system
            separation_y_irga = 0.0                                                          'Coordinate y of IRGASON IRGA measurement center in the CSAT coordinate system
         EndIf
  
         If (NOT IRGASON) Then
           If ((separation_x_irga < 0.04066) OR (separation_x_irga > 0.09126)) Then 
            separation_x_irga = stn_conf_array_prev(12)                                      'Set back to previous value                                
           EndIf 
           If ((separation_y_irga < 0.02905) OR (separation_y_irga > 0.03348)) Then 
            separation_y_irga = stn_conf_array_prev(13)                                      'Set back to previous value  
           EndIf
         EndIf
         
        Case 14, 15, 16, 17
          If ((stn_conf_array (i_slow) > 5000) OR (stn_conf_array (i_slow) < 0)) Then 
             stn_conf_array (i_slow) = stn_conf_array_prev (i_slow)                          'Set back to previous value  
          EndIf
      EndSelect
    
    #If (SENSOR_GPS) Then 
       If (height_GPS16X > height_measurement + 10) OR (height_GPS16X < 0) Then
         height_GPS16X = stn_conf_array_prev (18)                                             'Set back to previous value  
       EndIf   
    #EndIf 

    #If (SENSOR_FW) Then
      If ((separation_y_FW > 0.1) OR (separation_y_FW < 0)) Then 
         Select Case IRGASON
           Case True        
             separation_y_FW = 0.03259                                                         'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
                   
           Case False
             separation_y_FW = -0.02306                                                        'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
         EndSelect
      EndIf 
       
      If ((separation_x_FW > 0.30) OR (separation_x_FW < 0)) Then 
         separation_x_FW = stn_conf_array_prev (18 - 1*SENSOR_GPS)                            'Set back to previous value 
       EndIf 
       If ((FW_diameter <> FW05DIA) AND (FW_diameter <> FW1_DIA) AND (FW_diameter <> FW2_DIA) AND (FW_diameter <> FW3_DIA)) Then   
             FW_diameter = stn_conf_array_prev (20 - 1*SENSOR_GPS)                            'Set back to previous value 
       EndIf        
    #EndIf
  
    #If (SENSOR_HFP AND SENSOR_CS6XX AND (SENSOR_TCAV OR SENSOR_CS65X)) Then
          If (soil_bulk_density > 1800.0) OR (soil_bulk_density <600.0) Then 
             soil_bulk_density = stn_conf_array_prev (18 - 1*SENSOR_GPS -3*SENSOR_FW)          'Set back to previous value 
          EndIf 
          If (Cds < 500.0) OR (Cds > 1500.0) Then  
             Cds = stn_conf_array_prev (19 - 1*SENSOR_GPS -3*SENSOR_FW)                        'Set back to previous value 
          EndIf 
          If (thick_abv_SHFP > 0.30) OR (thick_abv_SHFP < 0.0) Then 
             thick_abv_SHFP = stn_conf_array_prev (20 - 1*SENSOR_GPS -3*SENSOR_FW)             'Set back to previous value 
          EndIf 
    #EndIf

          Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:stn_conf_array.dat", 0)               'Store the new values to the file.
          Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR)         'Update stn_conf_array_prev()
          ExitFor

    EndIf '(stn_conf_array_prev(i_slow) <> stn_conf_array(i_slow)) 

    If (i_slow <= 4) Then
      For j_slow = 1 To 4

      If (planar_fit_angle_conf_array_prev (j_slow, 1) <> planar_fit_angle_conf_array (j_slow, 1)) _
        OR (planar_fit_angle_conf_array_prev (j_slow, 2) <> planar_fit_angle_conf_array (j_slow, 2)) Then

        If ((ABS(planar_fit_angle_conf_array (j_slow, 1)) > 30) OR (ABS(planar_fit_angle_conf_array (j_slow, 2)) > 30)) Then   
            Move (planar_fit_angle_conf_array(j_slow, 1), 2, planar_fit_angle_conf_array_prev(j_slow, 1), 2)                   'Set back to previous value    
        
        Else
            Calfile (planar_fit_angle_conf_array (1,1),8,"CPU:planar_fit_angle_conf_array.dat",0)                              'Store the new values to the file.

            'Keep current values of planar_fit_angle_conf_array() in planar_fit_angle_prev_array() for later use as previous values
            Move (planar_fit_angle_conf_array_prev(j_slow, 1), 2, planar_fit_angle_conf_array(j_slow, 1), 2)

        EndIf       

        Planar_Fit_flg = FALSE
        For k_slow = 1 To 4
          If (planar_fit_angle_conf_array (k_slow, 1) <> 0) OR (planar_fit_angle_conf_array (k_slow, 2) <> 0) Then
            Planar_Fit_flg = TRUE
            ExitFor
          EndIf
        Next k_slow
        
      ExitFor
      EndIf
      Next j_slow

   EndIf '(i_slow <= 4)

   Next i_slow
    '*** End of updating files of station variables and planar fit angles ***

   '*** Estimate the days of MicroSD for more data storage ***    
   If (card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") Then
     '1000 connverts mSecond to Second, 24 hours/day, and 3600 seconds/hour
     card_storage_available_days = card_storage_available_days - (SLW_SCN_INTV/1000)/(24*3600)
     
     '*** Time_Series files 
      'Normal computation 
      days_actv_tbl_Time_Series = days_actv_tbl_Time_Series - (SLW_SCN_INTV/1000)/(24*3600)
      days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series
     
      'Computation immedately after file normal closing
      If ((LastFileName_Time_Series <> LastFileName_Time_Series_prev) AND (realtime_array(4)= 0)) Then
        card_bytes_free           = Status.CardBytesFree                                 'in bytes. 
        card_bytes_free_assgnd    = card_bytes_free_assgnd    - bytes_tbl_Time_Series
        days_actv_tbl_Time_Series = DAY_TSRS_CRD 
        days_more_tbl_Time_Series = days_more_tbl_Time_Series - DAY_TSRS_CRD
        days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series
        
        LastFileName_Time_Series_prev = LastFileName_Time_Series    
      EndIf
         
      '*** Flux files 
      'Normal computation      
      #If (ONE_FL_TABLE) Then 
      days_actv_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat - (SLW_SCN_INTV/1000)/(24*3600)     
      days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat + days_more_tbl_flux_CSFormat   
      #Else 
      days_actv_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes - (SLW_SCN_INTV/1000)/(24*3600)    
      days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes
      #EndIf
       
       'Computation immedately after file normal closing
      If ((LastFileName_flux_CSFormat <> LastFileName_flux_CSFormat_prev) AND (realtime_array(4) = 0)) Then 
      card_bytes_free           = Status.CardBytesFree                                  'in bytes. 
      card_bytes_free_assgnd    = card_bytes_free_assgnd - bytes_tbl_flux_CSFormat - bytes_tbl_AmeriFluxFormat 

      #If (ONE_FL_TABLE) Then 
      days_actv_tbl_flux_CSFormat = DAY_FlUX_CRD     
      days_more_tbl_flux_CSFormat = days_more_tbl_flux_CSFormat - DAY_FlUX_CRD
      days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat + days_more_tbl_flux_CSFormat  
    
      #Else 
      days_actv_tbl_flux_CSFormat_notes = DAY_FlUX_CRD
      days_more_tbl_flux_CSFormat_notes = days_more_tbl_flux_CSFormat_notes - DAY_FlUX_CRD
      days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes
      #EndIf 
      
      LastFileName_flux_CSFormat_prev = LastFileName_flux_CSFormat

      EndIf      

   Else 
     days_actv_tbl_Time_Series          = NaN
     days_more_tbl_Time_Series          = NaN
     days_totl_tbl_Time_Series          = NaN
     
   #If (ONE_FL_TABLE) Then 
      days_actv_tbl_flux_CSFormat       = NaN    
      days_more_tbl_flux_CSFormat       = NaN   
      days_totl_tbl_flux_CSFormat       = NaN   
   #Else 
      days_actv_tbl_flux_CSFormat_notes = NaN  
      days_more_tbl_flux_CSFormat_notes = NaN
      days_totl_tbl_flux_CSFormat_notes = NaN
   #EndIf 

      card_storage_available_days       = NaN 
      
   EndIf 
   

   
  'Computaion immediately after MicrSD is replaced 
  If ((card_storage_available_days = NaN) AND (Status.CardStatus = "Card OK.")) Then

    're-estimate card_storage_available_days 
     card_bytes_free = Status.CardBytesFree                               'in bytes. 

   If (card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") Then

      day_snc_0101_1990 = SecsSince1990(status.TimeStamp(1,1), 1)/(24*3600)
            
      days_actv_tbl_Time_Series = DAY_TSRS_CRD - (day_snc_0101_1990 MOD DAY_TSRS_CRD)  

     'Pre-set, assume no extra storage in MicroSD
      days_totl_tbl_Time_Series = days_actv_tbl_Time_Series 
  
     #If (ONE_FL_TABLE) Then 
       
      days_actv_tbl_flux_CSFormat = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD) 
      
      'Pre-set, assume no extra storage in MicroSD     
      days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat 
    
     'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat ueses. 
     'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.    
     card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat 
    
     #Else 
      days_actv_tbl_flux_CSFormat_notes = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD)

     'Pre-set, assume no extra storage in MicroSD
      days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes
    
     'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat and Flux_Notes ues. 
     'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.   
      card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat_notes/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat  

    #EndIf 
     
      card_bytes_free_unassgnd   = card_bytes_free - card_bytes_free_assgnd 
      days_more_tbl_Time_Series = 0                                            'Reset after MicroSD abnormal including the replacement of MicroSD

  #If (ONE_FL_TABLE) Then
      days_more_tbl_flux_CSFormat = 0                                          'Reset after MicroSD abnormal including the replacement of MicroSD 
      
     While (((days_totl_tbl_flux_CSFormat >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR _
           ((days_totl_tbl_flux_CSFormat < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat))))      

       If (days_totl_tbl_flux_CSFormat >= days_totl_tbl_Time_Series) Then
          card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series 
          days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
          days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series    
        
       Else 
          card_bytes_free_assgnd      = card_bytes_free_assgnd      + bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat 
          days_more_tbl_flux_CSFormat = days_more_tbl_flux_CSFormat + DAY_FLUX_CRD
          days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat + days_more_tbl_flux_CSFormat    

        EndIf
        
         card_bytes_free_unassgnd  = card_bytes_free - card_bytes_free_assgnd  
 
     Wend 
    
        If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat) Then 
          card_storage_available_days = days_totl_tbl_flux_CSFormat
        Else
          card_storage_available_days = days_totl_tbl_Time_Series
        EndIf  

   #Else
     
     days_more_tbl_flux_CSFormat_notes = 0                               'Reset after MicroSD abnormal including the replacement of MicroSD 
    
     While (((days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR _
            ((days_totl_tbl_flux_CSFormat_notes < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat + bytes_tbl_flux_notes))))      

       If (days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) Then
          card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series 
          days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
          days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series   
        
       Else 
          card_bytes_free_assgnd            = card_bytes_free_assgnd + bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat + bytes_tbl_flux_notes 
          days_more_tbl_flux_CSFormat_notes = days_more_tbl_flux_CSFormat_notes + DAY_FLUX_CRD
          days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes   

       EndIf 
      
       card_bytes_free_unassgnd  = card_bytes_free - card_bytes_free_assgnd          

    Wend 

        If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat_notes) Then 
          card_storage_available_days = days_totl_tbl_flux_CSFormat_notes
        Else
          card_storage_available_days = days_totl_tbl_Time_Series
        EndIf  

  #EndIf 
        LastFileName_Time_Series_prev   = LastFileName_Time_Series
        LastFileName_flux_CSFormat_prev = LastFileName_flux_CSFormat  
          

 Else
     days_actv_tbl_Time_Series          = NaN
     days_more_tbl_Time_Series          = NaN
     days_totl_tbl_Time_Series          = NaN
     
   #If (ONE_FL_TABLE) Then 
      days_actv_tbl_flux_CSFormat       = NaN    
      days_more_tbl_flux_CSFormat       = NaN   
      days_totl_tbl_flux_CSFormat       = NaN   
   #Else 
      days_actv_tbl_flux_CSFormat_notes = NaN  
      days_more_tbl_flux_CSFormat_notes = NaN
      days_totl_tbl_flux_CSFormat_notes = NaN
   #EndIf 

      card_storage_available_days       = NaN 
         
   EndIf '(card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") 
     
  EndIf '((card_storage_available_days = NaN) AND (Status.CardStatus = "Card OK."))  
   '*** End of Checking how many days left for data storage in MicroSD **** 

    slowsequence_finished_f = TRUE
  NextScan
EndProg
